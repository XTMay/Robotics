# 实验指导与可视化工具

## 1. 逐步实验指导

### 1.1 实验环境搭建指导

#### Step 1: 基础环境安装

```bash
#!/bin/bash
# 环境安装脚本：setup_environment.sh

echo "=== 强化学习与传感器融合项目环境搭建 ==="

# 检查操作系统
if [[ "$OSTYPE" == "linux-gnu"* ]]; then
    echo "检测到Linux系统，开始安装..."

    # 更新系统包
    sudo apt update && sudo apt upgrade -y

    # 安装Python 3.8+
    sudo apt install python3.8 python3.8-dev python3.8-venv python3-pip -y

    # 安装系统依赖
    sudo apt install build-essential cmake git wget curl -y
    sudo apt install libatlas-base-dev liblapack-dev gfortran -y
    sudo apt install libjpeg-dev libpng-dev -y

elif [[ "$OSTYPE" == "darwin"* ]]; then
    echo "检测到macOS系统，开始安装..."

    # 检查Homebrew
    if ! command -v brew &> /dev/null; then
        echo "安装Homebrew..."
        /bin/bash -c "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)"
    fi

    # 安装依赖
    brew install python@3.8 cmake git wget
    brew install openblas lapack

else
    echo "不支持的操作系统: $OSTYPE"
    exit 1
fi

# 创建虚拟环境
echo "创建Python虚拟环境..."
python3 -m venv venv_rl_fusion
source venv_rl_fusion/bin/activate

# 升级pip
pip install --upgrade pip setuptools wheel

# 安装核心依赖
echo "安装Python依赖包..."
pip install torch torchvision torchaudio
pip install numpy scipy matplotlib seaborn
pip install pandas scikit-learn
pip install jupyter ipykernel
pip install tqdm psutil

# 安装机器人相关包
pip install gymnasium[classic_control]
pip install stable-baselines3
pip install opencv-python
pip install plotly dash

# 安装可选的ROS包（如果需要）
read -p "是否安装ROS Noetic? (y/n): " install_ros
if [[ $install_ros == "y" ]]; then
    if [[ "$OSTYPE" == "linux-gnu"* ]]; then
        echo "安装ROS Noetic..."
        sudo sh -c 'echo "deb http://packages.ros.org/ros/ubuntu $(lsb_release -sc) main" > /etc/apt/sources.list.d/ros-latest.list'
        sudo apt-key adv --keyserver 'hkp://keyserver.ubuntu.com:80' --recv-key C1CF6E31E6BADE8868B172B4F42ED6FBAB17C654
        sudo apt update
        sudo apt install ros-noetic-desktop-full -y
        sudo apt install python3-rosdep python3-rosinstall python3-rosinstall-generator python3-wstool build-essential -y
        sudo rosdep init && rosdep update
        echo "source /opt/ros/noetic/setup.bash" >> ~/.bashrc
    else
        echo "ROS仅支持Linux系统"
    fi
fi

# 创建项目目录结构
echo "创建项目目录..."
mkdir -p project_rl_fusion/{src,data,models,results,docs,tests}

# 创建配置文件
cat > project_rl_fusion/requirements.txt << EOF
torch>=1.8.0
numpy>=1.21.0
scipy>=1.7.0
matplotlib>=3.3.0
seaborn>=0.11.0
pandas>=1.3.0
scikit-learn>=1.0.0
jupyter>=1.0.0
tqdm>=4.62.0
psutil>=5.8.0
gymnasium>=0.26.0
stable-baselines3>=1.6.0
opencv-python>=4.5.0
plotly>=5.0.0
dash>=2.0.0
EOF

echo "=== 环境搭建完成 ==="
echo "激活虚拟环境: source venv_rl_fusion/bin/activate"
echo "进入项目目录: cd project_rl_fusion"
```

#### Step 2: 验证安装

```python
# verification_script.py
"""
环境验证脚本
运行此脚本验证所有依赖是否正确安装
"""

import sys
import importlib
import torch
import numpy as np
import matplotlib.pyplot as plt

def check_python_version():
    """检查Python版本"""
    version = sys.version_info
    print(f"Python版本: {version.major}.{version.minor}.{version.micro}")

    if version.major >= 3 and version.minor >= 8:
        print("✓ Python版本符合要求")
        return True
    else:
        print("✗ Python版本过低，需要3.8+")
        return False

def check_package(package_name, import_name=None):
    """检查包是否安装"""
    if import_name is None:
        import_name = package_name

    try:
        importlib.import_module(import_name)
        print(f"✓ {package_name} 已安装")
        return True
    except ImportError:
        print(f"✗ {package_name} 未安装")
        return False

def check_gpu_availability():
    """检查GPU可用性"""
    if torch.cuda.is_available():
        gpu_count = torch.cuda.device_count()
        gpu_name = torch.cuda.get_device_name(0)
        print(f"✓ GPU可用: {gpu_count}个设备")
        print(f"  主要GPU: {gpu_name}")
        return True
    else:
        print("! GPU不可用，将使用CPU")
        return False

def main():
    """主验证函数"""
    print("=== 环境验证 ===")

    # 检查Python版本
    python_ok = check_python_version()

    # 检查核心包
    packages = [
        ('NumPy', 'numpy'),
        ('SciPy', 'scipy'),
        ('Matplotlib', 'matplotlib'),
        ('PyTorch', 'torch'),
        ('Pandas', 'pandas'),
        ('Scikit-learn', 'sklearn'),
        ('Jupyter', 'jupyter'),
        ('OpenCV', 'cv2'),
        ('Gymnasium', 'gymnasium'),
        ('Stable-Baselines3', 'stable_baselines3')
    ]

    package_status = []
    for package_name, import_name in packages:
        status = check_package(package_name, import_name)
        package_status.append(status)

    # 检查GPU
    gpu_available = check_gpu_availability()

    # 运行简单测试
    print("\n=== 功能测试 ===")

    try:
        # NumPy测试
        arr = np.random.randn(100, 100)
        result = np.dot(arr, arr.T)
        print("✓ NumPy矩阵运算正常")
    except Exception as e:
        print(f"✗ NumPy测试失败: {e}")

    try:
        # PyTorch测试
        x = torch.randn(10, 10)
        y = torch.mm(x, x.t())
        if torch.cuda.is_available():
            x_gpu = x.cuda()
            y_gpu = torch.mm(x_gpu, x_gpu.t())
            print("✓ PyTorch GPU运算正常")
        else:
            print("✓ PyTorch CPU运算正常")
    except Exception as e:
        print(f"✗ PyTorch测试失败: {e}")

    try:
        # Matplotlib测试
        fig, ax = plt.subplots()
        ax.plot([1, 2, 3], [1, 4, 9])
        plt.close(fig)
        print("✓ Matplotlib绘图正常")
    except Exception as e:
        print(f"✗ Matplotlib测试失败: {e}")

    # 总结
    print("\n=== 验证总结 ===")
    total_packages = len(packages)
    installed_packages = sum(package_status)

    print(f"Python版本: {'符合要求' if python_ok else '需要升级'}")
    print(f"依赖包: {installed_packages}/{total_packages} 已安装")
    print(f"GPU支持: {'可用' if gpu_available else '不可用'}")

    if python_ok and installed_packages == total_packages:
        print("🎉 环境验证成功！可以开始项目开发")
        return True
    else:
        print("❌ 环境验证失败，请检查安装")
        return False

if __name__ == "__main__":
    success = main()
    sys.exit(0 if success else 1)
```

### 1.2 实验一：基础算法验证

#### 实验目标
验证Q-Learning和卡尔曼滤波的基本实现

#### 实验步骤

```python
# experiment_1_basic_verification.py
"""
实验一：基础算法验证
"""

import numpy as np
import matplotlib.pyplot as plt
from collections import defaultdict, deque
import time

class ExperimentLogger:
    """实验日志记录器"""

    def __init__(self, experiment_name):
        self.experiment_name = experiment_name
        self.start_time = time.time()
        self.logs = []
        self.metrics = {}

        print(f"=== 开始实验: {experiment_name} ===")
        print(f"开始时间: {time.strftime('%Y-%m-%d %H:%M:%S')}")

    def log(self, message):
        """记录日志"""
        timestamp = time.time() - self.start_time
        log_entry = f"[{timestamp:.2f}s] {message}"
        print(log_entry)
        self.logs.append(log_entry)

    def record_metric(self, name, value):
        """记录指标"""
        if name not in self.metrics:
            self.metrics[name] = []
        self.metrics[name].append(value)

    def finish(self):
        """结束实验"""
        duration = time.time() - self.start_time
        print(f"=== 实验完成: {self.experiment_name} ===")
        print(f"总耗时: {duration:.2f}秒")
        return duration

def experiment_1_q_learning():
    """实验1：Q-Learning算法验证"""

    logger = ExperimentLogger("Q-Learning算法验证")

    # 步骤1: 创建简单环境
    logger.log("步骤1: 创建GridWorld环境")

    class SimpleGridWorld:
        def __init__(self, size=5):
            self.size = size
            self.reset()

        def reset(self):
            self.state = (0, 0)
            self.goal = (self.size-1, self.size-1)
            return self.state

        def step(self, action):
            x, y = self.state

            if action == 0 and x > 0:  # 上
                x -= 1
            elif action == 1 and x < self.size-1:  # 下
                x += 1
            elif action == 2 and y > 0:  # 左
                y -= 1
            elif action == 3 and y < self.size-1:  # 右
                y += 1

            self.state = (x, y)

            if self.state == self.goal:
                reward = 10
                done = True
            else:
                reward = -0.1
                done = False

            return self.state, reward, done

    env = SimpleGridWorld(5)
    logger.log(f"环境创建完成: {env.size}x{env.size}网格")

    # 步骤2: 实现Q-Learning
    logger.log("步骤2: 实现Q-Learning算法")

    class QLearningAgent:
        def __init__(self, actions, lr=0.1, gamma=0.9, epsilon=0.1):
            self.actions = actions
            self.lr = lr
            self.gamma = gamma
            self.epsilon = epsilon
            self.q_table = defaultdict(lambda: np.zeros(len(actions)))

        def get_action(self, state):
            if np.random.random() < self.epsilon:
                return np.random.choice(self.actions)
            else:
                return np.argmax(self.q_table[state])

        def learn(self, state, action, reward, next_state):
            current_q = self.q_table[state][action]
            next_max_q = np.max(self.q_table[next_state])

            td_error = reward + self.gamma * next_max_q - current_q
            self.q_table[state][action] += self.lr * td_error

            return abs(td_error)

    agent = QLearningAgent([0, 1, 2, 3])
    logger.log("Q-Learning智能体创建完成")

    # 步骤3: 训练智能体
    logger.log("步骤3: 开始训练")

    num_episodes = 500
    rewards_per_episode = []
    td_errors = []

    for episode in range(num_episodes):
        state = env.reset()
        total_reward = 0
        episode_td_errors = []

        for step in range(100):
            action = agent.get_action(state)
            next_state, reward, done = env.step(action)

            td_error = agent.learn(state, action, reward, next_state)
            episode_td_errors.append(td_error)

            state = next_state
            total_reward += reward

            if done:
                break

        rewards_per_episode.append(total_reward)
        td_errors.extend(episode_td_errors)

        logger.record_metric('episode_reward', total_reward)
        logger.record_metric('avg_td_error', np.mean(episode_td_errors))

        if episode % 100 == 0:
            avg_reward = np.mean(rewards_per_episode[-100:])
            logger.log(f"Episode {episode}: 平均奖励 = {avg_reward:.2f}")

    # 步骤4: 评估性能
    logger.log("步骤4: 评估学习效果")

    # 测试学习后的策略
    agent.epsilon = 0  # 关闭探索
    test_rewards = []

    for _ in range(100):
        state = env.reset()
        total_reward = 0

        for step in range(100):
            action = agent.get_action(state)
            state, reward, done = env.step(action)
            total_reward += reward

            if done:
                break

        test_rewards.append(total_reward)

    success_rate = sum(1 for r in test_rewards if r > 5) / len(test_rewards)
    avg_test_reward = np.mean(test_rewards)

    logger.log(f"测试结果:")
    logger.log(f"  成功率: {success_rate:.2%}")
    logger.log(f"  平均奖励: {avg_test_reward:.2f}")

    # 步骤5: 可视化结果
    logger.log("步骤5: 生成可视化结果")

    fig, axes = plt.subplots(2, 2, figsize=(12, 10))

    # 学习曲线
    axes[0, 0].plot(rewards_per_episode, alpha=0.3)
    axes[0, 0].plot(np.convolve(rewards_per_episode, np.ones(50)/50, mode='valid'), linewidth=2)
    axes[0, 0].set_title('Q-Learning学习曲线')
    axes[0, 0].set_xlabel('Episode')
    axes[0, 0].set_ylabel('总奖励')
    axes[0, 0].grid(True)

    # TD误差
    axes[0, 1].plot(td_errors[:1000], alpha=0.7)
    axes[0, 1].set_title('TD误差变化')
    axes[0, 1].set_xlabel('训练步骤')
    axes[0, 1].set_ylabel('TD误差')
    axes[0, 1].grid(True)

    # Q值热力图
    q_values = np.zeros((env.size, env.size))
    for i in range(env.size):
        for j in range(env.size):
            state = (i, j)
            q_values[i, j] = np.max(agent.q_table[state])

    im = axes[1, 0].imshow(q_values, cmap='viridis')
    axes[1, 0].set_title('状态值函数')
    plt.colorbar(im, ax=axes[1, 0])

    # 最优策略
    policy = np.zeros((env.size, env.size))
    for i in range(env.size):
        for j in range(env.size):
            state = (i, j)
            policy[i, j] = np.argmax(agent.q_table[state])

    axes[1, 1].imshow(policy, cmap='tab10')
    axes[1, 1].set_title('最优策略')

    # 添加箭头表示动作
    for i in range(env.size):
        for j in range(env.size):
            action = int(policy[i, j])
            if action == 0:  # 上
                axes[1, 1].arrow(j, i, 0, -0.3, head_width=0.1, head_length=0.1, fc='white', ec='white')
            elif action == 1:  # 下
                axes[1, 1].arrow(j, i, 0, 0.3, head_width=0.1, head_length=0.1, fc='white', ec='white')
            elif action == 2:  # 左
                axes[1, 1].arrow(j, i, -0.3, 0, head_width=0.1, head_length=0.1, fc='white', ec='white')
            elif action == 3:  # 右
                axes[1, 1].arrow(j, i, 0.3, 0, head_width=0.1, head_length=0.1, fc='white', ec='white')

    plt.tight_layout()
    plt.savefig('experiment_1_q_learning_results.png', dpi=300, bbox_inches='tight')
    plt.show()

    duration = logger.finish()

    return {
        'success_rate': success_rate,
        'avg_reward': avg_test_reward,
        'duration': duration,
        'convergence_episodes': num_episodes
    }

def experiment_2_kalman_filter():
    """实验2：卡尔曼滤波验证"""

    logger = ExperimentLogger("卡尔曼滤波验证")

    # 步骤1: 创建一维跟踪问题
    logger.log("步骤1: 设置一维物体跟踪问题")

    dt = 0.1
    time_steps = 200

    # 系统参数
    F = np.array([[1, dt], [0, 1]])  # 状态转移矩阵
    H = np.array([[1, 0]])           # 观测矩阵
    Q = np.array([[0.01, 0], [0, 0.01]])  # 过程噪声
    R = np.array([[1.0]])            # 观测噪声

    x0 = np.array([[0], [1]])        # 初始状态
    P0 = np.eye(2)                   # 初始协方差

    logger.log(f"系统参数设置完成，仿真时长: {time_steps * dt:.1f}秒")

    # 步骤2: 实现卡尔曼滤波器
    logger.log("步骤2: 实现卡尔曼滤波器")

    class KalmanFilter:
        def __init__(self, F, H, Q, R, x0, P0):
            self.F = F
            self.H = H
            self.Q = Q
            self.R = R
            self.x = x0
            self.P = P0
            self.history = {'x': [], 'P': []}

        def predict(self):
            self.x = self.F @ self.x
            self.P = self.F @ self.P @ self.F.T + self.Q

        def update(self, z):
            S = self.H @ self.P @ self.H.T + self.R
            K = self.P @ self.H.T @ np.linalg.inv(S)

            y = z - self.H @ self.x
            self.x = self.x + K @ y
            self.P = (np.eye(len(self.x)) - K @ self.H) @ self.P

            self.history['x'].append(self.x.copy())
            self.history['P'].append(self.P.copy())

            return y, S  # 返回创新和创新协方差

    kf = KalmanFilter(F, H, Q, R, x0, P0)
    logger.log("卡尔曼滤波器创建完成")

    # 步骤3: 生成仿真数据
    logger.log("步骤3: 生成真实轨迹和观测数据")

    true_positions = []
    true_velocities = []
    observations = []

    true_pos = 0
    true_vel = 1

    for t in range(time_steps):
        # 真实系统演化
        true_pos += true_vel * dt
        true_vel += np.random.normal(0, 0.1)  # 过程噪声

        true_positions.append(true_pos)
        true_velocities.append(true_vel)

        # 生成观测
        obs = true_pos + np.random.normal(0, 1.0)
        observations.append(obs)

    logger.log(f"生成了{len(observations)}个观测数据点")

    # 步骤4: 运行滤波
    logger.log("步骤4: 运行卡尔曼滤波")

    estimates = []
    innovations = []
    innovation_covariances = []

    for obs in observations:
        kf.predict()
        innovation, innovation_cov = kf.update(np.array([[obs]]))

        estimates.append(kf.x[0, 0])
        innovations.append(innovation[0, 0])
        innovation_covariances.append(innovation_cov[0, 0])

        logger.record_metric('position_estimate', kf.x[0, 0])
        logger.record_metric('velocity_estimate', kf.x[1, 0])
        logger.record_metric('innovation', innovation[0, 0])

    # 步骤5: 性能评估
    logger.log("步骤5: 评估滤波性能")

    position_errors = np.array(estimates) - np.array(true_positions)
    rmse = np.sqrt(np.mean(position_errors**2))
    mae = np.mean(np.abs(position_errors))

    # 创新序列统计检验
    innovation_mean = np.mean(innovations)
    innovation_std = np.std(innovations)
    theoretical_std = np.sqrt(np.mean(innovation_covariances))

    logger.log(f"性能指标:")
    logger.log(f"  RMSE: {rmse:.3f}")
    logger.log(f"  MAE: {mae:.3f}")
    logger.log(f"  创新序列均值: {innovation_mean:.3f} (理论值: 0)")
    logger.log(f"  创新序列标准差: {innovation_std:.3f} (理论值: {theoretical_std:.3f})")

    # 步骤6: 可视化结果
    logger.log("步骤6: 生成可视化结果")

    fig, axes = plt.subplots(2, 2, figsize=(12, 10))

    time_axis = np.arange(len(true_positions)) * dt

    # 位置跟踪
    axes[0, 0].plot(time_axis, true_positions, 'g-', label='真实位置', linewidth=2)
    axes[0, 0].plot(time_axis, observations, 'r.', label='观测', alpha=0.6)
    axes[0, 0].plot(time_axis, estimates, 'b-', label='卡尔曼估计', linewidth=2)
    axes[0, 0].set_xlabel('时间 (s)')
    axes[0, 0].set_ylabel('位置')
    axes[0, 0].set_title('位置跟踪')
    axes[0, 0].legend()
    axes[0, 0].grid(True)

    # 估计误差
    axes[0, 1].plot(time_axis, position_errors, 'r-', linewidth=2)
    axes[0, 1].axhline(0, color='k', linestyle='--', alpha=0.5)
    axes[0, 1].set_xlabel('时间 (s)')
    axes[0, 1].set_ylabel('位置误差')
    axes[0, 1].set_title(f'位置估计误差 (RMSE={rmse:.3f})')
    axes[0, 1].grid(True)

    # 创新序列
    axes[1, 0].plot(time_axis, innovations, 'b-', alpha=0.7)
    axes[1, 0].axhline(0, color='k', linestyle='--', alpha=0.5)
    axes[1, 0].set_xlabel('时间 (s)')
    axes[1, 0].set_ylabel('创新')
    axes[1, 0].set_title('创新序列')
    axes[1, 0].grid(True)

    # 不确定性演化
    uncertainties = [np.sqrt(P[0, 0]) for P in kf.history['P']]
    axes[1, 1].plot(time_axis, uncertainties, 'purple', linewidth=2)
    axes[1, 1].set_xlabel('时间 (s)')
    axes[1, 1].set_ylabel('位置不确定性 (σ)')
    axes[1, 1].set_title('估计不确定性')
    axes[1, 1].grid(True)

    plt.tight_layout()
    plt.savefig('experiment_2_kalman_filter_results.png', dpi=300, bbox_inches='tight')
    plt.show()

    duration = logger.finish()

    return {
        'rmse': rmse,
        'mae': mae,
        'innovation_consistency': abs(innovation_std - theoretical_std) < 0.1,
        'duration': duration
    }

def run_experiment_1():
    """运行实验一：基础算法验证"""

    print("=" * 60)
    print("实验一：基础算法验证")
    print("=" * 60)

    # 运行Q-Learning实验
    q_learning_results = experiment_1_q_learning()

    print("\n" + "-" * 40)

    # 运行卡尔曼滤波实验
    kalman_results = experiment_2_kalman_filter()

    # 实验总结
    print("\n" + "=" * 60)
    print("实验一总结")
    print("=" * 60)

    print(f"Q-Learning实验:")
    print(f"  成功率: {q_learning_results['success_rate']:.2%}")
    print(f"  平均奖励: {q_learning_results['avg_reward']:.2f}")
    print(f"  训练时间: {q_learning_results['duration']:.2f}秒")

    print(f"\n卡尔曼滤波实验:")
    print(f"  RMSE: {kalman_results['rmse']:.3f}")
    print(f"  MAE: {kalman_results['mae']:.3f}")
    print(f"  创新一致性: {'通过' if kalman_results['innovation_consistency'] else '未通过'}")
    print(f"  滤波时间: {kalman_results['duration']:.2f}秒")

    # 判断实验是否成功
    q_learning_success = q_learning_results['success_rate'] > 0.8
    kalman_success = kalman_results['rmse'] < 1.0 and kalman_results['innovation_consistency']

    if q_learning_success and kalman_success:
        print("\n🎉 实验一验证成功！基础算法实现正确")
        return True
    else:
        print("\n❌ 实验一验证失败，请检查算法实现")
        return False

if __name__ == "__main__":
    success = run_experiment_1()
    print(f"\n实验一结果: {'成功' if success else '失败'}")
```

### 1.3 实验二：深度强化学习导航

#### 实验目标
实现并训练DQN智能体进行网格世界导航

#### 实验步骤

```python
# experiment_2_dqn_navigation.py
"""
实验二：深度强化学习导航
"""

import torch
import torch.nn as nn
import torch.optim as optim
import numpy as np
import matplotlib.pyplot as plt
from collections import deque
import random
import time

class ExperimentTracker:
    """实验追踪器"""

    def __init__(self, experiment_name):
        self.experiment_name = experiment_name
        self.metrics = {}
        self.checkpoints = {}
        self.start_time = time.time()

        print(f"开始实验: {experiment_name}")

    def log_metric(self, name, value, step):
        """记录指标"""
        if name not in self.metrics:
            self.metrics[name] = {'values': [], 'steps': []}

        self.metrics[name]['values'].append(value)
        self.metrics[name]['steps'].append(step)

    def save_checkpoint(self, name, data):
        """保存检查点"""
        self.checkpoints[name] = {
            'data': data,
            'timestamp': time.time() - self.start_time
        }

    def plot_metrics(self):
        """绘制指标"""
        if not self.metrics:
            return

        num_metrics = len(self.metrics)
        fig, axes = plt.subplots(1, num_metrics, figsize=(5*num_metrics, 4))

        if num_metrics == 1:
            axes = [axes]

        for i, (metric_name, data) in enumerate(self.metrics.items()):
            axes[i].plot(data['steps'], data['values'])
            axes[i].set_title(metric_name)
            axes[i].set_xlabel('Step')
            axes[i].set_ylabel('Value')
            axes[i].grid(True)

        plt.tight_layout()
        plt.show()

def experiment_2_dqn_navigation():
    """实验2：DQN导航训练"""

    tracker = ExperimentTracker("DQN导航训练")

    print("步骤1: 创建导航环境")

    class NavigationEnvironment:
        def __init__(self, size=10, num_obstacles=10):
            self.size = size
            self.num_obstacles = num_obstacles
            self.reset()

        def reset(self):
            # 生成地图
            self.grid = np.zeros((self.size, self.size))

            # 随机放置障碍物
            obstacle_positions = set()
            while len(obstacle_positions) < self.num_obstacles:
                pos = (np.random.randint(1, self.size-1), np.random.randint(1, self.size-1))
                obstacle_positions.add(pos)

            for pos in obstacle_positions:
                self.grid[pos] = 1

            # 设置起点和终点
            self.start_pos = (0, 0)
            self.goal_pos = (self.size-1, self.size-1)
            self.grid[self.start_pos] = 0
            self.grid[self.goal_pos] = 0

            self.agent_pos = self.start_pos
            self.steps = 0
            self.max_steps = self.size * self.size

            return self.get_state()

        def get_state(self):
            """获取状态表示"""
            # 简化状态：智能体位置 + 目标位置 + 周围环境
            state = []

            # 智能体位置（归一化）
            state.extend([self.agent_pos[0] / self.size, self.agent_pos[1] / self.size])

            # 目标位置（归一化）
            state.extend([self.goal_pos[0] / self.size, self.goal_pos[1] / self.size])

            # 到目标的距离和角度
            dx = self.goal_pos[0] - self.agent_pos[0]
            dy = self.goal_pos[1] - self.agent_pos[1]
            distance = np.sqrt(dx**2 + dy**2) / (self.size * np.sqrt(2))
            angle = np.arctan2(dy, dx) / np.pi
            state.extend([distance, np.sin(angle), np.cos(angle)])

            # 周围8个方向的障碍物信息
            directions = [(-1,-1), (-1,0), (-1,1), (0,-1), (0,1), (1,-1), (1,0), (1,1)]
            for dx, dy in directions:
                new_x, new_y = self.agent_pos[0] + dx, self.agent_pos[1] + dy
                if 0 <= new_x < self.size and 0 <= new_y < self.size:
                    obstacle = self.grid[new_x, new_y]
                else:
                    obstacle = 1  # 边界视为障碍物
                state.append(obstacle)

            return np.array(state, dtype=np.float32)

        def step(self, action):
            """执行动作"""
            # 动作映射：0-上，1-下，2-左，3-右
            moves = [(-1, 0), (1, 0), (0, -1), (0, 1)]
            dx, dy = moves[action]

            new_x = self.agent_pos[0] + dx
            new_y = self.agent_pos[1] + dy

            # 检查边界和障碍物
            if (0 <= new_x < self.size and 0 <= new_y < self.size and
                self.grid[new_x, new_y] == 0):
                self.agent_pos = (new_x, new_y)
                collision = False
            else:
                collision = True

            self.steps += 1

            # 计算奖励
            if self.agent_pos == self.goal_pos:
                reward = 100
                done = True
            elif collision:
                reward = -10
                done = False
            elif self.steps >= self.max_steps:
                reward = -50
                done = True
            else:
                # 距离奖励
                distance = np.sqrt((self.goal_pos[0] - self.agent_pos[0])**2 +
                                 (self.goal_pos[1] - self.agent_pos[1])**2)
                reward = -0.1 - distance * 0.01
                done = False

            return self.get_state(), reward, done

        def render(self):
            """可视化环境"""
            grid_display = self.grid.copy()
            grid_display[self.agent_pos] = 0.5  # 智能体
            grid_display[self.goal_pos] = 0.7   # 目标

            plt.imshow(grid_display, cmap='RdYlBu')
            plt.title(f"步数: {self.steps}")
            plt.colorbar()
            plt.show()

    env = NavigationEnvironment(size=8, num_obstacles=8)
    state_size = len(env.get_state())
    action_size = 4

    print(f"环境创建完成: {env.size}x{env.size}, 状态维度: {state_size}")

    print("步骤2: 构建DQN网络")

    class DQNNetwork(nn.Module):
        def __init__(self, state_size, action_size, hidden_size=64):
            super(DQNNetwork, self).__init__()
            self.network = nn.Sequential(
                nn.Linear(state_size, hidden_size),
                nn.ReLU(),
                nn.Linear(hidden_size, hidden_size),
                nn.ReLU(),
                nn.Linear(hidden_size, action_size)
            )

        def forward(self, x):
            return self.network(x)

    class DQNAgent:
        def __init__(self, state_size, action_size, lr=1e-3):
            self.state_size = state_size
            self.action_size = action_size
            self.epsilon = 1.0
            self.epsilon_min = 0.01
            self.epsilon_decay = 0.995

            self.device = torch.device("cuda" if torch.cuda.is_available() else "cpu")
            self.q_network = DQNNetwork(state_size, action_size).to(self.device)
            self.target_network = DQNNetwork(state_size, action_size).to(self.device)
            self.optimizer = optim.Adam(self.q_network.parameters(), lr=lr)

            self.memory = deque(maxlen=10000)
            self.batch_size = 32
            self.update_frequency = 4
            self.target_update_frequency = 100
            self.learn_step = 0

        def remember(self, state, action, reward, next_state, done):
            self.memory.append((state, action, reward, next_state, done))

        def act(self, state):
            if np.random.random() <= self.epsilon:
                return random.choice(range(self.action_size))

            state = torch.FloatTensor(state).unsqueeze(0).to(self.device)
            q_values = self.q_network(state)
            return q_values.argmax().item()

        def learn(self):
            if len(self.memory) < self.batch_size:
                return 0

            batch = random.sample(self.memory, self.batch_size)
            states, actions, rewards, next_states, dones = zip(*batch)

            states = torch.FloatTensor(states).to(self.device)
            actions = torch.LongTensor(actions).to(self.device)
            rewards = torch.FloatTensor(rewards).to(self.device)
            next_states = torch.FloatTensor(next_states).to(self.device)
            dones = torch.BoolTensor(dones).to(self.device)

            current_q_values = self.q_network(states).gather(1, actions.unsqueeze(1))
            next_q_values = self.target_network(next_states).max(1)[0].detach()
            target_q_values = rewards + (0.99 * next_q_values * ~dones)

            loss = nn.MSELoss()(current_q_values.squeeze(), target_q_values)

            self.optimizer.zero_grad()
            loss.backward()
            self.optimizer.step()

            if self.learn_step % self.target_update_frequency == 0:
                self.target_network.load_state_dict(self.q_network.state_dict())

            if self.epsilon > self.epsilon_min:
                self.epsilon *= self.epsilon_decay

            self.learn_step += 1
            return loss.item()

    agent = DQNAgent(state_size, action_size)
    print(f"DQN智能体创建完成，使用设备: {agent.device}")

    print("步骤3: 开始训练")

    num_episodes = 1000
    scores = deque(maxlen=100)
    losses = []

    for episode in range(num_episodes):
        state = env.reset()
        total_reward = 0
        episode_loss = []

        for step in range(env.max_steps):
            action = agent.act(state)
            next_state, reward, done = env.step(action)

            agent.remember(state, action, reward, next_state, done)

            if step % agent.update_frequency == 0:
                loss = agent.learn()
                if loss > 0:
                    episode_loss.append(loss)

            state = next_state
            total_reward += reward

            if done:
                break

        scores.append(total_reward)
        if episode_loss:
            losses.append(np.mean(episode_loss))

        # 记录指标
        tracker.log_metric('episode_reward', total_reward, episode)
        tracker.log_metric('epsilon', agent.epsilon, episode)
        if episode_loss:
            tracker.log_metric('loss', np.mean(episode_loss), episode)

        if episode % 100 == 0:
            avg_score = np.mean(scores)
            print(f"Episode {episode}: 平均分数={avg_score:.2f}, ε={agent.epsilon:.3f}")

            # 保存检查点
            tracker.save_checkpoint(f'episode_{episode}', {
                'model_state': agent.q_network.state_dict(),
                'avg_score': avg_score,
                'epsilon': agent.epsilon
            })

    print("步骤4: 测试训练结果")

    # 测试智能体
    agent.epsilon = 0  # 关闭探索
    test_scores = []
    success_count = 0

    for test_episode in range(100):
        state = env.reset()
        total_reward = 0

        for step in range(env.max_steps):
            action = agent.act(state)
            state, reward, done = env.step(action)
            total_reward += reward

            if done:
                if env.agent_pos == env.goal_pos:
                    success_count += 1
                break

        test_scores.append(total_reward)

    success_rate = success_count / 100
    avg_test_score = np.mean(test_scores)

    print(f"测试结果:")
    print(f"  成功率: {success_rate:.2%}")
    print(f"  平均分数: {avg_test_score:.2f}")

    print("步骤5: 可视化学习过程")

    # 绘制学习曲线
    tracker.plot_metrics()

    # 展示一个成功的导航示例
    if success_rate > 0:
        print("展示导航示例...")
        state = env.reset()
        trajectory = [env.agent_pos]

        for step in range(env.max_steps):
            action = agent.act(state)
            state, reward, done = env.step(action)
            trajectory.append(env.agent_pos)

            if done:
                break

        # 可视化轨迹
        grid_display = env.grid.copy()
        for i, pos in enumerate(trajectory):
            grid_display[pos] = 0.5 + 0.3 * (i / len(trajectory))

        grid_display[env.start_pos] = 0.8
        grid_display[env.goal_pos] = 1.0

        plt.figure(figsize=(8, 8))
        plt.imshow(grid_display, cmap='viridis')
        plt.title('DQN导航轨迹示例')
        plt.colorbar(label='轨迹进度')

        # 添加轨迹线
        traj_x = [pos[1] for pos in trajectory]
        traj_y = [pos[0] for pos in trajectory]
        plt.plot(traj_x, traj_y, 'r-', linewidth=2, alpha=0.7)

        plt.savefig('experiment_2_dqn_trajectory.png', dpi=300, bbox_inches='tight')
        plt.show()

    return {
        'success_rate': success_rate,
        'avg_test_score': avg_test_score,
        'training_episodes': num_episodes,
        'final_epsilon': agent.epsilon
    }

def run_experiment_2():
    """运行实验二"""

    print("=" * 60)
    print("实验二：深度强化学习导航")
    print("=" * 60)

    results = experiment_2_dqn_navigation()

    print("\n" + "=" * 60)
    print("实验二总结")
    print("=" * 60)

    print(f"DQN导航训练结果:")
    print(f"  最终成功率: {results['success_rate']:.2%}")
    print(f"  平均测试分数: {results['avg_test_score']:.2f}")
    print(f"  训练回合数: {results['training_episodes']}")
    print(f"  最终探索率: {results['final_epsilon']:.3f}")

    # 判断实验成功
    success = results['success_rate'] > 0.7  # 成功率超过70%

    if success:
        print("\n🎉 实验二成功！DQN智能体学会了导航")
    else:
        print("\n❌实验二需要改进，建议:")
        print("  - 调整网络结构")
        print("  - 增加训练回合")
        print("  - 调整奖励函数")
        print("  - 优化超参数")

    return success

if __name__ == "__main__":
    success = run_experiment_2()
    print(f"\n实验二结果: {'成功' if success else '需要改进'}")
```

## 2. 交互式可视化系统

### 2.1 实时状态监控界面

```python
# interactive_visualization.py
"""
交互式可视化系统
"""

import dash
from dash import dcc, html, Input, Output, State
import plotly.graph_objs as go
import plotly.express as px
import numpy as np
import pandas as pd
import threading
import time
from collections import deque
import json

class RealTimeDataGenerator:
    """实时数据生成器（模拟传感器数据）"""

    def __init__(self):
        self.running = False
        self.data_buffers = {
            'ekf_state': deque(maxlen=1000),
            'sensor_data': deque(maxlen=1000),
            'dqn_metrics': deque(maxlen=1000),
            'system_performance': deque(maxlen=1000)
        }
        self.timestamps = deque(maxlen=1000)
        self.start_time = time.time()

    def start(self):
        """开始数据生成"""
        self.running = True
        self.data_thread = threading.Thread(target=self._generate_data)
        self.data_thread.daemon = True
        self.data_thread.start()

    def stop(self):
        """停止数据生成"""
        self.running = False

    def _generate_data(self):
        """生成模拟数据"""
        t = 0
        while self.running:
            current_time = time.time() - self.start_time

            # 模拟机器人运动轨迹（圆形路径）
            radius = 5
            angular_freq = 0.1

            x = radius * np.cos(angular_freq * current_time)
            y = radius * np.sin(angular_freq * current_time)
            theta = angular_freq * current_time + np.pi/2
            v = radius * angular_freq
            omega = angular_freq

            # EKF状态数据
            ekf_state = {
                'x': x + np.random.normal(0, 0.1),
                'y': y + np.random.normal(0, 0.1),
                'theta': theta + np.random.normal(0, 0.05),
                'v': v + np.random.normal(0, 0.1),
                'omega': omega + np.random.normal(0, 0.05),
                'uncertainty_x': 0.1 + 0.05 * np.sin(0.2 * current_time),
                'uncertainty_y': 0.1 + 0.05 * np.cos(0.2 * current_time)
            }

            # 传感器数据
            sensor_data = {
                'imu_gyro': omega + np.random.normal(0, 0.01),
                'imu_acc': np.random.normal(0, 0.1),
                'odom_x': x + np.random.normal(0, 0.1),
                'odom_y': y + np.random.normal(0, 0.1),
                'gps_x': x + np.random.normal(0, 1.0),
                'gps_y': y + np.random.normal(0, 1.0)
            }

            # DQN指标
            dqn_metrics = {
                'q_value': 10 + 5 * np.sin(0.1 * current_time) + np.random.normal(0, 1),
                'epsilon': max(0.01, 1.0 - current_time * 0.01),
                'loss': max(0, 2 * np.exp(-current_time * 0.1) + np.random.normal(0, 0.1)),
                'reward': 50 + 30 * np.sin(0.05 * current_time) + np.random.normal(0, 5)
            }

            # 系统性能
            system_performance = {
                'cpu_usage': 20 + 10 * np.sin(0.3 * current_time) + np.random.normal(0, 2),
                'memory_usage': 60 + 15 * np.cos(0.2 * current_time) + np.random.normal(0, 3),
                'computation_time': 50 + 20 * np.sin(0.15 * current_time) + np.random.normal(0, 5),
                'success_rate': min(1.0, max(0.0, 0.5 + 0.3 * np.tanh(current_time * 0.1) + np.random.normal(0, 0.05)))
            }

            # 存储数据
            self.timestamps.append(current_time)
            self.data_buffers['ekf_state'].append(ekf_state)
            self.data_buffers['sensor_data'].append(sensor_data)
            self.data_buffers['dqn_metrics'].append(dqn_metrics)
            self.data_buffers['system_performance'].append(system_performance)

            time.sleep(0.1)  # 10Hz更新频率

    def get_latest_data(self):
        """获取最新数据"""
        if not self.timestamps:
            return None

        return {
            'timestamps': list(self.timestamps),
            'ekf_state': list(self.data_buffers['ekf_state']),
            'sensor_data': list(self.data_buffers['sensor_data']),
            'dqn_metrics': list(self.data_buffers['dqn_metrics']),
            'system_performance': list(self.data_buffers['system_performance'])
        }

class VisualizationDashboard:
    """可视化仪表板"""

    def __init__(self):
        self.app = dash.Dash(__name__)
        self.data_generator = RealTimeDataGenerator()
        self.setup_layout()
        self.setup_callbacks()

    def setup_layout(self):
        """设置布局"""
        self.app.layout = html.Div([
            html.H1("强化学习与传感器融合实时监控",
                   style={'textAlign': 'center', 'marginBottom': 30}),

            # 控制面板
            html.Div([
                html.Button("开始监控", id="start-btn", n_clicks=0,
                          style={'marginRight': 10}),
                html.Button("停止监控", id="stop-btn", n_clicks=0),
                html.Div(id="status-display", style={'marginLeft': 20, 'display': 'inline-block'})
            ], style={'textAlign': 'center', 'marginBottom': 20}),

            # 主要图表区域
            html.Div([
                # 左列
                html.Div([
                    dcc.Graph(id="trajectory-plot"),
                    dcc.Graph(id="sensor-data-plot")
                ], style={'width': '50%', 'display': 'inline-block', 'verticalAlign': 'top'}),

                # 右列
                html.Div([
                    dcc.Graph(id="dqn-metrics-plot"),
                    dcc.Graph(id="performance-plot")
                ], style={'width': '50%', 'display': 'inline-block', 'verticalAlign': 'top'})
            ]),

            # 详细信息面板
            html.Div([
                html.H3("系统状态详情"),
                html.Div(id="detailed-info")
            ], style={'marginTop': 30}),

            # 自动刷新组件
            dcc.Interval(
                id='interval-component',
                interval=1000,  # 1秒更新一次
                n_intervals=0
            )
        ])

    def setup_callbacks(self):
        """设置回调函数"""

        @self.app.callback(
            Output('status-display', 'children'),
            [Input('start-btn', 'n_clicks'),
             Input('stop-btn', 'n_clicks')]
        )
        def control_monitoring(start_clicks, stop_clicks):
            """控制监控开始/停止"""
            ctx = dash.callback_context
            if not ctx.triggered:
                return "状态: 未开始"

            button_id = ctx.triggered[0]['prop_id'].split('.')[0]

            if button_id == 'start-btn' and start_clicks > 0:
                self.data_generator.start()
                return "状态: 运行中"
            elif button_id == 'stop-btn' and stop_clicks > 0:
                self.data_generator.stop()
                return "状态: 已停止"

            return "状态: 未开始"

        @self.app.callback(
            [Output('trajectory-plot', 'figure'),
             Output('sensor-data-plot', 'figure'),
             Output('dqn-metrics-plot', 'figure'),
             Output('performance-plot', 'figure'),
             Output('detailed-info', 'children')],
            [Input('interval-component', 'n_intervals')]
        )
        def update_all_plots(n):
            """更新所有图表"""
            data = self.data_generator.get_latest_data()

            if data is None or not data['timestamps']:
                # 返回空图表
                empty_fig = go.Figure()
                return empty_fig, empty_fig, empty_fig, empty_fig, "等待数据..."

            timestamps = data['timestamps']
            ekf_data = data['ekf_state']
            sensor_data = data['sensor_data']
            dqn_data = data['dqn_metrics']
            perf_data = data['system_performance']

            # 1. 轨迹图
            trajectory_fig = self.create_trajectory_plot(ekf_data)

            # 2. 传感器数据图
            sensor_fig = self.create_sensor_plot(timestamps, sensor_data)

            # 3. DQN指标图
            dqn_fig = self.create_dqn_plot(timestamps, dqn_data)

            # 4. 性能图
            performance_fig = self.create_performance_plot(timestamps, perf_data)

            # 5. 详细信息
            detailed_info = self.create_detailed_info(ekf_data, dqn_data, perf_data)

            return trajectory_fig, sensor_fig, dqn_fig, performance_fig, detailed_info

    def create_trajectory_plot(self, ekf_data):
        """创建轨迹图"""
        if not ekf_data:
            return go.Figure()

        x_vals = [d['x'] for d in ekf_data]
        y_vals = [d['y'] for d in ekf_data]
        uncertainties_x = [d['uncertainty_x'] for d in ekf_data]
        uncertainties_y = [d['uncertainty_y'] for d in ekf_data]

        fig = go.Figure()

        # 轨迹线
        fig.add_trace(go.Scatter(
            x=x_vals, y=y_vals,
            mode='lines+markers',
            name='机器人轨迹',
            line=dict(color='blue', width=2),
            marker=dict(size=4)
        ))

        # 不确定性椭圆（只显示最近几个点）
        for i in range(max(0, len(x_vals)-10), len(x_vals), 2):
            fig.add_shape(
                type="circle",
                xref="x", yref="y",
                x0=x_vals[i] - uncertainties_x[i],
                y0=y_vals[i] - uncertainties_y[i],
                x1=x_vals[i] + uncertainties_x[i],
                y1=y_vals[i] + uncertainties_y[i],
                line=dict(color="red", width=1),
                fillcolor="rgba(255,0,0,0.1)"
            )

        fig.update_layout(
            title="机器人轨迹与不确定性",
            xaxis_title="X 位置 (m)",
            yaxis_title="Y 位置 (m)",
            showlegend=True,
            height=400
        )
        fig.update_xaxis(scaleanchor="y", scaleratio=1)

        return fig

    def create_sensor_plot(self, timestamps, sensor_data):
        """创建传感器数据图"""
        if not sensor_data:
            return go.Figure()

        fig = go.Figure()

        # IMU陀螺仪
        imu_gyro = [d['imu_gyro'] for d in sensor_data]
        fig.add_trace(go.Scatter(
            x=timestamps, y=imu_gyro,
            mode='lines',
            name='IMU 陀螺仪',
            line=dict(color='red')
        ))

        # 里程计数据
        odom_x = [d['odom_x'] for d in sensor_data]
        fig.add_trace(go.Scatter(
            x=timestamps, y=odom_x,
            mode='lines',
            name='里程计 X',
            line=dict(color='blue'),
            yaxis='y2'
        ))

        fig.update_layout(
            title="传感器数据实时监控",
            xaxis_title="时间 (s)",
            yaxis=dict(title="角速度 (rad/s)", side="left"),
            yaxis2=dict(title="位置 (m)", side="right", overlaying="y"),
            showlegend=True,
            height=400
        )

        return fig

    def create_dqn_plot(self, timestamps, dqn_data):
        """创建DQN指标图"""
        if not dqn_data:
            return go.Figure()

        fig = go.Figure()

        # Q值
        q_values = [d['q_value'] for d in dqn_data]
        fig.add_trace(go.Scatter(
            x=timestamps, y=q_values,
            mode='lines',
            name='Q值',
            line=dict(color='green')
        ))

        # 探索率
        epsilon_values = [d['epsilon'] for d in dqn_data]
        fig.add_trace(go.Scatter(
            x=timestamps, y=epsilon_values,
            mode='lines',
            name='探索率 (ε)',
            line=dict(color='orange'),
            yaxis='y2'
        ))

        # 损失
        loss_values = [d['loss'] for d in dqn_data]
        fig.add_trace(go.Scatter(
            x=timestamps, y=loss_values,
            mode='lines',
            name='训练损失',
            line=dict(color='purple'),
            yaxis='y3'
        ))

        fig.update_layout(
            title="DQN训练指标",
            xaxis_title="时间 (s)",
            yaxis=dict(title="Q值", side="left"),
            yaxis2=dict(title="探索率", side="right", overlaying="y", position=0.85),
            yaxis3=dict(title="损失", side="right", overlaying="y", position=1.0),
            showlegend=True,
            height=400
        )

        return fig

    def create_performance_plot(self, timestamps, perf_data):
        """创建性能监控图"""
        if not perf_data:
            return go.Figure()

        fig = go.Figure()

        # CPU使用率
        cpu_usage = [d['cpu_usage'] for d in perf_data]
        fig.add_trace(go.Scatter(
            x=timestamps, y=cpu_usage,
            mode='lines',
            name='CPU使用率 (%)',
            line=dict(color='red')
        ))

        # 内存使用率
        memory_usage = [d['memory_usage'] for d in perf_data]
        fig.add_trace(go.Scatter(
            x=timestamps, y=memory_usage,
            mode='lines',
            name='内存使用率 (%)',
            line=dict(color='blue')
        ))

        # 计算时间
        comp_time = [d['computation_time'] for d in perf_data]
        fig.add_trace(go.Scatter(
            x=timestamps, y=comp_time,
            mode='lines',
            name='计算时间 (ms)',
            line=dict(color='green'),
            yaxis='y2'
        ))

        fig.update_layout(
            title="系统性能监控",
            xaxis_title="时间 (s)",
            yaxis=dict(title="使用率 (%)", side="left"),
            yaxis2=dict(title="计算时间 (ms)", side="right", overlaying="y"),
            showlegend=True,
            height=400
        )

        return fig

    def create_detailed_info(self, ekf_data, dqn_data, perf_data):
        """创建详细信息面板"""
        if not ekf_data or not dqn_data or not perf_data:
            return "等待数据..."

        latest_ekf = ekf_data[-1]
        latest_dqn = dqn_data[-1]
        latest_perf = perf_data[-1]

        info_cards = html.Div([
            # EKF状态卡片
            html.Div([
                html.H4("EKF状态估计"),
                html.P(f"位置: ({latest_ekf['x']:.2f}, {latest_ekf['y']:.2f})"),
                html.P(f"朝向: {latest_ekf['theta']:.2f} rad"),
                html.P(f"速度: {latest_ekf['v']:.2f} m/s"),
                html.P(f"不确定性: ±{latest_ekf['uncertainty_x']:.3f} m")
            ], className="info-card", style={
                'width': '30%', 'display': 'inline-block', 'margin': '10px',
                'padding': '15px', 'border': '1px solid #ddd', 'borderRadius': '5px'
            }),

            # DQN状态卡片
            html.Div([
                html.H4("DQN学习状态"),
                html.P(f"当前Q值: {latest_dqn['q_value']:.2f}"),
                html.P(f"探索率: {latest_dqn['epsilon']:.3f}"),
                html.P(f"训练损失: {latest_dqn['loss']:.3f}"),
                html.P(f"奖励: {latest_dqn['reward']:.1f}")
            ], className="info-card", style={
                'width': '30%', 'display': 'inline-block', 'margin': '10px',
                'padding': '15px', 'border': '1px solid #ddd', 'borderRadius': '5px'
            }),

            # 系统性能卡片
            html.Div([
                html.H4("系统性能"),
                html.P(f"CPU: {latest_perf['cpu_usage']:.1f}%"),
                html.P(f"内存: {latest_perf['memory_usage']:.1f}%"),
                html.P(f"计算时间: {latest_perf['computation_time']:.1f}ms"),
                html.P(f"成功率: {latest_perf['success_rate']:.1%}")
            ], className="info-card", style={
                'width': '30%', 'display': 'inline-block', 'margin': '10px',
                'padding': '15px', 'border': '1px solid #ddd', 'borderRadius': '5px'
            })
        ])

        return info_cards

    def run(self, debug=False, port=8050):
        """运行仪表板"""
        print(f"启动可视化仪表板: http://localhost:{port}")
        self.app.run_server(debug=debug, port=port)

def create_parameter_tuning_interface():
    """创建参数调优界面"""

    app = dash.Dash(__name__)

    app.layout = html.Div([
        html.H1("算法参数调优界面", style={'textAlign': 'center'}),

        html.Div([
            # DQN参数
            html.Div([
                html.H3("DQN参数"),
                html.Label("学习率:"),
                dcc.Slider(id='lr-slider', min=0.0001, max=0.01, step=0.0001,
                          value=0.001, marks={i/1000: str(i/1000) for i in range(1, 11)}),

                html.Label("探索率衰减:"),
                dcc.Slider(id='epsilon-decay-slider', min=0.99, max=0.999, step=0.001,
                          value=0.995, marks={0.99+i*0.002: f"{0.99+i*0.002:.3f}" for i in range(5)}),

                html.Label("批次大小:"),
                dcc.Dropdown(id='batch-size-dropdown',
                           options=[{'label': str(i), 'value': i} for i in [16, 32, 64, 128]],
                           value=32),

                html.Label("目标网络更新频率:"),
                dcc.Input(id='target-update-input', type='number', value=100, min=10, max=1000)
            ], style={'width': '45%', 'display': 'inline-block', 'padding': '20px'}),

            # EKF参数
            html.Div([
                html.H3("EKF参数"),
                html.Label("过程噪声:"),
                dcc.Slider(id='process-noise-slider', min=0.001, max=0.1, step=0.001,
                          value=0.01, marks={i/100: str(i/100) for i in range(1, 11)}),

                html.Label("观测噪声:"),
                dcc.Slider(id='obs-noise-slider', min=0.1, max=5.0, step=0.1,
                          value=1.0, marks={i: str(i) for i in range(1, 6)}),

                html.Label("初始不确定性:"),
                dcc.Slider(id='init-uncertainty-slider', min=0.01, max=1.0, step=0.01,
                          value=0.1, marks={i/10: str(i/10) for i in range(1, 11)}),

                html.Label("自适应因子:"),
                dcc.Input(id='adaptive-factor-input', type='number', value=1.5,
                         min=1.0, max=3.0, step=0.1)
            ], style={'width': '45%', 'display': 'inline-block', 'padding': '20px'})
        ]),

        html.Div([
            html.Button("应用参数", id="apply-params-btn", n_clicks=0,
                       style={'marginRight': '10px'}),
            html.Button("重置为默认", id="reset-params-btn", n_clicks=0),
            html.Div(id="param-status")
        ], style={'textAlign': 'center', 'margin': '20px'}),

        html.Div([
            dcc.Graph(id="param-effect-plot")
        ])
    ])

    @app.callback(
        [Output('param-status', 'children'),
         Output('param-effect-plot', 'figure')],
        [Input('apply-params-btn', 'n_clicks'),
         Input('reset-params-btn', 'n_clicks')],
        [State('lr-slider', 'value'),
         State('epsilon-decay-slider', 'value'),
         State('batch-size-dropdown', 'value'),
         State('target-update-input', 'value'),
         State('process-noise-slider', 'value'),
         State('obs-noise-slider', 'value'),
         State('init-uncertainty-slider', 'value'),
         State('adaptive-factor-input', 'value')]
    )
    def update_parameters(apply_clicks, reset_clicks, lr, epsilon_decay, batch_size,
                         target_update, process_noise, obs_noise, init_uncertainty, adaptive_factor):
        ctx = dash.callback_context

        if not ctx.triggered:
            return "等待参数调整...", go.Figure()

        button_id = ctx.triggered[0]['prop_id'].split('.')[0]

        if button_id == 'apply-params-btn':
            # 这里会应用新参数到实际算法
            status = f"参数已应用: LR={lr}, ε衰减={epsilon_decay}, 批次={batch_size}"

            # 模拟参数效果图
            x = np.linspace(0, 100, 100)
            y1 = np.exp(-x * lr) * 100  # 学习曲线
            y2 = epsilon_decay ** x     # 探索率衰减

            fig = go.Figure()
            fig.add_trace(go.Scatter(x=x, y=y1, name='学习进度', line=dict(color='blue')))
            fig.add_trace(go.Scatter(x=x, y=y2, name='探索率', line=dict(color='red'), yaxis='y2'))

            fig.update_layout(
                title="参数效果预测",
                xaxis_title="训练步骤",
                yaxis=dict(title="学习进度", side="left"),
                yaxis2=dict(title="探索率", side="right", overlaying="y")
            )

            return status, fig

        return "参数已重置为默认值", go.Figure()

    return app

def run_visualization_system():
    """运行完整的可视化系统"""

    print("=== 启动交互式可视化系统 ===")

    # 创建主监控仪表板
    dashboard = VisualizationDashboard()

    # 在后台启动参数调优界面
    param_app = create_parameter_tuning_interface()

    print("可用界面:")
    print("1. 实时监控仪表板: http://localhost:8050")
    print("2. 参数调优界面: http://localhost:8051")

    # 启动参数调优界面（后台）
    import threading
    param_thread = threading.Thread(
        target=lambda: param_app.run_server(debug=False, port=8051)
    )
    param_thread.daemon = True
    param_thread.start()

    # 启动主仪表板
    dashboard.run(debug=False, port=8050)

if __name__ == "__main__":
    run_visualization_system()
```

## 3. 性能分析工具

### 3.1 详细性能报告生成器

```python
# performance_analysis_tools.py
"""
性能分析工具集
"""

import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
import pandas as pd
import time
import psutil
import threading
from collections import defaultdict
import json
from datetime import datetime
import warnings
warnings.filterwarnings('ignore')

class DetailedPerformanceAnalyzer:
    """详细性能分析器"""

    def __init__(self):
        self.performance_data = {
            'navigation': defaultdict(list),
            'ekf': defaultdict(list),
            'dqn': defaultdict(list),
            'system': defaultdict(list),
            'timestamps': []
        }

        self.analysis_results = {}

    def record_navigation_performance(self, episode_data):
        """记录导航性能数据"""

        # 基本指标
        self.performance_data['navigation']['success_rate'].append(
            1 if episode_data.get('success', False) else 0
        )
        self.performance_data['navigation']['episode_length'].append(
            episode_data.get('steps', 0)
        )
        self.performance_data['navigation']['total_reward'].append(
            episode_data.get('total_reward', 0)
        )

        # 轨迹分析
        if 'trajectory' in episode_data:
            trajectory = np.array(episode_data['trajectory'])
            if len(trajectory) > 1:
                # 路径长度
                path_length = np.sum(np.linalg.norm(np.diff(trajectory[:, :2], axis=0), axis=1))
                self.performance_data['navigation']['path_length'].append(path_length)

                # 路径平滑度
                if len(trajectory) > 2:
                    angles = []
                    for i in range(len(trajectory) - 2):
                        v1 = trajectory[i+1, :2] - trajectory[i, :2]
                        v2 = trajectory[i+2, :2] - trajectory[i+1, :2]
                        if np.linalg.norm(v1) > 0 and np.linalg.norm(v2) > 0:
                            angle = np.arccos(np.clip(np.dot(v1, v2) /
                                                    (np.linalg.norm(v1) * np.linalg.norm(v2)), -1, 1))
                            angles.append(angle)

                    path_smoothness = np.mean(angles) if angles else 0
                    self.performance_data['navigation']['path_smoothness'].append(path_smoothness)

        # 效率指标
        if 'goal_distance_initial' in episode_data and 'goal_distance_final' in episode_data:
            efficiency = (episode_data['goal_distance_initial'] - episode_data['goal_distance_final']) / \
                        episode_data['goal_distance_initial']
            self.performance_data['navigation']['efficiency'].append(efficiency)

    def record_ekf_performance(self, ekf_data):
        """记录EKF性能数据"""

        if 'position_error' in ekf_data:
            self.performance_data['ekf']['position_error'].append(ekf_data['position_error'])

        if 'angle_error' in ekf_data:
            self.performance_data['ekf']['angle_error'].append(ekf_data['angle_error'])

        if 'innovation' in ekf_data:
            self.performance_data['ekf']['innovation_norm'].append(
                np.linalg.norm(ekf_data['innovation'])
            )

        if 'uncertainty' in ekf_data:
            self.performance_data['ekf']['uncertainty'].append(ekf_data['uncertainty'])

        if 'computation_time' in ekf_data:
            self.performance_data['ekf']['computation_time'].append(ekf_data['computation_time'])

    def record_dqn_performance(self, dqn_data):
        """记录DQN性能数据"""

        if 'q_value' in dqn_data:
            self.performance_data['dqn']['q_value'].append(dqn_data['q_value'])

        if 'loss' in dqn_data:
            self.performance_data['dqn']['loss'].append(dqn_data['loss'])

        if 'epsilon' in dqn_data:
            self.performance_data['dqn']['epsilon'].append(dqn_data['epsilon'])

        if 'action_distribution' in dqn_data:
            # 记录动作分布熵（探索多样性）
            action_probs = np.array(dqn_data['action_distribution'])
            action_probs = action_probs / np.sum(action_probs)  # 归一化
            entropy = -np.sum(action_probs * np.log(action_probs + 1e-8))
            self.performance_data['dqn']['action_entropy'].append(entropy)

    def record_system_performance(self):
        """记录系统性能数据"""

        # CPU和内存使用率
        cpu_percent = psutil.cpu_percent()
        memory_info = psutil.virtual_memory()

        self.performance_data['system']['cpu_usage'].append(cpu_percent)
        self.performance_data['system']['memory_usage'].append(memory_info.percent)
        self.performance_data['system']['memory_available'].append(memory_info.available / 1024**3)  # GB

        # GPU使用率（如果可用）
        try:
            import GPUtil
            gpus = GPUtil.getGPUs()
            if gpus:
                gpu = gpus[0]
                self.performance_data['system']['gpu_usage'].append(gpu.load * 100)
                self.performance_data['system']['gpu_memory_usage'].append(gpu.memoryUtil * 100)
        except ImportError:
            pass

        # 时间戳
        self.performance_data['timestamps'].append(time.time())

    def generate_comprehensive_report(self):
        """生成综合性能报告"""

        report = {
            'generation_time': datetime.now().isoformat(),
            'analysis_summary': {},
            'detailed_metrics': {},
            'recommendations': []
        }

        # 导航性能分析
        nav_analysis = self.analyze_navigation_performance()
        report['analysis_summary']['navigation'] = nav_analysis

        # EKF性能分析
        ekf_analysis = self.analyze_ekf_performance()
        report['analysis_summary']['ekf'] = ekf_analysis

        # DQN性能分析
        dqn_analysis = self.analyze_dqn_performance()
        report['analysis_summary']['dqn'] = dqn_analysis

        # 系统性能分析
        system_analysis = self.analyze_system_performance()
        report['analysis_summary']['system'] = system_analysis

        # 生成建议
        report['recommendations'] = self.generate_recommendations()

        # 详细指标
        report['detailed_metrics'] = self.performance_data

        return report

    def analyze_navigation_performance(self):
        """分析导航性能"""

        nav_data = self.performance_data['navigation']
        analysis = {}

        if nav_data['success_rate']:
            success_rates = nav_data['success_rate']
            analysis['overall_success_rate'] = np.mean(success_rates)
            analysis['success_rate_trend'] = self.calculate_trend(success_rates)
            analysis['recent_success_rate'] = np.mean(success_rates[-50:]) if len(success_rates) >= 50 else np.mean(success_rates)

        if nav_data['episode_length']:
            episode_lengths = nav_data['episode_length']
            analysis['avg_episode_length'] = np.mean(episode_lengths)
            analysis['episode_length_std'] = np.std(episode_lengths)
            analysis['episode_length_trend'] = self.calculate_trend(episode_lengths)

        if nav_data['total_reward']:
            rewards = nav_data['total_reward']
            analysis['avg_reward'] = np.mean(rewards)
            analysis['reward_std'] = np.std(rewards)
            analysis['reward_trend'] = self.calculate_trend(rewards)

        if nav_data['path_length']:
            path_lengths = nav_data['path_length']
            analysis['avg_path_length'] = np.mean(path_lengths)
            analysis['path_efficiency'] = self.calculate_path_efficiency(path_lengths)

        if nav_data['path_smoothness']:
            smoothness = nav_data['path_smoothness']
            analysis['avg_path_smoothness'] = np.mean(smoothness)

        return analysis

    def analyze_ekf_performance(self):
        """分析EKF性能"""

        ekf_data = self.performance_data['ekf']
        analysis = {}

        if ekf_data['position_error']:
            pos_errors = ekf_data['position_error']
            analysis['mean_position_error'] = np.mean(pos_errors)
            analysis['position_error_std'] = np.std(pos_errors)
            analysis['position_rmse'] = np.sqrt(np.mean(np.array(pos_errors)**2))
            analysis['position_error_trend'] = self.calculate_trend(pos_errors)

        if ekf_data['innovation_norm']:
            innovations = ekf_data['innovation_norm']
            analysis['mean_innovation'] = np.mean(innovations)
            analysis['innovation_consistency'] = self.check_innovation_consistency(innovations)

        if ekf_data['uncertainty']:
            uncertainties = ekf_data['uncertainty']
            analysis['mean_uncertainty'] = np.mean(uncertainties)
            analysis['uncertainty_trend'] = self.calculate_trend(uncertainties)

        if ekf_data['computation_time']:
            comp_times = ekf_data['computation_time']
            analysis['mean_computation_time'] = np.mean(comp_times)
            analysis['max_computation_time'] = np.max(comp_times)
            analysis['computation_time_std'] = np.std(comp_times)

        return analysis

    def analyze_dqn_performance(self):
        """分析DQN性能"""

        dqn_data = self.performance_data['dqn']
        analysis = {}

        if dqn_data['q_value']:
            q_values = dqn_data['q_value']
            analysis['mean_q_value'] = np.mean(q_values)
            analysis['q_value_trend'] = self.calculate_trend(q_values)
            analysis['q_value_stability'] = np.std(q_values[-100:]) if len(q_values) >= 100 else np.std(q_values)

        if dqn_data['loss']:
            losses = dqn_data['loss']
            analysis['mean_loss'] = np.mean(losses)
            analysis['loss_trend'] = self.calculate_trend(losses)
            analysis['loss_convergence'] = self.check_convergence(losses)

        if dqn_data['epsilon']:
            epsilons = dqn_data['epsilon']
            analysis['current_epsilon'] = epsilons[-1] if epsilons else 0
            analysis['exploration_schedule'] = self.analyze_exploration_schedule(epsilons)

        if dqn_data['action_entropy']:
            entropies = dqn_data['action_entropy']
            analysis['mean_action_entropy'] = np.mean(entropies)
            analysis['exploration_diversity'] = self.classify_exploration_diversity(np.mean(entropies))

        return analysis

    def analyze_system_performance(self):
        """分析系统性能"""

        sys_data = self.performance_data['system']
        analysis = {}

        if sys_data['cpu_usage']:
            cpu_usage = sys_data['cpu_usage']
            analysis['mean_cpu_usage'] = np.mean(cpu_usage)
            analysis['max_cpu_usage'] = np.max(cpu_usage)
            analysis['cpu_usage_std'] = np.std(cpu_usage)

        if sys_data['memory_usage']:
            memory_usage = sys_data['memory_usage']
            analysis['mean_memory_usage'] = np.mean(memory_usage)
            analysis['max_memory_usage'] = np.max(memory_usage)

        if sys_data['gpu_usage']:
            gpu_usage = sys_data['gpu_usage']
            analysis['mean_gpu_usage'] = np.mean(gpu_usage)
            analysis['max_gpu_usage'] = np.max(gpu_usage)

        return analysis

    def calculate_trend(self, data):
        """计算数据趋势"""
        if len(data) < 2:
            return 0

        x = np.arange(len(data))
        y = np.array(data)

        # 线性回归
        slope = np.polyfit(x, y, 1)[0]
        return slope

    def calculate_path_efficiency(self, path_lengths):
        """计算路径效率"""
        if not path_lengths:
            return 0

        # 假设最优路径长度（直线距离）
        optimal_length = 10.0  # 根据环境设置
        avg_path_length = np.mean(path_lengths)

        efficiency = optimal_length / avg_path_length if avg_path_length > 0 else 0
        return min(efficiency, 1.0)

    def check_innovation_consistency(self, innovations):
        """检查创新序列一致性"""
        if len(innovations) < 10:
            return "数据不足"

        # 简化的一致性检查
        mean_innovation = np.mean(innovations)
        std_innovation = np.std(innovations)

        # 理论上创新序列应该接近零均值
        if abs(mean_innovation) < 0.1 and std_innovation < 2.0:
            return "一致"
        else:
            return "不一致"

    def check_convergence(self, losses):
        """检查损失收敛性"""
        if len(losses) < 50:
            return "数据不足"

        # 检查最近50个损失值的趋势
        recent_losses = losses[-50:]
        trend = self.calculate_trend(recent_losses)

        if trend < -0.001:
            return "收敛中"
        elif abs(trend) < 0.001:
            return "已收敛"
        else:
            return "发散"

    def analyze_exploration_schedule(self, epsilons):
        """分析探索计划"""
        if not epsilons:
            return "无数据"

        start_epsilon = epsilons[0]
        end_epsilon = epsilons[-1]

        if start_epsilon > 0.9 and end_epsilon < 0.1:
            return "标准衰减"
        elif end_epsilon > 0.3:
            return "过度探索"
        else:
            return "探索不足"

    def classify_exploration_diversity(self, mean_entropy):
        """分类探索多样性"""
        max_entropy = np.log(4)  # 4个动作的最大熵

        if mean_entropy > 0.8 * max_entropy:
            return "高多样性"
        elif mean_entropy > 0.5 * max_entropy:
            return "中等多样性"
        else:
            return "低多样性"

    def generate_recommendations(self):
        """生成优化建议"""

        recommendations = []

        # 导航性能建议
        nav_analysis = self.analysis_results.get('navigation', {})
        if nav_analysis.get('overall_success_rate', 0) < 0.8:
            recommendations.append({
                'category': '导航性能',
                'issue': '成功率偏低',
                'suggestion': '建议调整奖励函数，增加中间奖励引导'
            })

        if nav_analysis.get('avg_episode_length', 0) > 200:
            recommendations.append({
                'category': '导航效率',
                'issue': '回合长度过长',
                'suggestion': '考虑增加探索策略或调整网络结构'
            })

        # EKF性能建议
        ekf_analysis = self.analysis_results.get('ekf', {})
        if ekf_analysis.get('mean_position_error', float('inf')) > 1.0:
            recommendations.append({
                'category': 'EKF性能',
                'issue': '定位误差较大',
                'suggestion': '检查传感器校准和噪声模型参数'
            })

        if ekf_analysis.get('innovation_consistency') == '不一致':
            recommendations.append({
                'category': 'EKF调优',
                'issue': '创新序列不一致',
                'suggestion': '需要重新调整过程噪声和观测噪声协方差'
            })

        # DQN性能建议
        dqn_analysis = self.analysis_results.get('dqn', {})
        if dqn_analysis.get('loss_convergence') == '发散':
            recommendations.append({
                'category': 'DQN训练',
                'issue': '损失发散',
                'suggestion': '降低学习率或调整网络结构'
            })

        if dqn_analysis.get('exploration_diversity') == '低多样性':
            recommendations.append({
                'category': 'DQN探索',
                'issue': '探索不充分',
                'suggestion': '增加探索率或使用更复杂的探索策略'
            })

        # 系统性能建议
        sys_analysis = self.analysis_results.get('system', {})
        if sys_analysis.get('mean_cpu_usage', 0) > 80:
            recommendations.append({
                'category': '系统优化',
                'issue': 'CPU使用率过高',
                'suggestion': '考虑并行化处理或算法优化'
            })

        return recommendations

    def create_performance_dashboard(self):
        """创建性能分析仪表板"""

        # 设置绘图风格
        plt.style.use('seaborn-v0_8')
        sns.set_palette("husl")

        fig, axes = plt.subplots(3, 4, figsize=(20, 15))
        fig.suptitle('综合性能分析报告', fontsize=16, fontweight='bold')

        # 导航性能图表
        self.plot_navigation_metrics(axes[0, :])

        # EKF性能图表
        self.plot_ekf_metrics(axes[1, :])

        # DQN和系统性能图表
        self.plot_dqn_metrics(axes[2, :2])
        self.plot_system_metrics(axes[2, 2:])

        plt.tight_layout()
        plt.savefig('comprehensive_performance_report.png', dpi=300, bbox_inches='tight')
        plt.show()

        return fig

    def plot_navigation_metrics(self, axes):
        """绘制导航指标"""

        nav_data = self.performance_data['navigation']

        # 成功率趋势
        if nav_data['success_rate']:
            success_rates = nav_data['success_rate']
            window_size = min(20, len(success_rates))
            if len(success_rates) >= window_size:
                smoothed = pd.Series(success_rates).rolling(window=window_size).mean()
                axes[0].plot(smoothed.index, smoothed.values, linewidth=2)
            axes[0].set_title('成功率趋势')
            axes[0].set_ylabel('成功率')
            axes[0].grid(True, alpha=0.3)

        # 奖励分布
        if nav_data['total_reward']:
            axes[1].hist(nav_data['total_reward'], bins=30, alpha=0.7, edgecolor='black')
            axes[1].set_title('奖励分布')
            axes[1].set_xlabel('总奖励')
            axes[1].set_ylabel('频次')
            axes[1].grid(True, alpha=0.3)

        # 回合长度趋势
        if nav_data['episode_length']:
            episode_lengths = nav_data['episode_length']
            axes[2].plot(episode_lengths, alpha=0.7)
            if len(episode_lengths) >= 20:
                smoothed = pd.Series(episode_lengths).rolling(window=20).mean()
                axes[2].plot(smoothed.index, smoothed.values, 'r-', linewidth=2, label='平均值')
                axes[2].legend()
            axes[2].set_title('回合长度趋势')
            axes[2].set_ylabel('步数')
            axes[2].grid(True, alpha=0.3)

        # 路径效率箱线图
        if nav_data['path_length']:
            path_lengths = nav_data['path_length']
            axes[3].boxplot(path_lengths)
            axes[3].set_title('路径长度分布')
            axes[3].set_ylabel('路径长度')
            axes[3].grid(True, alpha=0.3)

    def plot_ekf_metrics(self, axes):
        """绘制EKF指标"""

        ekf_data = self.performance_data['ekf']

        # 位置误差趋势
        if ekf_data['position_error']:
            pos_errors = ekf_data['position_error']
            axes[0].plot(pos_errors, alpha=0.7)
            axes[0].axhline(np.mean(pos_errors), color='red', linestyle='--',
                           label=f'平均值: {np.mean(pos_errors):.3f}')
            axes[0].set_title('位置误差趋势')
            axes[0].set_ylabel('位置误差 (m)')
            axes[0].legend()
            axes[0].grid(True, alpha=0.3)

        # 创新序列
        if ekf_data['innovation_norm']:
            innovations = ekf_data['innovation_norm']
            axes[1].plot(innovations, alpha=0.7)
            axes[1].set_title('创新序列')
            axes[1].set_ylabel('创新范数')
            axes[1].grid(True, alpha=0.3)

        # 不确定性演化
        if ekf_data['uncertainty']:
            uncertainties = ekf_data['uncertainty']
            axes[2].plot(uncertainties, linewidth=2)
            axes[2].set_title('估计不确定性')
            axes[2].set_ylabel('不确定性')
            axes[2].grid(True, alpha=0.3)

        # 计算时间分布
        if ekf_data['computation_time']:
            comp_times = np.array(ekf_data['computation_time']) * 1000  # 转换为ms
            axes[3].hist(comp_times, bins=20, alpha=0.7, edgecolor='black')
            axes[3].axvline(np.mean(comp_times), color='red', linestyle='--',
                           label=f'平均: {np.mean(comp_times):.1f}ms')
            axes[3].set_title('EKF计算时间分布')
            axes[3].set_xlabel('计算时间 (ms)')
            axes[3].set_ylabel('频次')
            axes[3].legend()
            axes[3].grid(True, alpha=0.3)

    def plot_dqn_metrics(self, axes):
        """绘制DQN指标"""

        dqn_data = self.performance_data['dqn']

        # Q值和损失
        if dqn_data['q_value'] and dqn_data['loss']:
            ax1 = axes[0]
            ax2 = ax1.twinx()

            ax1.plot(dqn_data['q_value'], 'b-', label='Q值')
            ax2.plot(dqn_data['loss'], 'r-', alpha=0.7, label='损失')

            ax1.set_xlabel('训练步骤')
            ax1.set_ylabel('Q值', color='b')
            ax2.set_ylabel('损失', color='r')
            ax1.set_title('Q值与损失趋势')

            # 添加图例
            lines1, labels1 = ax1.get_legend_handles_labels()
            lines2, labels2 = ax2.get_legend_handles_labels()
            ax1.legend(lines1 + lines2, labels1 + labels2, loc='upper right')

            ax1.grid(True, alpha=0.3)

        # 探索率衰减
        if dqn_data['epsilon']:
            axes[1].plot(dqn_data['epsilon'], linewidth=2)
            axes[1].set_title('探索率衰减')
            axes[1].set_ylabel('ε值')
            axes[1].set_xlabel('训练步骤')
            axes[1].grid(True, alpha=0.3)

    def plot_system_metrics(self, axes):
        """绘制系统指标"""

        sys_data = self.performance_data['system']

        # CPU和内存使用率
        if sys_data['cpu_usage'] and sys_data['memory_usage']:
            timestamps = range(len(sys_data['cpu_usage']))

            axes[0].plot(timestamps, sys_data['cpu_usage'], 'b-', label='CPU使用率')
            axes[0].plot(timestamps, sys_data['memory_usage'], 'r-', label='内存使用率')
            axes[0].set_title('系统资源使用率')
            axes[0].set_ylabel('使用率 (%)')
            axes[0].set_xlabel('时间')
            axes[0].legend()
            axes[0].grid(True, alpha=0.3)

        # 资源使用统计
        if sys_data['cpu_usage']:
            resource_stats = {
                'CPU平均': np.mean(sys_data['cpu_usage']),
                'CPU最大': np.max(sys_data['cpu_usage']),
                '内存平均': np.mean(sys_data['memory_usage']) if sys_data['memory_usage'] else 0,
                '内存最大': np.max(sys_data['memory_usage']) if sys_data['memory_usage'] else 0
            }

            bars = axes[1].bar(resource_stats.keys(), resource_stats.values(),
                              color=['skyblue', 'lightcoral', 'lightgreen', 'orange'])
            axes[1].set_title('资源使用统计')
            axes[1].set_ylabel('使用率 (%)')

            # 添加数值标签
            for bar, value in zip(bars, resource_stats.values()):
                axes[1].text(bar.get_x() + bar.get_width()/2, bar.get_height() + 1,
                           f'{value:.1f}%', ha='center', va='bottom')

            axes[1].grid(True, alpha=0.3)

    def save_report(self, filename='performance_analysis_report.json'):
        """保存分析报告"""

        report = self.generate_comprehensive_report()

        with open(filename, 'w', encoding='utf-8') as f:
            json.dump(report, f, indent=2, ensure_ascii=False, default=str)

        print(f"性能分析报告已保存到: {filename}")
        return filename

def run_performance_analysis_demo():
    """运行性能分析演示"""

    print("=== 性能分析工具演示 ===")

    # 创建性能分析器
    analyzer = DetailedPerformanceAnalyzer()

    # 模拟记录数据
    print("生成模拟性能数据...")

    for episode in range(200):
        # 模拟导航数据
        nav_data = {
            'success': np.random.random() > (0.5 - episode * 0.002),  # 逐渐提高成功率
            'steps': max(50, 200 - episode + np.random.randint(-20, 20)),
            'total_reward': 50 + episode * 0.3 + np.random.normal(0, 10),
            'trajectory': np.random.randn(100, 3),  # 模拟轨迹
            'goal_distance_initial': 10.0,
            'goal_distance_final': max(0.1, 5.0 - episode * 0.02 + np.random.normal(0, 1))
        }
        analyzer.record_navigation_performance(nav_data)

        # 模拟EKF数据
        ekf_data = {
            'position_error': max(0.1, 2.0 - episode * 0.005 + np.random.normal(0, 0.1)),
            'angle_error': np.random.normal(0, 0.1),
            'innovation': np.random.normal(0, 0.5, 3),
            'uncertainty': 0.2 + 0.1 * np.sin(episode * 0.1),
            'computation_time': 0.01 + np.random.normal(0, 0.002)
        }
        analyzer.record_ekf_performance(ekf_data)

        # 模拟DQN数据
        dqn_data = {
            'q_value': 10 + episode * 0.1 + np.random.normal(0, 2),
            'loss': max(0.1, 5.0 * np.exp(-episode * 0.01) + np.random.normal(0, 0.5)),
            'epsilon': max(0.01, 1.0 - episode * 0.005),
            'action_distribution': np.random.dirichlet([1, 1, 1, 1])
        }
        analyzer.record_dqn_performance(dqn_data)

        # 记录系统性能（每10个episode一次）
        if episode % 10 == 0:
            analyzer.record_system_performance()

    print("数据生成完成，开始分析...")

    # 生成综合报告
    report = analyzer.generate_comprehensive_report()

    # 打印关键指标
    print("\n=== 关键性能指标 ===")
    nav_summary = report['analysis_summary']['navigation']
    print(f"导航成功率: {nav_summary.get('overall_success_rate', 0):.2%}")
    print(f"最近成功率: {nav_summary.get('recent_success_rate', 0):.2%}")
    print(f"平均回合长度: {nav_summary.get('avg_episode_length', 0):.1f}")

    ekf_summary = report['analysis_summary']['ekf']
    print(f"平均定位误差: {ekf_summary.get('mean_position_error', 0):.3f}m")
    print(f"EKF计算时间: {ekf_summary.get('mean_computation_time', 0)*1000:.1f}ms")

    dqn_summary = report['analysis_summary']['dqn']
    print(f"损失收敛状态: {dqn_summary.get('loss_convergence', '未知')}")
    print(f"探索多样性: {dqn_summary.get('exploration_diversity', '未知')}")

    # 显示优化建议
    print("\n=== 优化建议 ===")
    for i, rec in enumerate(report['recommendations'], 1):
        print(f"{i}. [{rec['category']}] {rec['issue']}")
        print(f"   建议: {rec['suggestion']}")

    # 创建可视化仪表板
    print("\n生成可视化报告...")
    analyzer.create_performance_dashboard()

    # 保存报告
    report_file = analyzer.save_report()

    print(f"\n=== 分析完成 ===")
    print(f"可视化图表已显示")
    print(f"详细报告已保存: {report_file}")

    return analyzer, report

if __name__ == "__main__":
    analyzer, report = run_performance_analysis_demo()
    print("性能分析演示完成！")
```

## 学习检查点

### 实验完成验证

1. **实验环境**：
   - 所有依赖包正确安装
   - 验证脚本通过测试
   - GPU/CPU环境配置正确

2. **基础算法验证**：
   - Q-Learning成功率 > 80%
   - 卡尔曼滤波RMSE < 1.0
   - 创新序列一致性检验通过

3. **深度学习导航**：
   - DQN训练收敛
   - 导航成功率 > 70%
   - 可视化轨迹合理

4. **可视化系统**：
   - 实时监控界面运行
   - 参数调优界面可用
   - 性能分析报告生成

### 工具使用能力

完成本部分后，学生应能够：
- 独立搭建实验环境
- 运行和调试实验代码
- 使用可视化工具分析结果
- 生成专业的性能报告
- 基于分析结果优化算法

**实践建议**：
1. 逐步完成所有实验，确保每个环节都理解
2. 尝试修改参数观察对结果的影响
3. 使用可视化工具深入分析算法行为
4. 记录实验过程和发现的问题