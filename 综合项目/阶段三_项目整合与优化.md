# 阶段三：项目整合与优化

## 1. 强化学习与传感器融合系统集成

### 1.1 系统架构设计

#### 整体架构图

```
┌─────────────────────────────────────────────────────────────────┐
│                    自主导航系统架构                              │
├─────────────────────────────────────────────────────────────────┤
│  传感器层                                                       │
│  ┌─────────┐  ┌─────────┐  ┌─────────┐  ┌─────────┐           │
│  │   IMU   │  │ 里程计  │  │   GPS   │  │ 激光雷达 │           │
│  └─────────┘  └─────────┘  └─────────┘  └─────────┘           │
├─────────────────────────────────────────────────────────────────┤
│  融合层                                                         │
│  ┌─────────────────────────────────────────────────────────────┐ │
│  │            多传感器EKF状态估计                             │ │
│  │  • 位姿估计 (x, y, θ)                                    │ │
│  │  • 速度估计 (v, ω)                                       │ │
│  │  • 不确定性量化                                          │ │
│  └─────────────────────────────────────────────────────────────┘ │
├─────────────────────────────────────────────────────────────────┤
│  决策层                                                         │
│  ┌─────────────────────────────────────────────────────────────┐ │
│  │            DQN强化学习控制器                               │ │
│  │  • 状态感知                                              │ │
│  │  • 动作选择                                              │ │
│  │  • 路径规划                                              │ │
│  └─────────────────────────────────────────────────────────────┘ │
├─────────────────────────────────────────────────────────────────┤
│  执行层                                                         │
│  ┌─────────────────────────────────────────────────────────────┐ │
│  │            机器人运动控制                                  │ │
│  │  • 速度控制                                              │ │
│  │  • 安全监控                                              │ │
│  │  • 执行器驱动                                            │ │
│  └─────────────────────────────────────────────────────────────┘ │
└─────────────────────────────────────────────────────────────────┘
```

#### 系统集成理论

**状态空间统一**：
强化学习状态向量包含EKF估计的状态和不确定性信息：
$$s_{RL} = [x_{EKF}, P_{diag}, d_{goal}, d_{obstacles}, \text{goal\_angle}]$$

其中：
- $x_{EKF}$：EKF估计的机器人状态
- $P_{diag}$：协方差矩阵对角元素（不确定性）
- $d_{goal}$：到目标距离
- $d_{obstacles}$：障碍物距离（激光雷达）
- $\text{goal\_angle}$：目标方向角

**融合策略**：
1. **松耦合**：EKF提供状态估计，RL基于估计状态进行决策
2. **紧耦合**：RL考虑估计不确定性进行风险感知决策
3. **自适应权重**：根据传感器可靠性动态调整融合权重

### 1.2 集成系统实现

```python
import numpy as np
import torch
import rospy
from threading import Lock, Thread
from collections import deque
import time
import matplotlib.pyplot as plt
from matplotlib.animation import FuncAnimation

class IntegratedNavigationSystem:
    """强化学习与传感器融合集成导航系统"""

    def __init__(self, dqn_model_path=None):
        """
        初始化集成导航系统

        Args:
            dqn_model_path: 预训练DQN模型路径
        """
        # 核心组件
        self.ekf = RobustMultiSensorEKF()
        self.dqn_agent = NavigationDQNAgent(state_size=20, action_size=5)

        # 加载预训练模型
        if dqn_model_path:
            self.dqn_agent.load_model(dqn_model_path)
            self.dqn_agent.epsilon = 0.0  # 关闭探索

        # 系统状态
        self.system_state = {
            'ekf_state': np.zeros(7),
            'ekf_covariance': np.eye(7),
            'goal_position': np.array([10.0, 10.0]),
            'current_action': 0,
            'last_reward': 0.0,
            'episode_reward': 0.0,
            'steps': 0
        }

        # 传感器数据缓冲
        self.sensor_buffer = {
            'imu': deque(maxlen=10),
            'odom': deque(maxlen=10),
            'gps': deque(maxlen=10),
            'lidar': deque(maxlen=10)
        }

        # 线程同步
        self.data_lock = Lock()
        self.running = False

        # 性能监控
        self.performance_metrics = {
            'computation_time': deque(maxlen=100),
            'ekf_time': deque(maxlen=100),
            'dqn_time': deque(maxlen=100),
            'fusion_accuracy': deque(maxlen=100),
            'navigation_success_rate': 0.0
        }

        # 可视化
        self.trajectory_history = deque(maxlen=1000)
        self.uncertainty_history = deque(maxlen=1000)

        print("集成导航系统初始化完成")

    def process_sensor_data(self, sensor_type, data, timestamp):
        """
        处理传感器数据

        Args:
            sensor_type: 传感器类型 ('imu', 'odom', 'gps', 'lidar')
            data: 传感器数据
            timestamp: 时间戳
        """
        with self.data_lock:
            self.sensor_buffer[sensor_type].append({
                'data': data,
                'timestamp': timestamp
            })

    def state_estimation_thread(self):
        """状态估计线程（EKF）"""
        last_time = time.time()

        while self.running:
            current_time = time.time()
            dt = current_time - last_time

            if dt >= 0.01:  # 100Hz更新频率
                start_time = time.time()

                with self.data_lock:
                    # EKF预测步骤
                    control_input = self.action_to_control(self.system_state['current_action'])
                    self.ekf.predict(control_input, dt)

                    # 传感器更新
                    self.update_ekf_with_sensors()

                    # 更新系统状态
                    self.system_state['ekf_state'] = self.ekf.get_state().flatten()
                    self.system_state['ekf_covariance'] = self.ekf.get_covariance()

                # 记录性能
                ekf_time = time.time() - start_time
                self.performance_metrics['ekf_time'].append(ekf_time)

                last_time = current_time

            time.sleep(0.001)  # 短暂休眠

    def decision_making_thread(self):
        """决策制定线程（DQN）"""
        last_time = time.time()

        while self.running:
            current_time = time.time()
            dt = current_time - last_time

            if dt >= 0.1:  # 10Hz决策频率
                start_time = time.time()

                with self.data_lock:
                    # 构建RL状态
                    rl_state = self.build_rl_state()

                    # DQN决策
                    action = self.dqn_agent.act(rl_state, training=False)

                    # 计算奖励
                    reward = self.calculate_reward()

                    # 更新系统状态
                    self.system_state['current_action'] = action
                    self.system_state['last_reward'] = reward
                    self.system_state['episode_reward'] += reward
                    self.system_state['steps'] += 1

                # 记录性能
                dqn_time = time.time() - start_time
                self.performance_metrics['dqn_time'].append(dqn_time)

                last_time = current_time

            time.sleep(0.01)

    def update_ekf_with_sensors(self):
        """使用最新传感器数据更新EKF"""

        # IMU更新
        if self.sensor_buffer['imu']:
            latest_imu = self.sensor_buffer['imu'][-1]['data']
            self.ekf.robust_update_imu(latest_imu)

        # 里程计更新
        if self.sensor_buffer['odom']:
            latest_odom = self.sensor_buffer['odom'][-1]['data']
            self.ekf.robust_update_odometry(latest_odom)

        # GPS更新
        if self.sensor_buffer['gps']:
            latest_gps = self.sensor_buffer['gps'][-1]['data']
            self.ekf.robust_update_gps(latest_gps)

    def build_rl_state(self):
        """构建强化学习状态向量"""

        ekf_state = self.system_state['ekf_state']
        ekf_cov = self.system_state['ekf_covariance']
        goal_pos = self.system_state['goal_position']

        # 提取位姿信息
        robot_pos = ekf_state[:2]
        robot_theta = ekf_state[2]
        robot_vel = ekf_state[3:5]

        # 计算目标相关信息
        goal_vector = goal_pos - robot_pos
        goal_distance = np.linalg.norm(goal_vector)
        goal_angle = np.arctan2(goal_vector[1], goal_vector[0]) - robot_theta
        goal_angle = np.arctan2(np.sin(goal_angle), np.cos(goal_angle))

        # 不确定性信息
        pos_uncertainty = np.sqrt(ekf_cov[0, 0] + ekf_cov[1, 1])
        angle_uncertainty = np.sqrt(ekf_cov[2, 2])

        # 激光雷达信息（简化）
        lidar_ranges = np.ones(8) * 5.0  # 默认值
        if self.sensor_buffer['lidar']:
            latest_lidar = self.sensor_buffer['lidar'][-1]['data']
            lidar_ranges = np.array(latest_lidar[:8])

        # 组合RL状态
        rl_state = np.concatenate([
            robot_pos / 20.0,  # 归一化位置
            [np.sin(robot_theta), np.cos(robot_theta)],  # 角度编码
            robot_vel / 2.0,  # 归一化速度
            [goal_distance / 20.0],  # 归一化目标距离
            [np.sin(goal_angle), np.cos(goal_angle)],  # 目标角度编码
            [pos_uncertainty, angle_uncertainty],  # 不确定性
            lidar_ranges / 5.0  # 归一化激光雷达
        ])

        return rl_state.astype(np.float32)

    def action_to_control(self, action):
        """将RL动作转换为控制输入"""

        action_map = {
            0: [0.5, 0.0],    # 前进
            1: [0.0, 0.5],    # 左转
            2: [0.0, -0.5],   # 右转
            3: [-0.3, 0.0],   # 后退
            4: [0.0, 0.0]     # 停止
        }

        return action_map.get(action, [0.0, 0.0])

    def calculate_reward(self):
        """计算强化学习奖励"""

        ekf_state = self.system_state['ekf_state']
        goal_pos = self.system_state['goal_position']

        # 当前位置
        robot_pos = ekf_state[:2]
        robot_vel = ekf_state[3:5]

        # 距离奖励
        goal_distance = np.linalg.norm(goal_pos - robot_pos)
        distance_reward = -goal_distance * 0.1

        # 到达目标奖励
        if goal_distance < 0.5:
            arrival_reward = 100.0
        else:
            arrival_reward = 0.0

        # 速度平滑性奖励
        smooth_penalty = -0.01 * abs(robot_vel[1])  # 角速度惩罚

        # 不确定性惩罚（鼓励在高置信度区域导航）
        ekf_cov = self.system_state['ekf_covariance']
        uncertainty_penalty = -0.1 * np.trace(ekf_cov[:2, :2])

        # 总奖励
        total_reward = distance_reward + arrival_reward + smooth_penalty + uncertainty_penalty

        return total_reward

    def start_system(self):
        """启动集成系统"""
        self.running = True

        # 启动线程
        self.ekf_thread = Thread(target=self.state_estimation_thread)
        self.dqn_thread = Thread(target=self.decision_making_thread)

        self.ekf_thread.start()
        self.dqn_thread.start()

        print("集成导航系统已启动")

    def stop_system(self):
        """停止集成系统"""
        self.running = False

        if hasattr(self, 'ekf_thread'):
            self.ekf_thread.join()
        if hasattr(self, 'dqn_thread'):
            self.dqn_thread.join()

        print("集成导航系统已停止")

    def get_current_pose(self):
        """获取当前位姿估计"""
        with self.data_lock:
            return self.system_state['ekf_state'][:3]

    def get_current_action(self):
        """获取当前动作"""
        with self.data_lock:
            return self.system_state['current_action']

    def set_goal(self, goal_position):
        """设置导航目标"""
        with self.data_lock:
            self.system_state['goal_position'] = np.array(goal_position)
            self.system_state['episode_reward'] = 0.0
            self.system_state['steps'] = 0

    def get_performance_metrics(self):
        """获取性能指标"""
        with self.data_lock:
            metrics = {}
            for key, values in self.performance_metrics.items():
                if isinstance(values, deque) and values:
                    metrics[key] = {
                        'mean': np.mean(values),
                        'std': np.std(values),
                        'max': np.max(values),
                        'min': np.min(values)
                    }
                else:
                    metrics[key] = values

            return metrics

class SystemSimulator:
    """集成系统仿真器"""

    def __init__(self, navigation_system):
        """
        Args:
            navigation_system: 集成导航系统实例
        """
        self.nav_system = navigation_system
        self.env = NavigationEnvironment(map_size=(20, 20), obstacle_ratio=0.1)

        # 仿真参数
        self.dt = 0.1
        self.max_simulation_time = 300  # 5分钟
        self.sensor_noise = {
            'imu': {'gyro': 0.01, 'acc': 0.1},
            'odom': {'pos': 0.1, 'angle': 0.05},
            'gps': {'pos': 1.0},
            'lidar': {'range': 0.1}
        }

        # 仿真记录
        self.simulation_data = {
            'time': [],
            'true_pose': [],
            'estimated_pose': [],
            'actions': [],
            'rewards': [],
            'computation_times': []
        }

    def run_simulation(self, num_episodes=10):
        """运行仿真"""

        print(f"开始仿真，共{num_episodes}个回合")

        episode_results = []

        for episode in range(num_episodes):
            print(f"\n=== 回合 {episode + 1}/{num_episodes} ===")

            # 重置环境和系统
            true_state = self.env.reset()
            self.nav_system.set_goal(self.env.goal_pos)

            # 启动系统
            self.nav_system.start_system()

            episode_data = self.run_single_episode()
            episode_results.append(episode_data)

            # 停止系统
            self.nav_system.stop_system()

            # 打印回合结果
            success = episode_data['success']
            total_reward = episode_data['total_reward']
            steps = episode_data['steps']
            final_distance = episode_data['final_distance']

            print(f"成功: {'是' if success else '否'}")
            print(f"总奖励: {total_reward:.2f}")
            print(f"步数: {steps}")
            print(f"最终距离: {final_distance:.3f}m")

        # 统计分析
        self.analyze_results(episode_results)

        return episode_results

    def run_single_episode(self):
        """运行单个回合"""

        episode_data = {
            'trajectory': [],
            'estimated_trajectory': [],
            'actions': [],
            'rewards': [],
            'computation_times': [],
            'success': False,
            'total_reward': 0.0,
            'steps': 0,
            'final_distance': 0.0
        }

        start_time = time.time()

        while time.time() - start_time < self.max_simulation_time:
            step_start = time.time()

            # 获取真实状态
            true_pose = self.env.robot_pos.tolist() + [self.env.robot_theta]

            # 生成传感器数据
            self.generate_and_feed_sensor_data(true_pose)

            # 获取系统输出
            estimated_pose = self.nav_system.get_current_pose()
            current_action = self.nav_system.get_current_action()

            # 执行动作
            control_input = self.nav_system.action_to_control(current_action)
            self.env.robot_v = control_input[0]
            self.env.robot_omega = control_input[1]

            # 更新环境
            next_state, reward, done = self.env.step(current_action)

            # 记录数据
            episode_data['trajectory'].append(true_pose)
            episode_data['estimated_trajectory'].append(estimated_pose.tolist())
            episode_data['actions'].append(current_action)
            episode_data['rewards'].append(reward)
            episode_data['total_reward'] += reward
            episode_data['steps'] += 1

            step_time = time.time() - step_start
            episode_data['computation_times'].append(step_time)

            # 检查终止条件
            if done:
                goal_distance = np.linalg.norm(self.env.robot_pos - np.array(self.env.goal_pos))
                episode_data['success'] = goal_distance < 0.5
                episode_data['final_distance'] = goal_distance
                break

            time.sleep(max(0, self.dt - step_time))

        return episode_data

    def generate_and_feed_sensor_data(self, true_pose):
        """生成并输入传感器数据"""

        current_time = time.time()

        # IMU数据
        true_omega = self.env.robot_omega
        imu_data = [
            true_omega + np.random.normal(0, self.sensor_noise['imu']['gyro']),
            np.random.normal(0, self.sensor_noise['imu']['acc'])
        ]
        self.nav_system.process_sensor_data('imu', imu_data, current_time)

        # 里程计数据
        odom_data = [
            true_pose[0] + np.random.normal(0, self.sensor_noise['odom']['pos']),
            true_pose[1] + np.random.normal(0, self.sensor_noise['odom']['pos']),
            true_pose[2] + np.random.normal(0, self.sensor_noise['odom']['angle'])
        ]
        self.nav_system.process_sensor_data('odom', odom_data, current_time)

        # GPS数据（低频）
        if np.random.random() < 0.1:  # 10% 概率
            gps_data = [
                true_pose[0] + np.random.normal(0, self.sensor_noise['gps']['pos']),
                true_pose[1] + np.random.normal(0, self.sensor_noise['gps']['pos'])
            ]
            self.nav_system.process_sensor_data('gps', gps_data, current_time)

        # 激光雷达数据
        lidar_ranges = []
        for angle in np.linspace(0, 2*np.pi, 8, endpoint=False):
            scan_angle = true_pose[2] + angle
            true_range = self.env.cast_ray(self.env.robot_pos, scan_angle, 5.0)
            noisy_range = true_range + np.random.normal(0, self.sensor_noise['lidar']['range'])
            lidar_ranges.append(max(0.1, noisy_range))

        self.nav_system.process_sensor_data('lidar', lidar_ranges, current_time)

    def analyze_results(self, episode_results):
        """分析仿真结果"""

        print("\n" + "="*50)
        print("仿真结果分析")
        print("="*50)

        # 成功率统计
        success_count = sum(1 for ep in episode_results if ep['success'])
        success_rate = success_count / len(episode_results)

        print(f"总回合数: {len(episode_results)}")
        print(f"成功回合数: {success_count}")
        print(f"成功率: {success_rate:.2%}")

        # 性能统计
        total_rewards = [ep['total_reward'] for ep in episode_results]
        steps_counts = [ep['steps'] for ep in episode_results]
        final_distances = [ep['final_distance'] for ep in episode_results]

        print(f"\n平均总奖励: {np.mean(total_rewards):.2f} ± {np.std(total_rewards):.2f}")
        print(f"平均步数: {np.mean(steps_counts):.1f} ± {np.std(steps_counts):.1f}")
        print(f"平均最终距离: {np.mean(final_distances):.3f} ± {np.std(final_distances):.3f}m")

        # 计算时间统计
        all_computation_times = []
        for ep in episode_results:
            all_computation_times.extend(ep['computation_times'])

        print(f"\n平均计算时间: {np.mean(all_computation_times)*1000:.2f}ms")
        print(f"最大计算时间: {np.max(all_computation_times)*1000:.2f}ms")

        # 可视化结果
        self.visualize_results(episode_results)

    def visualize_results(self, episode_results):
        """可视化仿真结果"""

        fig, axes = plt.subplots(2, 3, figsize=(18, 12))

        # 成功率统计
        success_rates = []
        for i in range(len(episode_results)):
            success_count = sum(1 for j in range(i+1) if episode_results[j]['success'])
            success_rates.append(success_count / (i+1))

        axes[0, 0].plot(success_rates, 'b-', linewidth=2)
        axes[0, 0].set_xlabel('回合数')
        axes[0, 0].set_ylabel('累积成功率')
        axes[0, 0].set_title('学习成功率')
        axes[0, 0].grid(True)

        # 奖励曲线
        rewards = [ep['total_reward'] for ep in episode_results]
        axes[0, 1].plot(rewards, 'g-', linewidth=2)
        axes[0, 1].set_xlabel('回合数')
        axes[0, 1].set_ylabel('总奖励')
        axes[0, 1].set_title('奖励曲线')
        axes[0, 1].grid(True)

        # 步数统计
        steps = [ep['steps'] for ep in episode_results]
        axes[0, 2].plot(steps, 'r-', linewidth=2)
        axes[0, 2].set_xlabel('回合数')
        axes[0, 2].set_ylabel('步数')
        axes[0, 2].set_title('收敛速度')
        axes[0, 2].grid(True)

        # 轨迹示例（最后一个成功回合）
        success_episodes = [ep for ep in episode_results if ep['success']]
        if success_episodes:
            last_success = success_episodes[-1]
            true_traj = np.array(last_success['trajectory'])
            est_traj = np.array(last_success['estimated_trajectory'])

            axes[1, 0].plot(true_traj[:, 0], true_traj[:, 1], 'g-',
                          label='真实轨迹', linewidth=3)
            axes[1, 0].plot(est_traj[:, 0], est_traj[:, 1], 'b--',
                          label='估计轨迹', linewidth=2)
            axes[1, 0].scatter([true_traj[0, 0]], [true_traj[0, 1]],
                             c='green', s=100, marker='o', label='起点')
            axes[1, 0].scatter([true_traj[-1, 0]], [true_traj[-1, 1]],
                             c='red', s=100, marker='*', label='终点')
            axes[1, 0].set_xlabel('X (m)')
            axes[1, 0].set_ylabel('Y (m)')
            axes[1, 0].set_title('轨迹对比（最后成功回合）')
            axes[1, 0].legend()
            axes[1, 0].grid(True)
            axes[1, 0].axis('equal')

        # 计算时间分布
        all_times = []
        for ep in episode_results:
            all_times.extend(ep['computation_times'])

        axes[1, 1].hist(np.array(all_times) * 1000, bins=30, alpha=0.7)
        axes[1, 1].set_xlabel('计算时间 (ms)')
        axes[1, 1].set_ylabel('频次')
        axes[1, 1].set_title('计算时间分布')
        axes[1, 1].grid(True)

        # 最终距离分布
        final_distances = [ep['final_distance'] for ep in episode_results]
        axes[1, 2].hist(final_distances, bins=20, alpha=0.7)
        axes[1, 2].axvline(0.5, color='red', linestyle='--', label='成功阈值')
        axes[1, 2].set_xlabel('最终距离 (m)')
        axes[1, 2].set_ylabel('频次')
        axes[1, 2].set_title('最终距离分布')
        axes[1, 2].legend()
        axes[1, 2].grid(True)

        plt.tight_layout()
        plt.show()

# 运行集成系统测试
def run_integrated_system_test():
    """运行集成系统测试"""

    print("=== 集成导航系统测试 ===")

    # 创建集成系统
    nav_system = IntegratedNavigationSystem()

    # 创建仿真器
    simulator = SystemSimulator(nav_system)

    # 运行仿真测试
    results = simulator.run_simulation(num_episodes=20)

    # 获取性能指标
    performance = nav_system.get_performance_metrics()

    print(f"\n=== 系统性能指标 ===")
    for metric, stats in performance.items():
        if isinstance(stats, dict):
            print(f"{metric}:")
            print(f"  均值: {stats['mean']:.4f}")
            print(f"  标准差: {stats['std']:.4f}")
            print(f"  最大值: {stats['max']:.4f}")
            print(f"  最小值: {stats['min']:.4f}")
        else:
            print(f"{metric}: {stats}")

    return nav_system, results

if __name__ == "__main__":
    nav_system, test_results = run_integrated_system_test()
    print("集成系统测试完成！")
```

## 2. 实时性能优化

### 2.1 计算复杂度分析

#### 时间复杂度分析

**EKF状态估计**：
- 预测步骤：$O(n^2)$，其中$n$是状态维度
- 更新步骤：$O(n^2 \cdot m)$，其中$m$是观测维度
- 矩阵求逆：$O(m^3)$

**DQN推理**：
- 前向传播：$O(W)$，其中$W$是网络权重数量
- 典型值：约1-5ms（GPU）或10-20ms（CPU）

**总体系统延迟**：
$$T_{total} = T_{sensor} + T_{EKF} + T_{DQN} + T_{control}$$

目标：$T_{total} < 100ms$（10Hz控制频率）

### 2.2 性能优化实现

```python
import cProfile
import pstats
from functools import wraps
import psutil
import threading
from multiprocessing import Pool
import numba
from numba import jit

class PerformanceOptimizer:
    """性能优化工具类"""

    def __init__(self):
        self.profiling_enabled = True
        self.performance_data = {}

    def profile_function(self, func_name):
        """函数性能分析装饰器"""
        def decorator(func):
            @wraps(func)
            def wrapper(*args, **kwargs):
                if self.profiling_enabled:
                    start_time = time.time()
                    result = func(*args, **kwargs)
                    end_time = time.time()

                    execution_time = end_time - start_time
                    if func_name not in self.performance_data:
                        self.performance_data[func_name] = []
                    self.performance_data[func_name].append(execution_time)

                    return result
                else:
                    return func(*args, **kwargs)
            return wrapper
        return decorator

    def get_performance_report(self):
        """生成性能报告"""
        report = {}
        for func_name, times in self.performance_data.items():
            report[func_name] = {
                'mean_time': np.mean(times),
                'max_time': np.max(times),
                'min_time': np.min(times),
                'std_time': np.std(times),
                'call_count': len(times),
                'total_time': np.sum(times)
            }
        return report

# 优化的矩阵运算
@jit(nopython=True, cache=True)
def fast_matrix_multiply(A, B):
    """优化的矩阵乘法"""
    return np.dot(A, B)

@jit(nopython=True, cache=True)
def fast_matrix_inverse(A):
    """优化的矩阵求逆"""
    return np.linalg.inv(A)

@jit(nopython=True, cache=True)
def normalize_angle_fast(angle):
    """快速角度归一化"""
    return np.arctan2(np.sin(angle), np.cos(angle))

class OptimizedMultiSensorEKF(MultiSensorEKF):
    """性能优化的多传感器EKF"""

    def __init__(self):
        super().__init__()
        self.optimizer = PerformanceOptimizer()

        # 预分配内存
        self.temp_matrices = {
            'F': np.eye(self.state_dim),
            'H_imu': np.zeros((2, self.state_dim)),
            'H_odom': np.zeros((3, self.state_dim)),
            'H_gps': np.zeros((2, self.state_dim)),
            'K': np.zeros((self.state_dim, 3)),  # 最大观测维度
            'S': np.zeros((3, 3)),
            'innovation': np.zeros((3, 1))
        }

        # 设置固定的H矩阵
        self.temp_matrices['H_imu'][0, 4] = 1  # gyro
        self.temp_matrices['H_imu'][0, 6] = 1  # gyro bias
        self.temp_matrices['H_imu'][1, 5] = 1  # acc bias

        self.temp_matrices['H_odom'][:3, :3] = np.eye(3)  # pose
        self.temp_matrices['H_gps'][:2, :2] = np.eye(2)   # position

    @PerformanceOptimizer().profile_function('ekf_predict')
    def predict(self, control_input, dt):
        """优化的预测步骤"""
        # 使用预分配的矩阵
        F = self.temp_matrices['F']
        F.fill(0)
        np.fill_diagonal(F, 1)

        # 当前状态
        v, theta = self.x[3, 0], self.x[2, 0]

        # 雅可比矩阵计算
        F[0, 2] = -v * np.sin(theta) * dt
        F[0, 3] = np.cos(theta) * dt
        F[1, 2] = v * np.cos(theta) * dt
        F[1, 3] = np.sin(theta) * dt
        F[2, 4] = dt

        # 状态预测
        px, py, omega = self.x[0, 0], self.x[1, 0], self.x[4, 0]
        u_v, u_omega = control_input

        self.x[0, 0] = px + v * np.cos(theta) * dt
        self.x[1, 0] = py + v * np.sin(theta) * dt
        self.x[2, 0] = normalize_angle_fast(theta + omega * dt)
        self.x[3, 0] = v + u_v * dt
        self.x[4, 0] = omega + u_omega * dt

        # 协方差预测
        self.P = fast_matrix_multiply(fast_matrix_multiply(F, self.P), F.T) + self.Q

    @PerformanceOptimizer().profile_function('ekf_update_imu')
    def update_imu(self, imu_measurement):
        """优化的IMU更新"""
        H = self.temp_matrices['H_imu']

        # 观测预测
        h = np.array([
            [self.x[4, 0] + self.x[6, 0]],  # omega + bias
            [imu_measurement[1]]            # acc (simplified)
        ])

        # 创新
        z = np.array(imu_measurement).reshape(-1, 1)
        innovation = z - h
        innovation[0, 0] = normalize_angle_fast(innovation[0, 0])

        # 创新协方差
        S = fast_matrix_multiply(fast_matrix_multiply(H, self.P), H.T) + self.R_imu

        # 卡尔曼增益
        K = fast_matrix_multiply(fast_matrix_multiply(self.P, H.T), fast_matrix_inverse(S))

        # 状态更新
        self.x = self.x + fast_matrix_multiply(K, innovation)
        self.x[2, 0] = normalize_angle_fast(self.x[2, 0])

        # 协方差更新（Joseph形式，数值稳定）
        I_KH = np.eye(self.state_dim) - fast_matrix_multiply(K, H)
        self.P = fast_matrix_multiply(fast_matrix_multiply(I_KH, self.P), I_KH.T) + \
                fast_matrix_multiply(fast_matrix_multiply(K, self.R_imu), K.T)

class OptimizedNavigationDQN(NavigationDQN):
    """优化的导航DQN网络"""

    def __init__(self, state_size=13, action_size=5, hidden_size=128):
        super().__init__(state_size, action_size, hidden_size)

        # 启用混合精度训练
        self.use_amp = torch.cuda.is_available()
        if self.use_amp:
            self.scaler = torch.cuda.amp.GradScaler()

    def forward(self, state):
        """优化的前向传播"""
        if self.use_amp and state.is_cuda:
            with torch.cuda.amp.autocast():
                return super().forward(state)
        else:
            return super().forward(state)

class OptimizedNavigationSystem(IntegratedNavigationSystem):
    """性能优化的导航系统"""

    def __init__(self, dqn_model_path=None):
        # 使用优化组件
        self.ekf = OptimizedMultiSensorEKF()
        self.dqn_agent = NavigationDQNAgent(state_size=20, action_size=5)

        # 性能监控
        self.performance_monitor = PerformanceOptimizer()

        # 并行处理池
        self.thread_pool = Pool(processes=2)

        # 数据预处理缓存
        self.state_cache = {}
        self.cache_valid = False

        super().__init__(dqn_model_path)

    @PerformanceOptimizer().profile_function('sensor_processing')
    def process_sensor_data_optimized(self, sensor_batch):
        """批量处理传感器数据"""
        for sensor_type, data, timestamp in sensor_batch:
            self.process_sensor_data(sensor_type, data, timestamp)

    @PerformanceOptimizer().profile_function('rl_state_build')
    def build_rl_state_cached(self):
        """带缓存的RL状态构建"""
        if self.cache_valid:
            return self.state_cache['rl_state']

        rl_state = self.build_rl_state()
        self.state_cache['rl_state'] = rl_state
        self.cache_valid = True

        return rl_state

    def invalidate_cache(self):
        """缓存失效"""
        self.cache_valid = False

    def get_optimization_report(self):
        """获取优化报告"""
        ekf_report = self.ekf.optimizer.get_performance_report()
        system_report = self.performance_monitor.get_performance_report()

        return {
            'ekf_performance': ekf_report,
            'system_performance': system_report,
            'memory_usage': psutil.Process().memory_info(),
            'cpu_usage': psutil.cpu_percent()
        }

# 基准测试
def benchmark_comparison():
    """对比优化前后的性能"""

    print("=== 性能基准测试 ===")

    # 测试数据
    num_iterations = 1000
    state_size = 20
    control_input = [0.5, 0.1]
    dt = 0.1

    # 原始版本测试
    print("测试原始版本...")
    original_ekf = MultiSensorEKF()
    start_time = time.time()

    for _ in range(num_iterations):
        original_ekf.predict(control_input, dt)

        # 模拟传感器更新
        imu_data = [0.1, 0.05]
        odom_data = [1.0, 1.0, 0.1]
        gps_data = [1.0, 1.0]

        original_ekf.update_imu(imu_data)
        original_ekf.update_odometry(odom_data)
        original_ekf.update_gps(gps_data)

    original_time = time.time() - start_time

    # 优化版本测试
    print("测试优化版本...")
    optimized_ekf = OptimizedMultiSensorEKF()
    start_time = time.time()

    for _ in range(num_iterations):
        optimized_ekf.predict(control_input, dt)

        # 模拟传感器更新
        imu_data = [0.1, 0.05]
        odom_data = [1.0, 1.0, 0.1]
        gps_data = [1.0, 1.0]

        optimized_ekf.update_imu(imu_data)
        optimized_ekf.update_odometry(odom_data)
        optimized_ekf.update_gps(gps_data)

    optimized_time = time.time() - start_time

    # 结果对比
    speedup = original_time / optimized_time
    print(f"\n原始版本时间: {original_time:.3f}s")
    print(f"优化版本时间: {optimized_time:.3f}s")
    print(f"加速比: {speedup:.2f}x")

    # DQN推理测试
    print("\n测试DQN推理性能...")
    device = torch.device("cuda" if torch.cuda.is_available() else "cpu")

    # 原始网络
    original_net = NavigationDQN(state_size, 5).to(device)
    optimized_net = OptimizedNavigationDQN(state_size, 5).to(device)

    test_states = torch.randn(100, state_size).to(device)

    # 原始网络推理
    start_time = time.time()
    with torch.no_grad():
        for state in test_states:
            _ = original_net(state.unsqueeze(0))
    original_inference_time = time.time() - start_time

    # 优化网络推理
    start_time = time.time()
    with torch.no_grad():
        for state in test_states:
            _ = optimized_net(state.unsqueeze(0))
    optimized_inference_time = time.time() - start_time

    inference_speedup = original_inference_time / optimized_inference_time
    print(f"原始DQN推理时间: {original_inference_time:.3f}s")
    print(f"优化DQN推理时间: {optimized_inference_time:.3f}s")
    print(f"DQN推理加速比: {inference_speedup:.2f}x")

    return {
        'ekf_speedup': speedup,
        'dqn_speedup': inference_speedup,
        'original_ekf_time': original_time,
        'optimized_ekf_time': optimized_time
    }

if __name__ == "__main__":
    benchmark_results = benchmark_comparison()
    print("\n性能优化测试完成！")
```

## 3. 鲁棒性测试与故障处理

### 3.1 传感器故障仿真

```python
class SensorFailureSimulator:
    """传感器故障仿真器"""

    def __init__(self):
        self.failure_types = {
            'dropout': self.simulate_dropout,
            'bias': self.simulate_bias,
            'noise': self.simulate_high_noise,
            'freeze': self.simulate_freeze,
            'outlier': self.simulate_outliers
        }

        self.failure_states = {
            'imu': {'active': False, 'type': None, 'params': {}},
            'odom': {'active': False, 'type': None, 'params': {}},
            'gps': {'active': False, 'type': None, 'params': {}}
        }

    def inject_failure(self, sensor_type, failure_type, **params):
        """注入传感器故障"""
        if sensor_type in self.failure_states and failure_type in self.failure_types:
            self.failure_states[sensor_type] = {
                'active': True,
                'type': failure_type,
                'params': params
            }
            print(f"已注入{sensor_type}传感器{failure_type}故障")

    def clear_failure(self, sensor_type):
        """清除传感器故障"""
        if sensor_type in self.failure_states:
            self.failure_states[sensor_type]['active'] = False
            print(f"已清除{sensor_type}传感器故障")

    def apply_failure(self, sensor_type, data):
        """应用故障效果"""
        failure_state = self.failure_states.get(sensor_type)

        if not failure_state or not failure_state['active']:
            return data

        failure_func = self.failure_types[failure_state['type']]
        return failure_func(data, **failure_state['params'])

    def simulate_dropout(self, data, dropout_rate=0.5):
        """模拟数据丢失"""
        if np.random.random() < dropout_rate:
            return None
        return data

    def simulate_bias(self, data, bias_values=None):
        """模拟传感器偏置"""
        if bias_values is None:
            bias_values = [0.1] * len(data)

        biased_data = []
        for i, value in enumerate(data):
            if i < len(bias_values):
                biased_data.append(value + bias_values[i])
            else:
                biased_data.append(value)

        return biased_data

    def simulate_high_noise(self, data, noise_multiplier=5.0):
        """模拟高噪声"""
        noisy_data = []
        for value in data:
            noise = np.random.normal(0, abs(value) * 0.1 * noise_multiplier)
            noisy_data.append(value + noise)

        return noisy_data

    def simulate_freeze(self, data, frozen_values=None):
        """模拟传感器冻结"""
        if frozen_values is None:
            # 使用上一次的值或零值
            frozen_values = [0.0] * len(data)

        return frozen_values

    def simulate_outliers(self, data, outlier_probability=0.1, outlier_magnitude=10.0):
        """模拟异常值"""
        outlier_data = []
        for value in data:
            if np.random.random() < outlier_probability:
                outlier = value + np.random.choice([-1, 1]) * outlier_magnitude
                outlier_data.append(outlier)
            else:
                outlier_data.append(value)

        return outlier_data

class RobustnessTestSuite:
    """鲁棒性测试套件"""

    def __init__(self, navigation_system):
        self.nav_system = navigation_system
        self.failure_sim = SensorFailureSimulator()
        self.test_results = {}

    def run_failure_tests(self):
        """运行故障测试"""

        print("=== 传感器故障鲁棒性测试 ===")

        test_scenarios = [
            {'name': 'IMU数据丢失', 'sensor': 'imu', 'failure': 'dropout', 'params': {'dropout_rate': 0.3}},
            {'name': 'GPS偏置故障', 'sensor': 'gps', 'failure': 'bias', 'params': {'bias_values': [2.0, 2.0]}},
            {'name': '里程计高噪声', 'sensor': 'odom', 'failure': 'noise', 'params': {'noise_multiplier': 3.0}},
            {'name': 'IMU冻结故障', 'sensor': 'imu', 'failure': 'freeze', 'params': {'frozen_values': [0.0, 0.0]}},
            {'name': 'GPS异常值', 'sensor': 'gps', 'failure': 'outlier', 'params': {'outlier_probability': 0.2}}
        ]

        for scenario in test_scenarios:
            print(f"\n测试场景: {scenario['name']}")
            result = self.run_single_failure_test(scenario)
            self.test_results[scenario['name']] = result

            print(f"导航成功率: {result['success_rate']:.2%}")
            print(f"平均定位误差: {result['avg_position_error']:.3f}m")
            print(f"系统稳定性: {'稳定' if result['system_stable'] else '不稳定'}")

        self.generate_robustness_report()

    def run_single_failure_test(self, scenario):
        """运行单个故障测试"""

        # 注入故障
        self.failure_sim.inject_failure(
            scenario['sensor'],
            scenario['failure'],
            **scenario['params']
        )

        # 创建测试环境
        env = NavigationEnvironment(map_size=(15, 15), obstacle_ratio=0.1)

        num_episodes = 10
        success_count = 0
        position_errors = []
        system_stability = True

        for episode in range(num_episodes):
            try:
                # 重置环境
                env.reset()
                self.nav_system.set_goal(env.goal_pos)

                # 运行测试回合
                episode_result = self.run_failure_episode(env)

                if episode_result['success']:
                    success_count += 1

                position_errors.append(episode_result['final_error'])

            except Exception as e:
                print(f"Episode {episode} 失败: {e}")
                system_stability = False

        # 清除故障
        self.failure_sim.clear_failure(scenario['sensor'])

        return {
            'success_rate': success_count / num_episodes,
            'avg_position_error': np.mean(position_errors),
            'max_position_error': np.max(position_errors),
            'system_stable': system_stability
        }

    def run_failure_episode(self, env):
        """在故障条件下运行单个回合"""

        max_steps = 200
        success = False
        final_error = float('inf')

        for step in range(max_steps):
            # 获取真实状态
            true_pose = [env.robot_pos[0], env.robot_pos[1], env.robot_theta]

            # 生成带故障的传感器数据
            self.generate_faulty_sensor_data(true_pose)

            # 系统决策
            estimated_pose = self.nav_system.get_current_pose()
            action = self.nav_system.get_current_action()

            # 执行动作
            control_input = self.nav_system.action_to_control(action)
            env.robot_v = control_input[0]
            env.robot_omega = control_input[1]

            _, _, done = env.step(action)

            if done:
                goal_distance = np.linalg.norm(env.robot_pos - np.array(env.goal_pos))
                success = goal_distance < 0.5
                final_error = goal_distance
                break

            time.sleep(0.01)

        return {
            'success': success,
            'final_error': final_error,
            'steps': step + 1
        }

    def generate_faulty_sensor_data(self, true_pose):
        """生成带故障的传感器数据"""

        current_time = time.time()

        # IMU数据（可能有故障）
        imu_data = [
            true_pose[2] + np.random.normal(0, 0.01),  # 简化的角速度
            np.random.normal(0, 0.1)  # 加速度
        ]
        faulty_imu = self.failure_sim.apply_failure('imu', imu_data)
        if faulty_imu is not None:
            self.nav_system.process_sensor_data('imu', faulty_imu, current_time)

        # 里程计数据（可能有故障）
        odom_data = [
            true_pose[0] + np.random.normal(0, 0.1),
            true_pose[1] + np.random.normal(0, 0.1),
            true_pose[2] + np.random.normal(0, 0.05)
        ]
        faulty_odom = self.failure_sim.apply_failure('odom', odom_data)
        if faulty_odom is not None:
            self.nav_system.process_sensor_data('odom', faulty_odom, current_time)

        # GPS数据（可能有故障，低频）
        if np.random.random() < 0.1:
            gps_data = [
                true_pose[0] + np.random.normal(0, 1.0),
                true_pose[1] + np.random.normal(0, 1.0)
            ]
            faulty_gps = self.failure_sim.apply_failure('gps', gps_data)
            if faulty_gps is not None:
                self.nav_system.process_sensor_data('gps', faulty_gps, current_time)

    def generate_robustness_report(self):
        """生成鲁棒性测试报告"""

        print("\n" + "="*60)
        print("鲁棒性测试报告")
        print("="*60)

        # 总体统计
        all_success_rates = [result['success_rate'] for result in self.test_results.values()]
        all_errors = [result['avg_position_error'] for result in self.test_results.values()]

        print(f"总体平均成功率: {np.mean(all_success_rates):.2%}")
        print(f"总体平均定位误差: {np.mean(all_errors):.3f}m")

        # 详细结果
        print("\n详细测试结果:")
        for scenario, result in self.test_results.items():
            print(f"\n{scenario}:")
            print(f"  成功率: {result['success_rate']:.2%}")
            print(f"  平均误差: {result['avg_position_error']:.3f}m")
            print(f"  最大误差: {result['max_position_error']:.3f}m")
            print(f"  系统稳定: {'是' if result['system_stable'] else '否'}")

        # 可视化结果
        self.visualize_robustness_results()

    def visualize_robustness_results(self):
        """可视化鲁棒性测试结果"""

        scenarios = list(self.test_results.keys())
        success_rates = [self.test_results[s]['success_rate'] for s in scenarios]
        avg_errors = [self.test_results[s]['avg_position_error'] for s in scenarios]

        fig, axes = plt.subplots(1, 2, figsize=(15, 6))

        # 成功率对比
        bars1 = axes[0].bar(range(len(scenarios)), success_rates, color='skyblue')
        axes[0].set_xlabel('测试场景')
        axes[0].set_ylabel('成功率')
        axes[0].set_title('不同故障场景下的导航成功率')
        axes[0].set_xticks(range(len(scenarios)))
        axes[0].set_xticklabels(scenarios, rotation=45, ha='right')
        axes[0].set_ylim(0, 1)

        # 添加数值标签
        for i, bar in enumerate(bars1):
            height = bar.get_height()
            axes[0].text(bar.get_x() + bar.get_width()/2., height + 0.01,
                        f'{height:.2%}', ha='center', va='bottom')

        # 定位误差对比
        bars2 = axes[1].bar(range(len(scenarios)), avg_errors, color='lightcoral')
        axes[1].set_xlabel('测试场景')
        axes[1].set_ylabel('平均定位误差 (m)')
        axes[1].set_title('不同故障场景下的定位误差')
        axes[1].set_xticks(range(len(scenarios)))
        axes[1].set_xticklabels(scenarios, rotation=45, ha='right')

        # 添加数值标签
        for i, bar in enumerate(bars2):
            height = bar.get_height()
            axes[1].text(bar.get_x() + bar.get_width()/2., height + 0.01,
                        f'{height:.3f}', ha='center', va='bottom')

        plt.tight_layout()
        plt.show()

# 运行鲁棒性测试
def run_robustness_tests():
    """运行完整的鲁棒性测试"""

    print("=== 启动鲁棒性测试 ===")

    # 创建优化的导航系统
    nav_system = OptimizedNavigationSystem()

    # 创建测试套件
    test_suite = RobustnessTestSuite(nav_system)

    # 启动导航系统
    nav_system.start_system()

    try:
        # 运行故障测试
        test_suite.run_failure_tests()

    finally:
        # 停止导航系统
        nav_system.stop_system()

    return test_suite.test_results

if __name__ == "__main__":
    robustness_results = run_robustness_tests()
    print("鲁棒性测试完成！")
```

## 4. 结果分析与可视化

### 4.1 综合性能评估

```python
class PerformanceAnalyzer:
    """性能分析器"""

    def __init__(self):
        self.metrics = {
            'navigation_success_rate': [],
            'position_accuracy': [],
            'computation_time': [],
            'robustness_score': [],
            'learning_efficiency': [],
            'energy_efficiency': []
        }

    def evaluate_system_performance(self, test_results, robustness_results):
        """评估系统整体性能"""

        print("=== 系统性能综合评估 ===")

        # 导航性能
        success_rates = [ep['success'] for ep in test_results if 'success' in ep]
        navigation_success_rate = np.mean(success_rates) if success_rates else 0.0

        # 定位精度
        if test_results and 'trajectory' in test_results[0]:
            position_errors = []
            for episode in test_results:
                if 'trajectory' in episode and 'estimated_trajectory' in episode:
                    true_traj = np.array(episode['trajectory'])
                    est_traj = np.array(episode['estimated_trajectory'])
                    errors = np.sqrt(np.sum((true_traj[:, :2] - est_traj[:, :2])**2, axis=1))
                    position_errors.extend(errors)

            avg_position_error = np.mean(position_errors) if position_errors else float('inf')
            position_accuracy = max(0, 1 - avg_position_error / 5.0)  # 归一化到0-1
        else:
            position_accuracy = 0.0

        # 计算时间
        computation_times = []
        for episode in test_results:
            if 'computation_times' in episode:
                computation_times.extend(episode['computation_times'])

        avg_computation_time = np.mean(computation_times) if computation_times else 0.0
        time_efficiency = max(0, 1 - avg_computation_time / 0.1)  # 目标100ms

        # 鲁棒性评分
        if robustness_results:
            robustness_scores = [result['success_rate'] for result in robustness_results.values()]
            robustness_score = np.mean(robustness_scores)
        else:
            robustness_score = 0.0

        # 综合评分
        weights = {
            'navigation': 0.3,
            'accuracy': 0.25,
            'efficiency': 0.2,
            'robustness': 0.25
        }

        overall_score = (
            weights['navigation'] * navigation_success_rate +
            weights['accuracy'] * position_accuracy +
            weights['efficiency'] * time_efficiency +
            weights['robustness'] * robustness_score
        )

        # 性能报告
        performance_report = {
            'overall_score': overall_score,
            'navigation_success_rate': navigation_success_rate,
            'position_accuracy': position_accuracy,
            'time_efficiency': time_efficiency,
            'robustness_score': robustness_score,
            'avg_computation_time': avg_computation_time * 1000,  # 转换为ms
            'avg_position_error': avg_position_error if 'avg_position_error' in locals() else 0.0
        }

        # 打印报告
        print(f"总体评分: {overall_score:.3f}/1.000")
        print(f"导航成功率: {navigation_success_rate:.2%}")
        print(f"定位精度得分: {position_accuracy:.3f}")
        print(f"计算效率得分: {time_efficiency:.3f}")
        print(f"鲁棒性得分: {robustness_score:.3f}")
        print(f"平均计算时间: {avg_computation_time*1000:.2f}ms")

        if 'avg_position_error' in locals():
            print(f"平均定位误差: {avg_position_error:.3f}m")

        # 性能等级评定
        if overall_score >= 0.9:
            grade = "优秀"
        elif overall_score >= 0.8:
            grade = "良好"
        elif overall_score >= 0.7:
            grade = "中等"
        elif overall_score >= 0.6:
            grade = "及格"
        else:
            grade = "不及格"

        print(f"性能等级: {grade}")

        return performance_report

    def generate_performance_charts(self, performance_report, test_results):
        """生成性能图表"""

        fig, axes = plt.subplots(2, 3, figsize=(18, 12))

        # 雷达图 - 综合性能
        categories = ['导航成功率', '定位精度', '计算效率', '鲁棒性']
        values = [
            performance_report['navigation_success_rate'],
            performance_report['position_accuracy'],
            performance_report['time_efficiency'],
            performance_report['robustness_score']
        ]

        angles = np.linspace(0, 2*np.pi, len(categories), endpoint=False)
        values_closed = values + [values[0]]
        angles_closed = np.concatenate([angles, [angles[0]]])

        axes[0, 0].plot(angles_closed, values_closed, 'o-', linewidth=2)
        axes[0, 0].fill(angles_closed, values_closed, alpha=0.25)
        axes[0, 0].set_xticks(angles)
        axes[0, 0].set_xticklabels(categories)
        axes[0, 0].set_ylim(0, 1)
        axes[0, 0].set_title('系统综合性能雷达图')
        axes[0, 0].grid(True)

        # 学习曲线
        if test_results:
            episode_rewards = []
            success_rates = []

            for i, episode in enumerate(test_results):
                if 'total_reward' in episode:
                    episode_rewards.append(episode['total_reward'])

                # 计算滑动成功率
                window_size = min(10, i + 1)
                recent_episodes = test_results[max(0, i-window_size+1):i+1]
                recent_successes = [ep.get('success', False) for ep in recent_episodes]
                success_rate = np.mean(recent_successes)
                success_rates.append(success_rate)

            axes[0, 1].plot(episode_rewards, alpha=0.7, label='回合奖励')
            axes[0, 1].plot(np.convolve(episode_rewards, np.ones(5)/5, mode='valid'),
                           linewidth=2, label='5回合平均')
            axes[0, 1].set_xlabel('回合数')
            axes[0, 1].set_ylabel('奖励')
            axes[0, 1].set_title('学习曲线')
            axes[0, 1].legend()
            axes[0, 1].grid(True)

            axes[0, 2].plot(success_rates, linewidth=2, color='green')
            axes[0, 2].set_xlabel('回合数')
            axes[0, 2].set_ylabel('成功率')
            axes[0, 2].set_title('成功率变化')
            axes[0, 2].set_ylim(0, 1)
            axes[0, 2].grid(True)

        # 计算时间分布
        all_times = []
        for episode in test_results:
            if 'computation_times' in episode:
                all_times.extend(episode['computation_times'])

        if all_times:
            axes[1, 0].hist(np.array(all_times) * 1000, bins=30, alpha=0.7, color='orange')
            axes[1, 0].axvline(performance_report['avg_computation_time'],
                              color='red', linestyle='--', label='平均值')
            axes[1, 0].axvline(100, color='green', linestyle='--', label='目标值(100ms)')
            axes[1, 0].set_xlabel('计算时间 (ms)')
            axes[1, 0].set_ylabel('频次')
            axes[1, 0].set_title('计算时间分布')
            axes[1, 0].legend()
            axes[1, 0].grid(True)

        # 性能对比柱状图
        metrics = ['导航成功率', '定位精度', '计算效率', '鲁棒性']
        scores = [performance_report[key] for key in
                 ['navigation_success_rate', 'position_accuracy', 'time_efficiency', 'robustness_score']]

        bars = axes[1, 1].bar(metrics, scores, color=['blue', 'green', 'orange', 'red'], alpha=0.7)
        axes[1, 1].set_ylabel('得分')
        axes[1, 1].set_title('各项指标得分')
        axes[1, 1].set_ylim(0, 1)

        # 添加数值标签
        for bar, score in zip(bars, scores):
            height = bar.get_height()
            axes[1, 1].text(bar.get_x() + bar.get_width()/2., height + 0.01,
                           f'{score:.3f}', ha='center', va='bottom')

        # 总体评分仪表盘
        overall_score = performance_report['overall_score']

        # 绘制半圆仪表盘
        theta = np.linspace(0, np.pi, 100)
        r = 1

        # 背景扇形
        axes[1, 2].fill_between(theta, 0, r, alpha=0.3, color='lightgray')

        # 分数对应的角度
        score_angle = overall_score * np.pi
        score_theta = np.linspace(0, score_angle, int(overall_score * 100))

        # 根据分数选择颜色
        if overall_score >= 0.8:
            color = 'green'
        elif overall_score >= 0.6:
            color = 'orange'
        else:
            color = 'red'

        axes[1, 2].fill_between(score_theta, 0, r, alpha=0.8, color=color)

        # 指针
        axes[1, 2].plot([score_angle, score_angle], [0, r], 'k-', linewidth=3)

        # 分数刻度
        for i in range(6):
            angle = i * np.pi / 5
            axes[1, 2].plot([angle, angle], [0.9, 1], 'k-', linewidth=1)
            axes[1, 2].text(angle, 1.1, f'{i*0.2:.1f}', ha='center', va='center')

        axes[1, 2].set_xlim(-0.2, np.pi + 0.2)
        axes[1, 2].set_ylim(-0.2, 1.3)
        axes[1, 2].set_aspect('equal')
        axes[1, 2].axis('off')
        axes[1, 2].set_title(f'总体评分: {overall_score:.3f}')

        plt.tight_layout()
        plt.show()

        return fig

def run_complete_system_evaluation():
    """运行完整的系统评估"""

    print("=== 启动完整系统评估 ===")

    # 1. 创建并测试集成系统
    print("1. 集成系统测试...")
    nav_system, test_results = run_integrated_system_test()

    # 2. 鲁棒性测试
    print("\n2. 鲁棒性测试...")
    robustness_results = run_robustness_tests()

    # 3. 性能优化测试
    print("\n3. 性能优化测试...")
    optimization_results = benchmark_comparison()

    # 4. 综合性能分析
    print("\n4. 综合性能分析...")
    analyzer = PerformanceAnalyzer()
    performance_report = analyzer.evaluate_system_performance(test_results, robustness_results)

    # 5. 生成可视化报告
    print("\n5. 生成可视化报告...")
    analyzer.generate_performance_charts(performance_report, test_results)

    # 6. 生成最终报告
    final_report = {
        'test_results': test_results,
        'robustness_results': robustness_results,
        'optimization_results': optimization_results,
        'performance_report': performance_report,
        'timestamp': time.strftime('%Y-%m-%d %H:%M:%S')
    }

    # 保存报告
    import json
    with open(f'system_evaluation_report_{int(time.time())}.json', 'w') as f:
        # 转换numpy数组为列表以便JSON序列化
        def convert_numpy(obj):
            if isinstance(obj, np.ndarray):
                return obj.tolist()
            elif isinstance(obj, dict):
                return {k: convert_numpy(v) for k, v in obj.items()}
            elif isinstance(obj, list):
                return [convert_numpy(item) for item in obj]
            else:
                return obj

        json.dump(convert_numpy(final_report), f, indent=2)

    print(f"\n=== 评估完成 ===")
    print(f"最终系统评分: {performance_report['overall_score']:.3f}/1.000")
    print(f"评估报告已保存")

    return final_report

if __name__ == "__main__":
    final_evaluation = run_complete_system_evaluation()
    print("完整系统评估完成！")
```

## 学习检查点

### 系统集成验证

1. **架构合理性**：
   - 组件间接口设计
   - 数据流和控制流
   - 实时性能保证

2. **功能完整性**：
   - 传感器融合效果
   - 强化学习决策质量
   - 故障处理能力

3. **性能指标**：
   - 导航成功率 > 85%
   - 平均定位误差 < 0.5m
   - 计算延迟 < 100ms
   - 鲁棒性得分 > 0.8

### 项目成果

完成本阶段后，学生将获得：
- 完整的自主导航系统
- 全面的性能评估报告
- 深入的问题分析能力
- 系统优化和调试经验

**最终交付物**：
1. 完整系统源代码
2. 技术文档和用户手册
3. 性能测试报告
4. 演示视频和PPT
5. 问题总结和改进建议