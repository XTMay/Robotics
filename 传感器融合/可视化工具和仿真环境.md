# 可视化工具和仿真环境

## 1. 交互式卡尔曼滤波可视化

### 1.1 实时滤波过程可视化

```python
import numpy as np
import matplotlib.pyplot as plt
from matplotlib.animation import FuncAnimation
from matplotlib.widgets import Slider, Button, CheckButtons
import ipywidgets as widgets
from IPython.display import display, clear_output
import threading
import time

class InteractiveKalmanVisualizer:
    """交互式卡尔曼滤波可视化工具"""

    def __init__(self):
        # 滤波器参数
        self.dt = 0.1
        self.process_noise = 0.1
        self.observation_noise = 0.5

        # 仿真数据
        self.true_positions = []
        self.observations = []
        self.kf_estimates = []
        self.kf_covariances = []

        # 动画控制
        self.is_running = False
        self.current_step = 0

        # 设置图形界面
        self.setup_visualization()

    def setup_visualization(self):
        """设置可视化界面"""
        self.fig, self.axes = plt.subplots(2, 2, figsize=(15, 10))
        self.fig.suptitle('交互式卡尔曼滤波可视化', fontsize=16)

        # 轨迹图
        self.ax_traj = self.axes[0, 0]
        self.ax_traj.set_title('位置跟踪')
        self.ax_traj.set_xlabel('时间步')
        self.ax_traj.set_ylabel('位置')
        self.ax_traj.grid(True, alpha=0.3)

        # Q值演化图
        self.ax_q = self.axes[0, 1]
        self.ax_q.set_title('Q值演化')
        self.ax_q.set_xlabel('时间步')
        self.ax_q.set_ylabel('Q值')
        self.ax_q.grid(True, alpha=0.3)

        # 不确定性图
        self.ax_uncertainty = self.axes[1, 0]
        self.ax_uncertainty.set_title('估计不确定性')
        self.ax_uncertainty.set_xlabel('时间步')
        self.ax_uncertainty.set_ylabel('标准差')
        self.ax_uncertainty.grid(True, alpha=0.3)

        # 创新图
        self.ax_innovation = self.axes[1, 1]
        self.ax_innovation.set_title('创新序列')
        self.ax_innovation.set_xlabel('时间步')
        self.ax_innovation.set_ylabel('创新值')
        self.ax_innovation.grid(True, alpha=0.3)

        # 添加控制滑块
        self.add_controls()

    def add_controls(self):
        """添加交互控制"""
        # 为滑块留出空间
        plt.subplots_adjust(bottom=0.25)

        # 过程噪声滑块
        ax_process = plt.axes([0.1, 0.1, 0.3, 0.03])
        self.slider_process = Slider(ax_process, '过程噪声', 0.01, 1.0,
                                   valinit=self.process_noise, valfmt='%.2f')

        # 观测噪声滑块
        ax_obs = plt.axes([0.1, 0.05, 0.3, 0.03])
        self.slider_obs = Slider(ax_obs, '观测噪声', 0.1, 2.0,
                               valinit=self.observation_noise, valfmt='%.2f')

        # 控制按钮
        ax_start = plt.axes([0.5, 0.1, 0.1, 0.04])
        self.button_start = Button(ax_start, '开始')

        ax_reset = plt.axes([0.62, 0.1, 0.1, 0.04])
        self.button_reset = Button(ax_reset, '重置')

        ax_step = plt.axes([0.74, 0.1, 0.1, 0.04])
        self.button_step = Button(ax_step, '单步')

        # 绑定事件
        self.slider_process.on_changed(self.update_process_noise)
        self.slider_obs.on_changed(self.update_observation_noise)
        self.button_start.on_clicked(self.toggle_animation)
        self.button_reset.on_clicked(self.reset_simulation)
        self.button_step.on_clicked(self.single_step)

    def update_process_noise(self, val):
        """更新过程噪声"""
        self.process_noise = val

    def update_observation_noise(self, val):
        """更新观测噪声"""
        self.observation_noise = val

    def generate_true_trajectory(self, n_steps=100):
        """生成真实轨迹"""
        trajectory = []
        position = 0
        velocity = 1

        for i in range(n_steps):
            # 简单的运动模型
            if i < 20:
                acceleration = 0
            elif i < 50:
                acceleration = 0.1
            elif i < 80:
                acceleration = -0.1
            else:
                acceleration = 0

            velocity += acceleration * self.dt
            position += velocity * self.dt

            trajectory.append(position)

        return trajectory

    def run_kalman_filter(self, true_trajectory):
        """运行卡尔曼滤波"""
        from阶段一_卡尔曼滤波基础与实现 import KalmanFilter

        # 初始化滤波器
        F = np.array([[1, self.dt], [0, 1]])  # 状态转移矩阵
        H = np.array([[1, 0]])                # 观测矩阵
        Q = self.process_noise**2 * np.array([[self.dt**3/3, self.dt**2/2],
                                             [self.dt**2/2, self.dt]])
        R = np.array([[self.observation_noise**2]])
        x0 = np.array([0, 0])
        P0 = np.eye(2) * 10

        kf = KalmanFilter(F, None, H, Q, R, x0, P0)

        estimates = []
        covariances = []
        observations = []

        for i, true_pos in enumerate(true_trajectory):
            # 生成观测
            obs = true_pos + np.random.normal(0, self.observation_noise)
            observations.append(obs)

            # 预测和更新
            kf.predict()
            kf.update([obs])

            # 记录结果
            x, P = kf.get_state()
            estimates.append(x[0])  # 只要位置
            covariances.append(np.sqrt(P[0, 0]))

        return estimates, covariances, observations

    def single_step(self, event=None):
        """执行单步仿真"""
        if self.current_step >= len(self.true_positions):
            return

        self.update_plots()
        self.current_step += 1

    def update_plots(self):
        """更新所有图表"""
        if self.current_step >= len(self.true_positions):
            return

        # 清除旧图
        for ax in self.axes.flat:
            ax.clear()

        steps = range(self.current_step + 1)

        # 轨迹图
        self.ax_traj.plot(steps, self.true_positions[:self.current_step+1],
                         'g-', linewidth=2, label='真实轨迹')
        self.ax_traj.scatter(steps[:-1], self.observations[:self.current_step],
                           color='red', alpha=0.6, s=20, label='观测值')
        self.ax_traj.plot(steps, self.kf_estimates[:self.current_step+1],
                         'b-', linewidth=2, label='卡尔曼估计')

        # 不确定性区间
        estimates = np.array(self.kf_estimates[:self.current_step+1])
        uncertainties = np.array(self.kf_covariances[:self.current_step+1])

        self.ax_traj.fill_between(steps,
                                estimates - 2*uncertainties,
                                estimates + 2*uncertainties,
                                alpha=0.2, color='blue', label='95%置信区间')

        self.ax_traj.set_title('位置跟踪')
        self.ax_traj.set_xlabel('时间步')
        self.ax_traj.set_ylabel('位置')
        self.ax_traj.legend()
        self.ax_traj.grid(True, alpha=0.3)

        # 不确定性演化
        self.ax_uncertainty.plot(steps, uncertainties, 'purple', linewidth=2)
        self.ax_uncertainty.set_title('估计不确定性')
        self.ax_uncertainty.set_xlabel('时间步')
        self.ax_uncertainty.set_ylabel('标准差')
        self.ax_uncertainty.grid(True, alpha=0.3)

        plt.draw()

    def toggle_animation(self, event):
        """切换动画状态"""
        self.is_running = not self.is_running
        if self.is_running:
            self.button_start.label.set_text('暂停')
            self.start_animation()
        else:
            self.button_start.label.set_text('开始')

    def start_animation(self):
        """开始动画"""
        def animate():
            while self.is_running and self.current_step < len(self.true_positions):
                self.single_step()
                time.sleep(0.1)

            self.is_running = False
            self.button_start.label.set_text('开始')

        threading.Thread(target=animate, daemon=True).start()

    def reset_simulation(self, event):
        """重置仿真"""
        self.is_running = False
        self.current_step = 0
        self.button_start.label.set_text('开始')

        # 重新生成数据
        self.true_positions = self.generate_true_trajectory(100)
        estimates, covariances, observations = self.run_kalman_filter(self.true_positions)

        self.kf_estimates = estimates
        self.kf_covariances = covariances
        self.observations = observations

        # 清除图表
        for ax in self.axes.flat:
            ax.clear()

        self.update_plots()

    def show(self):
        """显示可视化工具"""
        # 初始化数据
        self.reset_simulation(None)
        plt.show()

# 使用示例
def demo_interactive_kalman():
    """演示交互式卡尔曼滤波"""
    visualizer = InteractiveKalmanVisualizer()
    visualizer.show()

# demo_interactive_kalman()
```

### 1.2 参数敏感性分析工具

```python
class ParameterSensitivityAnalyzer:
    """参数敏感性分析工具"""

    def __init__(self):
        self.results_cache = {}

    def analyze_parameter_space(self, param_ranges, n_trials=10):
        """分析参数空间"""

        # 参数网格
        process_noise_range = param_ranges.get('process_noise', [0.01, 0.1, 0.5, 1.0])
        obs_noise_range = param_ranges.get('obs_noise', [0.1, 0.5, 1.0, 2.0])
        dt_range = param_ranges.get('dt', [0.05, 0.1, 0.2])

        results = {}

        print("开始参数敏感性分析...")
        total_combinations = len(process_noise_range) * len(obs_noise_range) * len(dt_range)
        current_combo = 0

        for process_noise in process_noise_range:
            for obs_noise in obs_noise_range:
                for dt in dt_range:
                    current_combo += 1
                    print(f"进度: {current_combo}/{total_combinations}")

                    # 运行多次试验
                    trial_results = []
                    for trial in range(n_trials):
                        rmse = self.run_single_trial(process_noise, obs_noise, dt)
                        trial_results.append(rmse)

                    # 记录平均结果
                    results[(process_noise, obs_noise, dt)] = {
                        'mean_rmse': np.mean(trial_results),
                        'std_rmse': np.std(trial_results),
                        'min_rmse': np.min(trial_results),
                        'max_rmse': np.max(trial_results)
                    }

        self.results_cache = results
        return results

    def run_single_trial(self, process_noise, obs_noise, dt):
        """运行单次试验"""
        # 生成真实轨迹
        n_steps = 100
        true_trajectory = []
        velocity = 1.0

        for i in range(n_steps):
            position = velocity * dt * i
            true_trajectory.append(position)

        # 运行卡尔曼滤波
        from阶段一_卡尔曼滤波基础与实现 import KalmanFilter

        F = np.array([[1, dt], [0, 1]])
        H = np.array([[1, 0]])
        Q = process_noise**2 * np.array([[dt**3/3, dt**2/2],
                                        [dt**2/2, dt]])
        R = np.array([[obs_noise**2]])
        x0 = np.array([0, 0])
        P0 = np.eye(2) * 10

        kf = KalmanFilter(F, None, H, Q, R, x0, P0)

        estimates = []
        for true_pos in true_trajectory:
            obs = true_pos + np.random.normal(0, obs_noise)
            kf.predict()
            kf.update([obs])
            x, _ = kf.get_state()
            estimates.append(x[0])

        # 计算RMSE
        errors = np.array(true_trajectory) - np.array(estimates)
        rmse = np.sqrt(np.mean(errors**2))

        return rmse

    def visualize_sensitivity_results(self, results=None):
        """可视化敏感性分析结果"""
        if results is None:
            results = self.results_cache

        if not results:
            print("没有可用的分析结果，请先运行 analyze_parameter_space()")
            return

        # 提取参数组合和性能指标
        param_combinations = list(results.keys())
        mean_rmses = [results[combo]['mean_rmse'] for combo in param_combinations]

        # 分别分析每个参数的影响
        self.plot_parameter_effects(param_combinations, mean_rmses)

    def plot_parameter_effects(self, param_combinations, performance_values):
        """绘制参数效应图"""
        fig, axes = plt.subplots(2, 2, figsize=(15, 12))

        # 过程噪声影响
        process_noises = [combo[0] for combo in param_combinations]
        unique_process = sorted(list(set(process_noises)))

        process_effects = {}
        for pn in unique_process:
            effects = [perf for combo, perf in zip(param_combinations, performance_values)
                      if combo[0] == pn]
            process_effects[pn] = effects

        axes[0, 0].boxplot([process_effects[pn] for pn in unique_process],
                          labels=[f'{pn:.2f}' for pn in unique_process])
        axes[0, 0].set_title('过程噪声对性能的影响')
        axes[0, 0].set_xlabel('过程噪声标准差')
        axes[0, 0].set_ylabel('RMSE')
        axes[0, 0].grid(True, alpha=0.3)

        # 观测噪声影响
        obs_noises = [combo[1] for combo in param_combinations]
        unique_obs = sorted(list(set(obs_noises)))

        obs_effects = {}
        for on in unique_obs:
            effects = [perf for combo, perf in zip(param_combinations, performance_values)
                      if combo[1] == on]
            obs_effects[on] = effects

        axes[0, 1].boxplot([obs_effects[on] for on in unique_obs],
                          labels=[f'{on:.1f}' for on in unique_obs])
        axes[0, 1].set_title('观测噪声对性能的影响')
        axes[0, 1].set_xlabel('观测噪声标准差')
        axes[0, 1].set_ylabel('RMSE')
        axes[0, 1].grid(True, alpha=0.3)

        # 时间步长影响
        dts = [combo[2] for combo in param_combinations]
        unique_dts = sorted(list(set(dts)))

        dt_effects = {}
        for dt in unique_dts:
            effects = [perf for combo, perf in zip(param_combinations, performance_values)
                      if combo[2] == dt]
            dt_effects[dt] = effects

        axes[1, 0].boxplot([dt_effects[dt] for dt in unique_dts],
                          labels=[f'{dt:.2f}' for dt in unique_dts])
        axes[1, 0].set_title('时间步长对性能的影响')
        axes[1, 0].set_xlabel('时间步长 (s)')
        axes[1, 0].set_ylabel('RMSE')
        axes[1, 0].grid(True, alpha=0.3)

        # 参数交互效应（热力图）
        # 固定dt，看process_noise和obs_noise的交互
        fixed_dt = unique_dts[len(unique_dts)//2]  # 选择中间值

        # 创建热力图数据
        process_obs_combinations = [(combo[0], combo[1]) for combo in param_combinations
                                   if combo[2] == fixed_dt]
        process_obs_performances = [perf for combo, perf in zip(param_combinations, performance_values)
                                   if combo[2] == fixed_dt]

        # 构建矩阵
        unique_process_for_heatmap = sorted(list(set([combo[0] for combo in process_obs_combinations])))
        unique_obs_for_heatmap = sorted(list(set([combo[1] for combo in process_obs_combinations])))

        performance_matrix = np.zeros((len(unique_process_for_heatmap), len(unique_obs_for_heatmap)))

        for i, pn in enumerate(unique_process_for_heatmap):
            for j, on in enumerate(unique_obs_for_heatmap):
                # 找到对应的性能值
                for combo, perf in zip(process_obs_combinations, process_obs_performances):
                    if combo[0] == pn and combo[1] == on:
                        performance_matrix[i, j] = perf
                        break

        im = axes[1, 1].imshow(performance_matrix, cmap='viridis', aspect='auto')
        axes[1, 1].set_title(f'参数交互效应 (dt={fixed_dt:.2f})')
        axes[1, 1].set_xlabel('观测噪声标准差')
        axes[1, 1].set_ylabel('过程噪声标准差')

        # 设置刻度标签
        axes[1, 1].set_xticks(range(len(unique_obs_for_heatmap)))
        axes[1, 1].set_xticklabels([f'{on:.1f}' for on in unique_obs_for_heatmap])
        axes[1, 1].set_yticks(range(len(unique_process_for_heatmap)))
        axes[1, 1].set_yticklabels([f'{pn:.2f}' for pn in unique_process_for_heatmap])

        # 添加颜色条
        plt.colorbar(im, ax=axes[1, 1], label='RMSE')

        plt.tight_layout()
        plt.show()

    def find_optimal_parameters(self, results=None):
        """找到最优参数组合"""
        if results is None:
            results = self.results_cache

        if not results:
            print("没有可用的分析结果")
            return None

        # 找到最小RMSE对应的参数
        best_combo = min(results.keys(), key=lambda x: results[x]['mean_rmse'])
        best_performance = results[best_combo]

        print("=== 最优参数组合 ===")
        print(f"过程噪声: {best_combo[0]:.3f}")
        print(f"观测噪声: {best_combo[1]:.3f}")
        print(f"时间步长: {best_combo[2]:.3f}")
        print(f"平均RMSE: {best_performance['mean_rmse']:.4f}")
        print(f"RMSE标准差: {best_performance['std_rmse']:.4f}")

        return best_combo, best_performance

# 运行敏感性分析
def demo_sensitivity_analysis():
    """演示参数敏感性分析"""
    analyzer = ParameterSensitivityAnalyzer()

    # 定义参数范围
    param_ranges = {
        'process_noise': [0.01, 0.05, 0.1, 0.2, 0.5],
        'obs_noise': [0.1, 0.3, 0.5, 1.0, 1.5],
        'dt': [0.05, 0.1, 0.15]
    }

    # 运行分析
    results = analyzer.analyze_parameter_space(param_ranges, n_trials=5)

    # 可视化结果
    analyzer.visualize_sensitivity_results()

    # 找到最优参数
    optimal_params, optimal_performance = analyzer.find_optimal_parameters()

    return analyzer, results

# demo_sensitivity_analysis()
```

## 2. 多传感器融合仿真环境

### 2.1 传感器仿真器

```python
class SensorSimulator:
    """多传感器仿真器"""

    def __init__(self, config=None):
        self.config = config or self.default_config()
        self.time = 0
        self.dt = 0.1

        # 传感器状态
        self.sensors = {
            'imu': IMUSensor(self.config['imu']),
            'gps': GPSSensor(self.config['gps']),
            'odometry': OdometrySensor(self.config['odometry']),
            'magnetometer': MagnetometerSensor(self.config['magnetometer']),
            'lidar': LidarSensor(self.config['lidar'])
        }

        # 环境设置
        self.environment = Environment(self.config['environment'])

    def default_config(self):
        """默认配置"""
        return {
            'imu': {
                'gyro_noise_std': 0.01,
                'accel_noise_std': 0.1,
                'gyro_bias_stability': 0.001,
                'accel_bias_stability': 0.01,
                'sampling_rate': 100  # Hz
            },
            'gps': {
                'position_noise_std': 2.0,
                'availability_probability': 0.95,
                'sampling_rate': 1  # Hz
            },
            'odometry': {
                'distance_noise_std': 0.05,
                'angle_noise_std': 0.02,
                'sampling_rate': 10  # Hz
            },
            'magnetometer': {
                'heading_noise_std': 0.05,
                'declination': 0.2,  # 磁偏角
                'sampling_rate': 10  # Hz
            },
            'lidar': {
                'range_noise_std': 0.1,
                'angular_resolution': 1.0,  # 度
                'max_range': 30.0,
                'sampling_rate': 10  # Hz
            },
            'environment': {
                'magnetic_field': [21000, 0, 45000],  # nT
                'gravity': [0, 0, -9.81],
                'landmarks': [[10, 10], [10, -10], [-10, 10], [-10, -10]]
            }
        }

    def step(self, true_state, dt=None):
        """仿真一步"""
        if dt is None:
            dt = self.dt

        self.time += dt

        # 收集所有传感器数据
        sensor_data = {}

        for sensor_name, sensor in self.sensors.items():
            if sensor.should_sample(self.time):
                data = sensor.measure(true_state, self.environment, self.time)
                sensor_data[sensor_name] = data

        return sensor_data

class IMUSensor:
    """IMU传感器仿真"""

    def __init__(self, config):
        self.config = config
        self.last_sample_time = 0

        # 偏差状态（随机游走）
        self.gyro_bias = np.zeros(3)
        self.accel_bias = np.zeros(3)

    def should_sample(self, current_time):
        """检查是否应该采样"""
        sampling_period = 1.0 / self.config['sampling_rate']
        return current_time - self.last_sample_time >= sampling_period

    def measure(self, true_state, environment, current_time):
        """测量IMU数据"""
        if not self.should_sample(current_time):
            return None

        self.last_sample_time = current_time

        # 提取真实状态
        position = true_state['position']
        velocity = true_state['velocity']
        acceleration = true_state['acceleration']
        angular_velocity = true_state['angular_velocity']
        orientation = true_state['orientation']

        # 更新偏差（随机游走）
        dt = 1.0 / self.config['sampling_rate']
        self.gyro_bias += np.random.normal(0, self.config['gyro_bias_stability'], 3) * np.sqrt(dt)
        self.accel_bias += np.random.normal(0, self.config['accel_bias_stability'], 3) * np.sqrt(dt)

        # 计算机体坐标系下的测量值
        # 简化：假设orientation是欧拉角[roll, pitch, yaw]
        R_body_to_nav = self.euler_to_dcm(orientation)

        # 陀螺仪测量（机体坐标系角速度）
        gyro_true = angular_velocity  # 假设已经是机体坐标系
        gyro_measured = (gyro_true + self.gyro_bias +
                        np.random.normal(0, self.config['gyro_noise_std'], 3))

        # 加速度计测量
        gravity_nav = environment.gravity
        gravity_body = R_body_to_nav.T @ gravity_nav

        accel_nav = acceleration - gravity_nav  # 去除重力的加速度
        accel_body = R_body_to_nav.T @ accel_nav + gravity_body

        accel_measured = (accel_body + self.accel_bias +
                         np.random.normal(0, self.config['accel_noise_std'], 3))

        return {
            'gyroscope': gyro_measured,
            'accelerometer': accel_measured,
            'timestamp': current_time,
            'sampling_rate': self.config['sampling_rate']
        }

    def euler_to_dcm(self, euler_angles):
        """欧拉角到方向余弦矩阵"""
        roll, pitch, yaw = euler_angles

        cos_r, sin_r = np.cos(roll), np.sin(roll)
        cos_p, sin_p = np.cos(pitch), np.sin(pitch)
        cos_y, sin_y = np.cos(yaw), np.sin(yaw)

        dcm = np.array([
            [cos_p*cos_y, -cos_p*sin_y, sin_p],
            [sin_r*sin_p*cos_y + cos_r*sin_y, -sin_r*sin_p*sin_y + cos_r*cos_y, -sin_r*cos_p],
            [-cos_r*sin_p*cos_y + sin_r*sin_y, cos_r*sin_p*sin_y + sin_r*cos_y, cos_r*cos_p]
        ])

        return dcm

class GPSSensor:
    """GPS传感器仿真"""

    def __init__(self, config):
        self.config = config
        self.last_sample_time = 0

    def should_sample(self, current_time):
        sampling_period = 1.0 / self.config['sampling_rate']
        return current_time - self.last_sample_time >= sampling_period

    def measure(self, true_state, environment, current_time):
        if not self.should_sample(current_time):
            return None

        # 检查GPS可用性
        if np.random.random() > self.config['availability_probability']:
            return None

        self.last_sample_time = current_time

        true_position = true_state['position']

        # 添加GPS噪声
        noise = np.random.normal(0, self.config['position_noise_std'], 2)
        measured_position = true_position[:2] + noise

        # 简化的精度估计
        estimated_accuracy = self.config['position_noise_std'] * (0.5 + np.random.random())

        return {
            'position': measured_position,
            'accuracy': estimated_accuracy,
            'timestamp': current_time,
            'available': True
        }

class Environment:
    """环境模型"""

    def __init__(self, config):
        self.gravity = np.array(config['gravity'])
        self.magnetic_field = np.array(config['magnetic_field'])
        self.landmarks = np.array(config['landmarks'])

class LidarSensor:
    """激光雷达传感器仿真"""

    def __init__(self, config):
        self.config = config
        self.last_sample_time = 0

    def should_sample(self, current_time):
        sampling_period = 1.0 / self.config['sampling_rate']
        return current_time - self.last_sample_time >= sampling_period

    def measure(self, true_state, environment, current_time):
        if not self.should_sample(current_time):
            return None

        self.last_sample_time = current_time

        position = true_state['position'][:2]
        orientation = true_state['orientation'][2]  # yaw angle

        # 激光扫描角度
        angular_resolution = np.radians(self.config['angular_resolution'])
        angles = np.arange(0, 2*np.pi, angular_resolution)

        ranges = []
        for angle in angles:
            # 计算世界坐标系下的射线方向
            world_angle = orientation + angle
            ray_direction = np.array([np.cos(world_angle), np.sin(world_angle)])

            # 检测与地标的距离
            min_range = self.config['max_range']

            for landmark in environment.landmarks:
                # 计算射线与地标的距离
                to_landmark = landmark - position
                projection = np.dot(to_landmark, ray_direction)

                if projection > 0:  # 地标在射线前方
                    # 简化：假设地标是点，计算最近距离
                    perpendicular_distance = np.linalg.norm(
                        to_landmark - projection * ray_direction)

                    if perpendicular_distance < 0.5:  # 地标半径
                        range_to_landmark = projection
                        if range_to_landmark < min_range:
                            min_range = range_to_landmark

            # 添加噪声
            if min_range < self.config['max_range']:
                measured_range = min_range + np.random.normal(0, self.config['range_noise_std'])
                measured_range = max(0, measured_range)  # 确保非负
            else:
                measured_range = self.config['max_range']

            ranges.append(measured_range)

        return {
            'ranges': np.array(ranges),
            'angles': angles,
            'timestamp': current_time,
            'max_range': self.config['max_range']
        }

# 仿真环境使用示例
def demo_sensor_simulation():
    """演示传感器仿真"""

    # 创建仿真器
    simulator = SensorSimulator()

    # 定义机器人轨迹
    def generate_robot_trajectory(duration=30, dt=0.1):
        """生成机器人轨迹"""
        time_steps = np.arange(0, duration, dt)
        trajectory = []

        for t in time_steps:
            # 圆形轨迹
            radius = 5
            angular_freq = 0.2

            x = radius * np.cos(angular_freq * t)
            y = radius * np.sin(angular_freq * t)
            yaw = angular_freq * t + np.pi/2

            vx = -radius * angular_freq * np.sin(angular_freq * t)
            vy = radius * angular_freq * np.cos(angular_freq * t)

            ax = -radius * angular_freq**2 * np.cos(angular_freq * t)
            ay = -radius * angular_freq**2 * np.sin(angular_freq * t)

            state = {
                'position': np.array([x, y, 0]),
                'velocity': np.array([vx, vy, 0]),
                'acceleration': np.array([ax, ay, 0]),
                'orientation': np.array([0, 0, yaw]),
                'angular_velocity': np.array([0, 0, angular_freq])
            }

            trajectory.append(state)

        return trajectory

    # 生成轨迹
    print("生成机器人轨迹...")
    trajectory = generate_robot_trajectory(duration=20, dt=0.1)

    # 运行仿真
    print("运行传感器仿真...")
    all_sensor_data = []

    for i, true_state in enumerate(trajectory):
        sensor_data = simulator.step(true_state, dt=0.1)
        all_sensor_data.append({
            'time': i * 0.1,
            'true_state': true_state,
            'sensors': sensor_data
        })

        if i % 50 == 0:
            print(f"进度: {i*0.1:.1f}s")

    # 分析和可视化
    visualize_sensor_simulation(all_sensor_data)

    return all_sensor_data, simulator

def visualize_sensor_simulation(sensor_data):
    """可视化传感器仿真结果"""

    fig, axes = plt.subplots(3, 2, figsize=(15, 12))

    # 提取数据
    times = [data['time'] for data in sensor_data]
    true_positions = [data['true_state']['position'][:2] for data in sensor_data]
    true_orientations = [data['true_state']['orientation'][2] for data in sensor_data]

    # GPS数据
    gps_times = []
    gps_positions = []
    for data in sensor_data:
        if 'gps' in data['sensors'] and data['sensors']['gps'] is not None:
            gps_times.append(data['time'])
            gps_positions.append(data['sensors']['gps']['position'])

    # IMU数据
    imu_times = []
    gyro_data = []
    accel_data = []
    for data in sensor_data:
        if 'imu' in data['sensors'] and data['sensors']['imu'] is not None:
            imu_times.append(data['time'])
            gyro_data.append(data['sensors']['imu']['gyroscope'][2])  # yaw rate
            accel_data.append(data['sensors']['imu']['accelerometer'])

    # 绘制轨迹
    true_positions = np.array(true_positions)
    axes[0, 0].plot(true_positions[:, 0], true_positions[:, 1], 'g-',
                    linewidth=2, label='真实轨迹')

    if gps_positions:
        gps_positions = np.array(gps_positions)
        axes[0, 0].scatter(gps_positions[:, 0], gps_positions[:, 1],
                          color='red', s=20, alpha=0.6, label='GPS观测')

    axes[0, 0].set_aspect('equal')
    axes[0, 0].legend()
    axes[0, 0].grid(True, alpha=0.3)
    axes[0, 0].set_title('机器人轨迹')
    axes[0, 0].set_xlabel('X (m)')
    axes[0, 0].set_ylabel('Y (m)')

    # GPS可用性
    gps_availability = []
    for t in times:
        available = any(abs(gt - t) < 0.05 for gt in gps_times)
        gps_availability.append(1 if available else 0)

    axes[0, 1].plot(times, gps_availability, 'b-', linewidth=2)
    axes[0, 1].set_title('GPS可用性')
    axes[0, 1].set_xlabel('时间 (s)')
    axes[0, 1].set_ylabel('可用 (1) / 不可用 (0)')
    axes[0, 1].grid(True, alpha=0.3)

    # 朝向对比
    axes[1, 0].plot(times, np.degrees(true_orientations), 'g-',
                    linewidth=2, label='真实朝向')
    axes[1, 0].legend()
    axes[1, 0].grid(True, alpha=0.3)
    axes[1, 0].set_title('朝向')
    axes[1, 0].set_xlabel('时间 (s)')
    axes[1, 0].set_ylabel('朝向 (度)')

    # 陀螺仪数据
    if gyro_data:
        axes[1, 1].plot(imu_times, gyro_data, 'purple', linewidth=2, alpha=0.7)
        axes[1, 1].grid(True, alpha=0.3)
        axes[1, 1].set_title('陀螺仪测量 (Yaw Rate)')
        axes[1, 1].set_xlabel('时间 (s)')
        axes[1, 1].set_ylabel('角速度 (rad/s)')

    # 加速度计数据
    if accel_data:
        accel_data = np.array(accel_data)
        axes[2, 0].plot(imu_times, accel_data[:, 0], 'r-', label='ax', alpha=0.7)
        axes[2, 0].plot(imu_times, accel_data[:, 1], 'g-', label='ay', alpha=0.7)
        axes[2, 0].plot(imu_times, accel_data[:, 2], 'b-', label='az', alpha=0.7)
        axes[2, 0].legend()
        axes[2, 0].grid(True, alpha=0.3)
        axes[2, 0].set_title('加速度计测量')
        axes[2, 0].set_xlabel('时间 (s)')
        axes[2, 0].set_ylabel('加速度 (m/s²)')

    # 激光雷达数据示例
    lidar_sample = None
    for data in sensor_data[::10]:  # 每10个数据点检查一次
        if 'lidar' in data['sensors'] and data['sensors']['lidar'] is not None:
            lidar_sample = data['sensors']['lidar']
            break

    if lidar_sample is not None:
        angles = lidar_sample['angles']
        ranges = lidar_sample['ranges']

        # 极坐标图
        ax_polar = plt.subplot(3, 2, 6, projection='polar')
        ax_polar.plot(angles, ranges, 'bo-', markersize=2, linewidth=1)
        ax_polar.set_title('激光雷达扫描示例')
        ax_polar.set_ylim(0, 30)

    plt.tight_layout()
    plt.show()

# 运行仿真演示
# simulation_data, sim = demo_sensor_simulation()
```

这个可视化工具和仿真环境为学生提供了：

1. **交互式学习体验**：通过滑块实时调整参数，观察滤波效果变化
2. **参数敏感性分析**：系统地分析不同参数对性能的影响
3. **多传感器仿真**：模拟真实的传感器特性和噪声
4. **可视化分析**：丰富的图表帮助理解算法原理和性能

这些工具大大增强了课程的实践性和直观性。