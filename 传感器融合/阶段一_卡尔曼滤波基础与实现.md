# 阶段一：卡尔曼滤波基础与实现

## 第1讲：概率论与状态估计基础

### 1.1 贝叶斯推理与状态估计

#### 1.1.1 状态估计问题的定义

状态估计是机器人学中的核心问题：给定一系列不完美的观测数据，如何最优地估计系统的真实状态？

**数学表述**：
- **状态向量** $\mathbf{x}_t$：描述系统在时刻 $t$ 的状态
- **观测向量** $\mathbf{z}_t$：时刻 $t$ 的传感器测量值
- **控制输入** $\mathbf{u}_t$：施加给系统的控制命令

**目标**：根据观测序列 $\mathbf{z}_{1:t} = \{\mathbf{z}_1, \mathbf{z}_2, ..., \mathbf{z}_t\}$ 和控制序列 $\mathbf{u}_{1:t}$，估计状态 $\mathbf{x}_t$。

#### 1.1.2 贝叶斯滤波框架

贝叶斯滤波提供了状态估计的理论框架：

**预测步骤**（运动更新）：
$$p(\mathbf{x}_t | \mathbf{z}_{1:t-1}, \mathbf{u}_{1:t}) = \int p(\mathbf{x}_t | \mathbf{x}_{t-1}, \mathbf{u}_t) p(\mathbf{x}_{t-1} | \mathbf{z}_{1:t-1}, \mathbf{u}_{1:t-1}) d\mathbf{x}_{t-1}$$

**更新步骤**（观测更新）：
$$p(\mathbf{x}_t | \mathbf{z}_{1:t}, \mathbf{u}_{1:t}) = \frac{p(\mathbf{z}_t | \mathbf{x}_t) p(\mathbf{x}_t | \mathbf{z}_{1:t-1}, \mathbf{u}_{1:t})}{p(\mathbf{z}_t | \mathbf{z}_{1:t-1}, \mathbf{u}_{1:t})}$$

#### 1.1.3 马尔可夫假设

为了简化计算，我们通常假设：

1. **状态马尔可夫性**：$p(\mathbf{x}_t | \mathbf{x}_{1:t-1}, \mathbf{u}_{1:t}) = p(\mathbf{x}_t | \mathbf{x}_{t-1}, \mathbf{u}_t)$
2. **观测马尔可夫性**：$p(\mathbf{z}_t | \mathbf{x}_{1:t}, \mathbf{z}_{1:t-1}) = p(\mathbf{z}_t | \mathbf{x}_t)$

### 1.2 高斯分布与协方差矩阵

#### 1.2.1 多元高斯分布

卡尔曼滤波假设所有概率分布都是高斯分布。多元高斯分布的概率密度函数为：

$$p(\mathbf{x}) = \frac{1}{(2\pi)^{n/2}|\boldsymbol{\Sigma}|^{1/2}} \exp\left(-\frac{1}{2}(\mathbf{x} - \boldsymbol{\mu})^T \boldsymbol{\Sigma}^{-1} (\mathbf{x} - \boldsymbol{\mu})\right)$$

其中：
- $\boldsymbol{\mu}$：均值向量
- $\boldsymbol{\Sigma}$：协方差矩阵
- $n$：状态维度

#### 1.2.2 协方差矩阵的意义

协方差矩阵 $\boldsymbol{\Sigma}$ 描述了状态不确定性：

```python
import numpy as np
import matplotlib.pyplot as plt
from matplotlib.patches import Ellipse
from scipy.stats import multivariate_normal

def plot_gaussian_ellipse(mean, cov, ax, color='blue', alpha=0.3, n_std=2):
    """
    绘制高斯分布的置信椭圆

    Args:
        mean: 均值向量 [x, y]
        cov: 协方差矩阵 2x2
        ax: matplotlib轴对象
        color: 椭圆颜色
        alpha: 透明度
        n_std: 标准差倍数（决定置信度）
    """
    # 计算特征值和特征向量
    eigenvals, eigenvecs = np.linalg.eigh(cov)

    # 计算椭圆参数
    angle = np.degrees(np.arctan2(eigenvecs[1, 0], eigenvecs[0, 0]))
    width = 2 * n_std * np.sqrt(eigenvals[0])
    height = 2 * n_std * np.sqrt(eigenvals[1])

    # 创建椭圆
    ellipse = Ellipse(mean, width, height, angle=angle,
                     facecolor=color, alpha=alpha, edgecolor=color)
    ax.add_patch(ellipse)

    return ellipse

# 演示不同协方差矩阵的效果
fig, axes = plt.subplots(2, 2, figsize=(12, 10))
mean = [0, 0]

# 不同的协方差矩阵
covariances = [
    [[1, 0], [0, 1]],        # 圆形（无相关性）
    [[2, 0], [0, 0.5]],      # 椭圆（无相关性）
    [[1, 0.8], [0.8, 1]],    # 正相关
    [[1, -0.8], [-0.8, 1]]   # 负相关
]

titles = ['无相关性 (圆形)', '无相关性 (椭圆)', '正相关', '负相关']

for i, (cov, title) in enumerate(zip(covariances, titles)):
    ax = axes[i//2, i%2]

    # 绘制置信椭圆
    plot_gaussian_ellipse(mean, cov, ax, color='blue', alpha=0.3, n_std=1)
    plot_gaussian_ellipse(mean, cov, ax, color='red', alpha=0.2, n_std=2)

    # 采样点
    samples = np.random.multivariate_normal(mean, cov, 100)
    ax.scatter(samples[:, 0], samples[:, 1], alpha=0.6, s=10)

    ax.set_xlim(-4, 4)
    ax.set_ylim(-4, 4)
    ax.set_aspect('equal')
    ax.grid(True, alpha=0.3)
    ax.set_title(title)
    ax.legend(['1σ', '2σ', '样本点'])

plt.tight_layout()
plt.show()

def demonstrate_covariance_properties():
    """演示协方差矩阵的性质"""
    print("=== 协方差矩阵性质演示 ===")

    # 示例协方差矩阵
    cov = np.array([[2.0, 0.8],
                    [0.8, 1.0]])

    print(f"协方差矩阵:\n{cov}")

    # 对称性
    print(f"\n对称性检验: {np.allclose(cov, cov.T)}")

    # 正定性
    eigenvals = np.linalg.eigvals(cov)
    print(f"特征值: {eigenvals}")
    print(f"正定性: {np.all(eigenvals > 0)}")

    # 行列式（体积）
    det = np.linalg.det(cov)
    print(f"行列式（不确定性体积）: {det:.3f}")

    # 迹（总方差）
    trace = np.trace(cov)
    print(f"迹（总方差）: {trace:.3f}")

    # 条件数（数值稳定性指标）
    cond = np.linalg.cond(cov)
    print(f"条件数: {cond:.3f}")

demonstrate_covariance_properties()
```

### 1.3 线性系统理论基础

#### 1.3.1 线性动态系统

卡尔曼滤波处理的标准线性系统形式：

**状态转移方程**：
$$\mathbf{x}_t = \mathbf{F}_t \mathbf{x}_{t-1} + \mathbf{B}_t \mathbf{u}_t + \mathbf{w}_t$$

**观测方程**：
$$\mathbf{z}_t = \mathbf{H}_t \mathbf{x}_t + \mathbf{v}_t$$

其中：
- $\mathbf{F}_t$：状态转移矩阵
- $\mathbf{B}_t$：控制输入矩阵
- $\mathbf{H}_t$：观测矩阵
- $\mathbf{w}_t \sim \mathcal{N}(0, \mathbf{Q}_t)$：过程噪声
- $\mathbf{v}_t \sim \mathcal{N}(0, \mathbf{R}_t)$：观测噪声

#### 1.3.2 一维运动模型示例

考虑一个沿直线运动的物体，状态为位置和速度：

```python
class ConstantVelocityModel:
    """常速度运动模型"""

    def __init__(self, dt=0.1, process_noise_std=0.1):
        """
        初始化常速度模型

        Args:
            dt: 时间步长
            process_noise_std: 过程噪声标准差
        """
        self.dt = dt

        # 状态转移矩阵 [位置, 速度]
        self.F = np.array([[1, dt],
                          [0, 1]])

        # 过程噪声协方差矩阵
        # 使用连续时间白噪声离散化
        q = process_noise_std ** 2
        self.Q = q * np.array([[dt**3/3, dt**2/2],
                              [dt**2/2, dt]])

        # 观测矩阵（只观测位置）
        self.H = np.array([[1, 0]])

    def predict_state(self, state, control=None):
        """状态预测"""
        if control is None:
            return self.F @ state
        else:
            # 如果有控制输入（如加速度）
            B = np.array([[0.5 * self.dt**2], [self.dt]])
            return self.F @ state + B @ control

    def predict_covariance(self, P):
        """协方差预测"""
        return self.F @ P @ self.F.T + self.Q

    def observation_model(self, state):
        """观测模型"""
        return self.H @ state

# 演示运动模型
def demonstrate_motion_model():
    """演示常速度运动模型"""
    dt = 0.1
    model = ConstantVelocityModel(dt=dt, process_noise_std=0.1)

    # 初始状态：位置=0, 速度=1
    x = np.array([0.0, 1.0])
    P = np.eye(2) * 0.1  # 初始不确定性

    print("=== 常速度模型演示 ===")
    print(f"时间步长: {dt}")
    print(f"状态转移矩阵 F:\n{model.F}")
    print(f"过程噪声协方差 Q:\n{model.Q}")
    print(f"观测矩阵 H:\n{model.H}")

    # 模拟几步预测
    states = [x.copy()]
    covariances = [P.copy()]

    for step in range(5):
        x = model.predict_state(x)
        P = model.predict_covariance(P)

        states.append(x.copy())
        covariances.append(P.copy())

        print(f"\n步骤 {step+1}:")
        print(f"  预测状态: 位置={x[0]:.2f}, 速度={x[1]:.2f}")
        print(f"  不确定性: σ_pos={np.sqrt(P[0,0]):.3f}, σ_vel={np.sqrt(P[1,1]):.3f}")

    return states, covariances

states, covariances = demonstrate_motion_model()
```

### 1.4 噪声模型与统计特性

#### 1.4.1 过程噪声建模

过程噪声反映了模型的不完美性：

```python
class NoiseModelAnalysis:
    """噪声模型分析工具"""

    @staticmethod
    def generate_process_noise_samples(Q, n_samples=1000):
        """生成过程噪声样本"""
        return np.random.multivariate_normal([0, 0], Q, n_samples)

    @staticmethod
    def analyze_noise_statistics(samples):
        """分析噪声统计特性"""
        mean = np.mean(samples, axis=0)
        cov = np.cov(samples.T)

        print("噪声统计分析:")
        print(f"  样本均值: {mean}")
        print(f"  理论均值: [0, 0]")
        print(f"  样本协方差:\n{cov}")

        # 正态性检验
        from scipy import stats
        for i in range(samples.shape[1]):
            stat, p_value = stats.normaltest(samples[:, i])
            print(f"  维度 {i} 正态性检验 p-value: {p_value:.4f}")

        return mean, cov

    @staticmethod
    def plot_noise_characteristics(samples, Q):
        """可视化噪声特性"""
        fig, axes = plt.subplots(2, 2, figsize=(12, 10))

        # 2D散点图
        axes[0, 0].scatter(samples[:, 0], samples[:, 1], alpha=0.6, s=10)
        axes[0, 0].set_xlabel('位置噪声')
        axes[0, 0].set_ylabel('速度噪声')
        axes[0, 0].set_title('过程噪声分布')
        axes[0, 0].grid(True, alpha=0.3)

        # 添加理论椭圆
        plot_gaussian_ellipse([0, 0], Q, axes[0, 0], color='red', alpha=0.2)

        # 位置噪声直方图
        axes[0, 1].hist(samples[:, 0], bins=50, alpha=0.7, density=True)
        axes[0, 1].set_xlabel('位置噪声')
        axes[0, 1].set_ylabel('概率密度')
        axes[0, 1].set_title('位置噪声分布')
        axes[0, 1].grid(True, alpha=0.3)

        # 添加理论曲线
        x_range = np.linspace(samples[:, 0].min(), samples[:, 0].max(), 100)
        theoretical_pdf = stats.norm.pdf(x_range, 0, np.sqrt(Q[0, 0]))
        axes[0, 1].plot(x_range, theoretical_pdf, 'r-', linewidth=2, label='理论')
        axes[0, 1].legend()

        # 速度噪声直方图
        axes[1, 0].hist(samples[:, 1], bins=50, alpha=0.7, density=True)
        axes[1, 0].set_xlabel('速度噪声')
        axes[1, 0].set_ylabel('概率密度')
        axes[1, 0].set_title('速度噪声分布')
        axes[1, 0].grid(True, alpha=0.3)

        # 添加理论曲线
        y_range = np.linspace(samples[:, 1].min(), samples[:, 1].max(), 100)
        theoretical_pdf = stats.norm.pdf(y_range, 0, np.sqrt(Q[1, 1]))
        axes[1, 0].plot(y_range, theoretical_pdf, 'r-', linewidth=2, label='理论')
        axes[1, 0].legend()

        # 相关性分析
        correlation = np.corrcoef(samples.T)[0, 1]
        axes[1, 1].scatter(samples[:, 0], samples[:, 1], alpha=0.6, s=10)
        axes[1, 1].set_xlabel('位置噪声')
        axes[1, 1].set_ylabel('速度噪声')
        axes[1, 1].set_title(f'噪声相关性 (r={correlation:.3f})')
        axes[1, 1].grid(True, alpha=0.3)

        plt.tight_layout()
        plt.show()

# 演示噪声分析
model = ConstantVelocityModel(dt=0.1, process_noise_std=0.1)
noise_analyzer = NoiseModelAnalysis()

# 生成噪声样本
noise_samples = noise_analyzer.generate_process_noise_samples(model.Q, 2000)

# 分析噪声统计特性
mean, cov = noise_analyzer.analyze_noise_statistics(noise_samples)

# 可视化噪声特性
noise_analyzer.plot_noise_characteristics(noise_samples, model.Q)
```

## 第2讲：卡尔曼滤波理论

### 2.1 卡尔曼滤波的数学推导

#### 2.1.1 最优估计理论

卡尔曼滤波器通过最小化均方误差来寻找最优估计：

$$\hat{\mathbf{x}}_t = \arg\min_{\mathbf{x}} E[(\mathbf{x}_t - \mathbf{x})^T(\mathbf{x}_t - \mathbf{x}) | \mathbf{z}_{1:t}]$$

#### 2.1.2 递推估计推导

**预测步骤**：

先验估计：
$$\hat{\mathbf{x}}_{t|t-1} = \mathbf{F}_t \hat{\mathbf{x}}_{t-1|t-1} + \mathbf{B}_t \mathbf{u}_t$$

先验协方差：
$$\mathbf{P}_{t|t-1} = \mathbf{F}_t \mathbf{P}_{t-1|t-1} \mathbf{F}_t^T + \mathbf{Q}_t$$

**更新步骤**：

卡尔曼增益：
$$\mathbf{K}_t = \mathbf{P}_{t|t-1} \mathbf{H}_t^T (\mathbf{H}_t \mathbf{P}_{t|t-1} \mathbf{H}_t^T + \mathbf{R}_t)^{-1}$$

后验估计：
$$\hat{\mathbf{x}}_{t|t} = \hat{\mathbf{x}}_{t|t-1} + \mathbf{K}_t (\mathbf{z}_t - \mathbf{H}_t \hat{\mathbf{x}}_{t|t-1})$$

后验协方差：
$$\mathbf{P}_{t|t} = (\mathbf{I} - \mathbf{K}_t \mathbf{H}_t) \mathbf{P}_{t|t-1}$$

#### 2.1.3 卡尔曼增益的直观理解

卡尔曼增益 $\mathbf{K}_t$ 决定了预测和观测的权重分配：

```python
def analyze_kalman_gain():
    """分析卡尔曼增益的特性"""

    # 创建不同的噪声场景
    scenarios = [
        {"name": "高观测噪声", "R": 10.0, "P": 1.0},
        {"name": "低观测噪声", "R": 0.1, "P": 1.0},
        {"name": "高预测不确定性", "R": 1.0, "P": 10.0},
        {"name": "低预测不确定性", "R": 1.0, "P": 0.1},
    ]

    H = 1.0  # 观测矩阵（标量情况）

    print("=== 卡尔曼增益分析 ===")
    print("场景\t\t\t观测噪声R\t预测不确定性P\t卡尔曼增益K\t说明")
    print("-" * 80)

    for scenario in scenarios:
        R = scenario["R"]
        P = scenario["P"]

        # 计算卡尔曼增益
        K = P * H / (H * P * H + R)

        # 解释增益大小
        if K > 0.7:
            explanation = "更信任观测"
        elif K < 0.3:
            explanation = "更信任预测"
        else:
            explanation = "平衡信任"

        print(f"{scenario['name']:<15}\t{R:<10.1f}\t{P:<15.1f}\t{K:<10.3f}\t{explanation}")

analyze_kalman_gain()
```

### 2.2 算法实现

#### 2.2.1 标准卡尔曼滤波器实现

```python
class KalmanFilter:
    """标准卡尔曼滤波器"""

    def __init__(self, F, B, H, Q, R, x0, P0):
        """
        初始化卡尔曼滤波器

        Args:
            F: 状态转移矩阵
            B: 控制输入矩阵
            H: 观测矩阵
            Q: 过程噪声协方差
            R: 观测噪声协方差
            x0: 初始状态估计
            P0: 初始状态协方差
        """
        self.F = np.array(F)
        self.B = np.array(B) if B is not None else None
        self.H = np.array(H)
        self.Q = np.array(Q)
        self.R = np.array(R)

        # 状态估计
        self.x = np.array(x0)
        self.P = np.array(P0)

        # 历史记录
        self.history = {
            'x': [self.x.copy()],
            'P': [self.P.copy()],
            'K': [],
            'innovation': [],
            'likelihood': []
        }

    def predict(self, u=None):
        """预测步骤"""
        # 状态预测
        if u is not None and self.B is not None:
            self.x = self.F @ self.x + self.B @ u
        else:
            self.x = self.F @ self.x

        # 协方差预测
        self.P = self.F @ self.P @ self.F.T + self.Q

        return self.x.copy(), self.P.copy()

    def update(self, z):
        """更新步骤"""
        # 创新（残差）
        innovation = z - self.H @ self.x

        # 创新协方差
        S = self.H @ self.P @ self.H.T + self.R

        # 卡尔曼增益
        K = self.P @ self.H.T @ np.linalg.inv(S)

        # 状态更新
        self.x = self.x + K @ innovation

        # 协方差更新（Joseph形式，数值稳定）
        I_KH = np.eye(len(self.x)) - K @ self.H
        self.P = I_KH @ self.P @ I_KH.T + K @ self.R @ K.T

        # 计算似然
        likelihood = self._compute_likelihood(innovation, S)

        # 记录历史
        self.history['x'].append(self.x.copy())
        self.history['P'].append(self.P.copy())
        self.history['K'].append(K.copy())
        self.history['innovation'].append(innovation.copy())
        self.history['likelihood'].append(likelihood)

        return self.x.copy(), self.P.copy(), K.copy()

    def _compute_likelihood(self, innovation, S):
        """计算观测似然"""
        n = len(innovation)
        det_S = np.linalg.det(S)

        if det_S <= 0:
            return -np.inf

        log_likelihood = -0.5 * (n * np.log(2 * np.pi) +
                                np.log(det_S) +
                                innovation.T @ np.linalg.inv(S) @ innovation)

        return log_likelihood

    def get_state(self):
        """获取当前状态估计"""
        return self.x.copy(), self.P.copy()

    def get_history(self):
        """获取历史记录"""
        return self.history.copy()

# 可视化工具
class KalmanFilterVisualizer:
    """卡尔曼滤波可视化工具"""

    @staticmethod
    def plot_1d_tracking(true_states, observations, kf_states, kf_covariances,
                        title="1D卡尔曼滤波跟踪"):
        """绘制一维跟踪结果"""

        time_steps = range(len(true_states))
        kf_positions = [x[0] for x in kf_states]
        kf_std = [np.sqrt(P[0, 0]) for P in kf_covariances]

        plt.figure(figsize=(12, 8))

        # 真实轨迹
        plt.plot(time_steps, true_states, 'g-', linewidth=2, label='真实位置')

        # 观测值
        plt.scatter(time_steps[1:], observations, color='red', alpha=0.6,
                   s=30, label='观测值', zorder=5)

        # 卡尔曼滤波估计
        plt.plot(time_steps, kf_positions, 'b-', linewidth=2, label='卡尔曼滤波估计')

        # 不确定性区间
        kf_positions_array = np.array(kf_positions)
        kf_std_array = np.array(kf_std)

        plt.fill_between(time_steps,
                        kf_positions_array - 2 * kf_std_array,
                        kf_positions_array + 2 * kf_std_array,
                        alpha=0.2, color='blue', label='95%置信区间')

        plt.xlabel('时间步')
        plt.ylabel('位置')
        plt.title(title)
        plt.legend()
        plt.grid(True, alpha=0.3)
        plt.show()

    @staticmethod
    def plot_filter_diagnostics(kf_history):
        """绘制滤波器诊断信息"""
        fig, axes = plt.subplots(2, 2, figsize=(15, 10))

        time_steps = range(len(kf_history['innovation']))

        # 创新序列
        innovations = np.array(kf_history['innovation'])
        if innovations.ndim == 2:
            innovations = innovations[:, 0]  # 取第一维

        axes[0, 0].plot(time_steps, innovations, 'r-', alpha=0.7)
        axes[0, 0].set_title('创新序列（残差）')
        axes[0, 0].set_xlabel('时间步')
        axes[0, 0].set_ylabel('创新')
        axes[0, 0].grid(True, alpha=0.3)
        axes[0, 0].axhline(y=0, color='k', linestyle='--', alpha=0.5)

        # 卡尔曼增益
        gains = np.array([K[0, 0] if K.ndim > 1 else K[0] for K in kf_history['K']])
        axes[0, 1].plot(time_steps, gains, 'g-', linewidth=2)
        axes[0, 1].set_title('卡尔曼增益')
        axes[0, 1].set_xlabel('时间步')
        axes[0, 1].set_ylabel('增益')
        axes[0, 1].grid(True, alpha=0.3)

        # 状态不确定性
        position_std = [np.sqrt(P[0, 0]) for P in kf_history['P']]
        axes[1, 0].plot(range(len(position_std)), position_std, 'b-', linewidth=2)
        axes[1, 0].set_title('位置不确定性')
        axes[1, 0].set_xlabel('时间步')
        axes[1, 0].set_ylabel('标准差')
        axes[1, 0].grid(True, alpha=0.3)

        # 似然函数
        likelihoods = kf_history['likelihood']
        axes[1, 1].plot(time_steps, likelihoods, 'm-', alpha=0.7)
        axes[1, 1].set_title('对数似然')
        axes[1, 1].set_xlabel('时间步')
        axes[1, 1].set_ylabel('对数似然')
        axes[1, 1].grid(True, alpha=0.3)

        plt.tight_layout()
        plt.show()
```

## 第3讲：一维卡尔曼滤波实现

### 3.1 运动物体跟踪实例

#### 3.1.1 问题设定

跟踪一个沿直线运动的物体，我们只能观测到其位置，但想要估计位置和速度。

```python
class MotionTracker:
    """运动物体跟踪器"""

    def __init__(self, dt=0.1, process_noise_std=0.1, observation_noise_std=0.5):
        """
        初始化跟踪器

        Args:
            dt: 时间步长
            process_noise_std: 过程噪声标准差
            observation_noise_std: 观测噪声标准差
        """
        self.dt = dt

        # 状态转移矩阵 (常速度模型)
        F = [[1, dt],
             [0, 1]]

        # 无控制输入
        B = None

        # 观测矩阵 (只观测位置)
        H = [[1, 0]]

        # 过程噪声协方差
        q = process_noise_std ** 2
        Q = q * np.array([[dt**3/3, dt**2/2],
                         [dt**2/2, dt]])

        # 观测噪声协方差
        R = [[observation_noise_std ** 2]]

        # 初始状态和协方差
        x0 = [0, 0]  # 初始位置和速度
        P0 = [[100, 0],   # 位置不确定性大
              [0, 100]]   # 速度不确定性大

        # 创建卡尔曼滤波器
        self.kf = KalmanFilter(F, B, H, Q, R, x0, P0)

    def track_object(self, true_trajectory, observation_noise_std=None):
        """
        跟踪物体运动

        Args:
            true_trajectory: 真实轨迹 [位置列表]
            observation_noise_std: 观测噪声标准差（可覆盖初始值）

        Returns:
            observations: 观测值
            estimates: 状态估计
            covariances: 协方差矩阵
        """
        if observation_noise_std is None:
            observation_noise_std = np.sqrt(self.kf.R[0, 0])

        observations = []
        estimates = []
        covariances = []

        # 记录初始状态
        x, P = self.kf.get_state()
        estimates.append(x.copy())
        covariances.append(P.copy())

        for i, true_pos in enumerate(true_trajectory[1:], 1):
            # 预测步骤
            self.kf.predict()

            # 生成噪声观测
            observed_pos = true_pos + np.random.normal(0, observation_noise_std)
            observations.append(observed_pos)

            # 更新步骤
            self.kf.update([observed_pos])

            # 记录结果
            x, P = self.kf.get_state()
            estimates.append(x.copy())
            covariances.append(P.copy())

        return observations, estimates, covariances

def generate_true_trajectory(n_steps=50, dt=0.1):
    """生成真实轨迹"""

    # 场景1: 匀速直线运动
    def constant_velocity():
        initial_pos = 0
        velocity = 2.0
        return [initial_pos + velocity * dt * i for i in range(n_steps)]

    # 场景2: 变速运动
    def variable_velocity():
        positions = [0]
        velocity = 1.0

        for i in range(1, n_steps):
            # 速度随时间缓慢变化
            if i > 20:
                velocity += 0.05  # 加速
            elif i > 35:
                velocity -= 0.1   # 减速

            positions.append(positions[-1] + velocity * dt)

        return positions

    # 场景3: 往复运动
    def oscillatory_motion():
        amplitude = 10
        frequency = 0.1
        return [amplitude * np.sin(2 * np.pi * frequency * dt * i)
                for i in range(n_steps)]

    return {
        'constant': constant_velocity(),
        'variable': variable_velocity(),
        'oscillatory': oscillatory_motion()
    }

# 运行跟踪实验
def run_tracking_experiment():
    """运行跟踪实验"""

    # 生成不同的真实轨迹
    trajectories = generate_true_trajectory(n_steps=50, dt=0.1)

    for scenario_name, true_traj in trajectories.items():
        print(f"\n=== {scenario_name.upper()} 运动场景 ===")

        # 创建跟踪器
        tracker = MotionTracker(dt=0.1,
                              process_noise_std=0.1,
                              observation_noise_std=0.5)

        # 跟踪物体
        observations, estimates, covariances = tracker.track_object(true_traj)

        # 计算性能指标
        estimated_positions = [est[0] for est in estimates[1:]]  # 排除初始估计
        true_positions = true_traj[1:]

        position_errors = np.array(estimated_positions) - np.array(true_positions)
        rmse = np.sqrt(np.mean(position_errors**2))
        mae = np.mean(np.abs(position_errors))

        print(f"位置RMSE: {rmse:.3f}")
        print(f"位置MAE: {mae:.3f}")

        # 可视化结果
        visualizer = KalmanFilterVisualizer()
        visualizer.plot_1d_tracking(true_traj, observations, estimates, covariances,
                                   title=f"{scenario_name.capitalize()}运动跟踪")

        # 显示诊断信息
        visualizer.plot_filter_diagnostics(tracker.kf.get_history())

# 运行实验
run_tracking_experiment()
```

### 3.2 参数调优与性能分析

#### 3.2.1 噪声参数敏感性分析

```python
class ParameterSensitivityAnalysis:
    """参数敏感性分析"""

    @staticmethod
    def analyze_noise_sensitivity():
        """分析噪声参数对性能的影响"""

        # 生成标准测试轨迹
        dt = 0.1
        n_steps = 50
        true_traj = [2.0 * dt * i for i in range(n_steps)]  # 匀速运动

        # 测试不同的噪声组合
        process_noise_levels = [0.01, 0.1, 0.5, 1.0]
        observation_noise_levels = [0.1, 0.5, 1.0, 2.0]

        results = {}

        for q_std in process_noise_levels:
            for r_std in observation_noise_levels:
                # 运行多次试验以获得统计结果
                rmse_list = []

                for trial in range(20):  # 20次蒙特卡洛试验
                    tracker = MotionTracker(dt=dt,
                                          process_noise_std=q_std,
                                          observation_noise_std=r_std)

                    _, estimates, _ = tracker.track_object(true_traj, r_std)

                    # 计算RMSE
                    estimated_positions = [est[0] for est in estimates[1:]]
                    true_positions = true_traj[1:]
                    position_errors = np.array(estimated_positions) - np.array(true_positions)
                    rmse = np.sqrt(np.mean(position_errors**2))
                    rmse_list.append(rmse)

                # 记录平均RMSE
                results[(q_std, r_std)] = np.mean(rmse_list)

        return results

    @staticmethod
    def visualize_sensitivity_analysis(results):
        """可视化敏感性分析结果"""

        # 提取参数值
        q_values = sorted(list(set([k[0] for k in results.keys()])))
        r_values = sorted(list(set([k[1] for k in results.keys()])))

        # 创建结果矩阵
        rmse_matrix = np.zeros((len(q_values), len(r_values)))

        for i, q_std in enumerate(q_values):
            for j, r_std in enumerate(r_values):
                rmse_matrix[i, j] = results[(q_std, r_std)]

        # 绘制热力图
        plt.figure(figsize=(10, 8))

        im = plt.imshow(rmse_matrix, cmap='viridis', aspect='auto', origin='lower')

        plt.xlabel('观测噪声标准差')
        plt.ylabel('过程噪声标准差')
        plt.title('参数敏感性分析：位置RMSE')

        # 设置刻度标签
        plt.xticks(range(len(r_values)), [f'{r:.1f}' for r in r_values])
        plt.yticks(range(len(q_values)), [f'{q:.2f}' for q in q_values])

        # 添加颜色条
        cbar = plt.colorbar(im)
        cbar.set_label('位置RMSE')

        # 添加数值标注
        for i in range(len(q_values)):
            for j in range(len(r_values)):
                text = plt.text(j, i, f'{rmse_matrix[i, j]:.2f}',
                              ha="center", va="center", color="white")

        plt.tight_layout()
        plt.show()

        # 找出最优参数
        min_idx = np.unravel_index(np.argmin(rmse_matrix), rmse_matrix.shape)
        best_q = q_values[min_idx[0]]
        best_r = r_values[min_idx[1]]
        best_rmse = rmse_matrix[min_idx]

        print(f"最优参数组合:")
        print(f"  过程噪声标准差: {best_q}")
        print(f"  观测噪声标准差: {best_r}")
        print(f"  对应RMSE: {best_rmse:.3f}")

# 运行敏感性分析
print("开始参数敏感性分析...")
sensitivity_results = ParameterSensitivityAnalysis.analyze_noise_sensitivity()
ParameterSensitivityAnalysis.visualize_sensitivity_analysis(sensitivity_results)
```

#### 3.2.2 滤波器收敛性分析

```python
class ConvergenceAnalysis:
    """收敛性分析工具"""

    @staticmethod
    def analyze_convergence_properties():
        """分析滤波器收敛特性"""

        # 创建测试场景
        dt = 0.1
        n_steps = 100

        # 真实状态：静止物体
        true_positions = [0] * n_steps

        # 不同初始不确定性
        initial_uncertainties = [0.1, 1.0, 10.0, 100.0]

        fig, axes = plt.subplots(2, 2, figsize=(15, 10))
        colors = ['blue', 'red', 'green', 'orange']

        for i, init_var in enumerate(initial_uncertainties):
            # 创建具有不同初始不确定性的滤波器
            F = [[1, dt], [0, 1]]
            H = [[1, 0]]
            Q = 0.01 * np.array([[dt**3/3, dt**2/2], [dt**2/2, dt]])
            R = [[0.25]]
            x0 = [0, 0]
            P0 = [[init_var, 0], [0, init_var]]

            kf = KalmanFilter(F, None, H, Q, R, x0, P0)

            position_estimates = []
            position_uncertainties = []
            velocity_estimates = []
            velocity_uncertainties = []

            # 模拟观测和滤波
            for step in range(n_steps):
                if step > 0:
                    # 预测
                    kf.predict()

                    # 生成观测（真实位置 + 噪声）
                    observation = true_positions[step] + np.random.normal(0, 0.5)

                    # 更新
                    kf.update([observation])

                # 记录状态
                x, P = kf.get_state()
                position_estimates.append(x[0])
                position_uncertainties.append(np.sqrt(P[0, 0]))
                velocity_estimates.append(x[1])
                velocity_uncertainties.append(np.sqrt(P[1, 1]))

            # 绘制位置估计
            axes[0, 0].plot(position_estimates, color=colors[i],
                           label=f'初始σ²={init_var}', linewidth=2)

            # 绘制位置不确定性
            axes[0, 1].plot(position_uncertainties, color=colors[i],
                           label=f'初始σ²={init_var}', linewidth=2)

            # 绘制速度估计
            axes[1, 0].plot(velocity_estimates, color=colors[i],
                           label=f'初始σ²={init_var}', linewidth=2)

            # 绘制速度不确定性
            axes[1, 1].plot(velocity_uncertainties, color=colors[i],
                           label=f'初始σ²={init_var}', linewidth=2)

        # 设置图表属性
        axes[0, 0].set_title('位置估计收敛')
        axes[0, 0].set_ylabel('估计位置')
        axes[0, 0].axhline(y=0, color='k', linestyle='--', alpha=0.5)
        axes[0, 0].legend()
        axes[0, 0].grid(True, alpha=0.3)

        axes[0, 1].set_title('位置不确定性收敛')
        axes[0, 1].set_ylabel('位置标准差')
        axes[0, 1].set_yscale('log')
        axes[0, 1].legend()
        axes[0, 1].grid(True, alpha=0.3)

        axes[1, 0].set_title('速度估计收敛')
        axes[1, 0].set_xlabel('时间步')
        axes[1, 0].set_ylabel('估计速度')
        axes[1, 0].axhline(y=0, color='k', linestyle='--', alpha=0.5)
        axes[1, 0].legend()
        axes[1, 0].grid(True, alpha=0.3)

        axes[1, 1].set_title('速度不确定性收敛')
        axes[1, 1].set_xlabel('时间步')
        axes[1, 1].set_ylabel('速度标准差')
        axes[1, 1].set_yscale('log')
        axes[1, 1].legend()
        axes[1, 1].grid(True, alpha=0.3)

        plt.tight_layout()
        plt.show()

    @staticmethod
    def analyze_steady_state():
        """分析稳态性能"""

        # 理论稳态协方差计算
        dt = 0.1
        F = np.array([[1, dt], [0, 1]])
        H = np.array([[1, 0]])
        Q = 0.01 * np.array([[dt**3/3, dt**2/2], [dt**2/2, dt]])
        R = np.array([[0.25]])

        # 求解离散代数Riccati方程
        from scipy.linalg import solve_discrete_are

        P_steady = solve_discrete_are(F.T, H.T, Q, R)

        print("=== 稳态分析 ===")
        print(f"稳态协方差矩阵:")
        print(P_steady)
        print(f"稳态位置标准差: {np.sqrt(P_steady[0, 0]):.4f}")
        print(f"稳态速度标准差: {np.sqrt(P_steady[1, 1]):.4f}")

        # 计算稳态卡尔曼增益
        K_steady = P_steady @ H.T @ np.linalg.inv(H @ P_steady @ H.T + R)
        print(f"稳态卡尔曼增益: {K_steady.flatten()}")

        return P_steady, K_steady

# 运行收敛性分析
convergence_analyzer = ConvergenceAnalysis()
convergence_analyzer.analyze_convergence_properties()
P_steady, K_steady = convergence_analyzer.analyze_steady_state()
```

### 3.3 练习与扩展

#### 3.3.1 练习题

**练习1**：修改运动模型
```python
# 实现匀加速度运动模型
# 状态向量：[位置, 速度, 加速度]
# 提示：状态转移矩阵为3x3

def create_constant_acceleration_model(dt):
    """创建匀加速度模型"""
    # TODO: 实现3状态卡尔曼滤波器
    pass
```

**练习2**：多维跟踪
```python
# 实现2D平面内的运动跟踪
# 状态向量：[x, y, vx, vy]
# 观测：[x, y]

def create_2d_tracker():
    """创建2D跟踪器"""
    # TODO: 实现2D卡尔曼滤波器
    pass
```

**练习3**：自适应滤波
```python
# 实现自适应噪声估计
def adaptive_kalman_filter():
    """自适应卡尔曼滤波器"""
    # TODO: 在线估计噪声参数
    pass
```

这个第一阶段的内容为学生提供了扎实的卡尔曼滤波理论基础和实践经验，为后续的扩展卡尔曼滤波和多传感器融合打下了良好的基础。