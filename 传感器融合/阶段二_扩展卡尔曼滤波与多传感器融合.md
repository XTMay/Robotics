# 阶段二：扩展卡尔曼滤波与多传感器融合

## 第4讲：非线性系统与EKF理论

### 4.1 非线性系统建模

#### 4.1.1 非线性系统的特点

在实际机器人应用中，大多数系统都是非线性的：

**非线性状态转移模型**：
$$\mathbf{x}_t = f(\mathbf{x}_{t-1}, \mathbf{u}_t) + \mathbf{w}_t$$

**非线性观测模型**：
$$\mathbf{z}_t = h(\mathbf{x}_t) + \mathbf{v}_t$$

#### 4.1.2 典型的机器人非线性模型

**二维机器人运动学模型**：
```python
import numpy as np
import matplotlib.pyplot as plt
from scipy.optimize import minimize

class Robot2DKinematics:
    """二维机器人运动学模型"""

    def __init__(self, dt=0.1):
        self.dt = dt

    def motion_model(self, state, control):
        """
        非线性运动模型

        Args:
            state: [x, y, theta] - 位置和朝向
            control: [v, omega] - 线速度和角速度

        Returns:
            new_state: 预测的新状态
        """
        x, y, theta = state
        v, omega = control

        # 避免除零
        if abs(omega) < 1e-6:
            # 直线运动
            new_x = x + v * np.cos(theta) * self.dt
            new_y = y + v * np.sin(theta) * self.dt
            new_theta = theta
        else:
            # 圆弧运动
            new_theta = theta + omega * self.dt
            new_x = x + (v / omega) * (np.sin(new_theta) - np.sin(theta))
            new_y = y + (v / omega) * (np.cos(theta) - np.cos(new_theta))

        # 保持角度在[-π, π]范围内
        new_theta = ((new_theta + np.pi) % (2 * np.pi)) - np.pi

        return np.array([new_x, new_y, new_theta])

    def observation_model(self, state, landmark_positions):
        """
        观测模型：到地标的距离和角度

        Args:
            state: [x, y, theta] - 机器人状态
            landmark_positions: [[x1, y1], [x2, y2], ...] - 地标位置

        Returns:
            observations: [range1, bearing1, range2, bearing2, ...]
        """
        x, y, theta = state
        observations = []

        for lm_x, lm_y in landmark_positions:
            # 距离
            dx = lm_x - x
            dy = lm_y - y
            range_obs = np.sqrt(dx**2 + dy**2)

            # 角度（相对于机器人朝向）
            bearing_obs = np.arctan2(dy, dx) - theta
            bearing_obs = ((bearing_obs + np.pi) % (2 * np.pi)) - np.pi

            observations.extend([range_obs, bearing_obs])

        return np.array(observations)

# 演示非线性模型
def demonstrate_nonlinear_model():
    """演示非线性模型特性"""

    robot = Robot2DKinematics(dt=0.1)

    # 不同控制输入
    controls = [
        [1.0, 0.0],    # 直线运动
        [1.0, 0.5],    # 右转
        [1.0, -0.5],   # 左转
        [1.0, 1.0],    # 急转弯
    ]

    fig, axes = plt.subplots(2, 2, figsize=(12, 10))
    axes = axes.flatten()

    for i, control in enumerate(controls):
        # 初始状态
        state = np.array([0.0, 0.0, 0.0])  # 起点在原点，朝向x轴

        # 轨迹
        trajectory = [state.copy()]

        # 模拟运动
        for step in range(50):
            state = robot.motion_model(state, control)
            trajectory.append(state.copy())

        trajectory = np.array(trajectory)

        # 绘制轨迹
        axes[i].plot(trajectory[:, 0], trajectory[:, 1], 'b-', linewidth=2)
        axes[i].scatter(trajectory[0, 0], trajectory[0, 1], color='green', s=100,
                       marker='o', label='起点')
        axes[i].scatter(trajectory[-1, 0], trajectory[-1, 1], color='red', s=100,
                       marker='x', label='终点')

        # 绘制朝向箭头
        for j in range(0, len(trajectory), 10):
            x, y, theta = trajectory[j]
            dx = 0.2 * np.cos(theta)
            dy = 0.2 * np.sin(theta)
            axes[i].arrow(x, y, dx, dy, head_width=0.1, head_length=0.1,
                         fc='red', ec='red', alpha=0.6)

        axes[i].set_aspect('equal')
        axes[i].grid(True, alpha=0.3)
        axes[i].set_title(f'控制输入: v={control[0]}, ω={control[1]}')
        axes[i].legend()

    plt.tight_layout()
    plt.show()

demonstrate_nonlinear_model()
```

### 4.2 线性化技术

#### 4.2.1 泰勒级数展开

EKF通过一阶泰勒展开将非线性函数线性化：

$$f(\mathbf{x}) \approx f(\hat{\mathbf{x}}) + \mathbf{F}(\mathbf{x} - \hat{\mathbf{x}})$$

其中 $\mathbf{F}$ 是雅可比矩阵。

#### 4.2.2 雅可比矩阵计算

```python
class JacobianCalculator:
    """雅可比矩阵计算工具"""

    @staticmethod
    def numerical_jacobian(func, x, epsilon=1e-7):
        """
        数值方法计算雅可比矩阵

        Args:
            func: 函数 f(x) -> y
            x: 评估点
            epsilon: 有限差分步长

        Returns:
            jacobian: 雅可比矩阵
        """
        x = np.array(x, dtype=float)
        f0 = func(x)

        if np.isscalar(f0):
            f0 = np.array([f0])

        m, n = len(f0), len(x)
        jacobian = np.zeros((m, n))

        for j in range(n):
            x_plus = x.copy()
            x_minus = x.copy()
            x_plus[j] += epsilon
            x_minus[j] -= epsilon

            f_plus = func(x_plus)
            f_minus = func(x_minus)

            if np.isscalar(f_plus):
                f_plus = np.array([f_plus])
            if np.isscalar(f_minus):
                f_minus = np.array([f_minus])

            jacobian[:, j] = (f_plus - f_minus) / (2 * epsilon)

        return jacobian

    @staticmethod
    def motion_model_jacobian(state, control, dt):
        """
        解析计算运动模型雅可比矩阵

        Args:
            state: [x, y, theta]
            control: [v, omega]
            dt: 时间步长

        Returns:
            F: 对状态的雅可比矩阵
            G: 对控制的雅可比矩阵
        """
        x, y, theta = state
        v, omega = control

        if abs(omega) < 1e-6:
            # 直线运动情况
            F = np.array([
                [1, 0, -v * np.sin(theta) * dt],
                [0, 1,  v * np.cos(theta) * dt],
                [0, 0,  1]
            ])

            G = np.array([
                [np.cos(theta) * dt, 0],
                [np.sin(theta) * dt, 0],
                [0, dt]
            ])
        else:
            # 圆弧运动情况
            sin_theta = np.sin(theta)
            cos_theta = np.cos(theta)
            sin_new = np.sin(theta + omega * dt)
            cos_new = np.cos(theta + omega * dt)

            F = np.array([
                [1, 0, (v/omega) * (cos_new - cos_theta)],
                [0, 1, (v/omega) * (sin_new - sin_theta)],
                [0, 0, 1]
            ])

            G = np.array([
                [(sin_new - sin_theta) / omega,
                 (v/omega**2) * (sin_theta - sin_new) + (v*dt/omega) * cos_new],
                [-(cos_new - cos_theta) / omega,
                 (v/omega**2) * (cos_new - cos_theta) + (v*dt/omega) * sin_new],
                [0, dt]
            ])

        return F, G

    @staticmethod
    def observation_model_jacobian(state, landmark_pos):
        """
        观测模型雅可比矩阵

        Args:
            state: [x, y, theta]
            landmark_pos: [lm_x, lm_y]

        Returns:
            H: 观测模型雅可比矩阵
        """
        x, y, theta = state
        lm_x, lm_y = landmark_pos

        dx = lm_x - x
        dy = lm_y - y
        r = np.sqrt(dx**2 + dy**2)

        if r < 1e-6:
            # 避免除零
            H = np.zeros((2, 3))
        else:
            H = np.array([
                [-dx/r, -dy/r, 0],           # 距离对状态的导数
                [dy/r**2, -dx/r**2, -1]      # 角度对状态的导数
            ])

        return H

# 验证雅可比计算
def verify_jacobian_calculation():
    """验证雅可比矩阵计算的正确性"""

    robot = Robot2DKinematics(dt=0.1)
    calc = JacobianCalculator()

    # 测试状态和控制
    state = np.array([1.0, 2.0, 0.5])
    control = np.array([1.5, 0.3])
    dt = 0.1

    # 定义运动模型函数
    def motion_func(x):
        return robot.motion_model(x, control)

    # 数值雅可比
    F_numerical = calc.numerical_jacobian(motion_func, state)

    # 解析雅可比
    F_analytical, _ = calc.motion_model_jacobian(state, control, dt)

    print("=== 雅可比矩阵验证 ===")
    print("数值雅可比矩阵:")
    print(F_numerical)
    print("\n解析雅可比矩阵:")
    print(F_analytical)
    print(f"\n差异范数: {np.linalg.norm(F_numerical - F_analytical):.2e}")

    # 观测模型验证
    landmark = np.array([3.0, 4.0])

    def obs_func(x):
        return robot.observation_model(x, [landmark])

    H_numerical = calc.numerical_jacobian(obs_func, state)
    H_analytical = calc.observation_model_jacobian(state, landmark)

    print("\n观测雅可比 - 数值:")
    print(H_numerical)
    print("\n观测雅可比 - 解析:")
    print(H_analytical)
    print(f"\n差异范数: {np.linalg.norm(H_numerical - H_analytical):.2e}")

verify_jacobian_calculation()
```

### 4.3 扩展卡尔曼滤波算法

#### 4.3.1 EKF算法步骤

```python
class ExtendedKalmanFilter:
    """扩展卡尔曼滤波器"""

    def __init__(self, motion_model, observation_model,
                 motion_jacobian, observation_jacobian,
                 Q, R, x0, P0):
        """
        初始化EKF

        Args:
            motion_model: 运动模型函数 f(x, u)
            observation_model: 观测模型函数 h(x)
            motion_jacobian: 运动模型雅可比函数 F, G = jacobian(x, u)
            observation_jacobian: 观测模型雅可比函数 H = jacobian(x)
            Q: 过程噪声协方差
            R: 观测噪声协方差
            x0: 初始状态
            P0: 初始协方差
        """
        self.motion_model = motion_model
        self.observation_model = observation_model
        self.motion_jacobian = motion_jacobian
        self.observation_jacobian = observation_jacobian

        self.Q = np.array(Q)
        self.R = np.array(R)

        self.x = np.array(x0, dtype=float)
        self.P = np.array(P0, dtype=float)

        # 历史记录
        self.history = {
            'x': [self.x.copy()],
            'P': [self.P.copy()],
            'K': [],
            'innovation': [],
            'likelihood': []
        }

    def predict(self, u):
        """预测步骤"""
        # 状态预测
        self.x = self.motion_model(self.x, u)

        # 计算运动模型雅可比
        F, G = self.motion_jacobian(self.x, u)

        # 协方差预测
        self.P = F @ self.P @ F.T + self.Q

        return self.x.copy(), self.P.copy()

    def update(self, z, landmark_positions=None):
        """更新步骤"""
        # 计算预测观测
        if landmark_positions is not None:
            h_x = self.observation_model(self.x, landmark_positions)
            H = self._compute_observation_jacobian(self.x, landmark_positions)
        else:
            h_x = self.observation_model(self.x)
            H = self.observation_jacobian(self.x)

        # 创新（残差）
        innovation = z - h_x

        # 处理角度差异（wrap to [-π, π]）
        for i in range(1, len(innovation), 2):  # 假设奇数索引是角度
            innovation[i] = ((innovation[i] + np.pi) % (2 * np.pi)) - np.pi

        # 创新协方差
        S = H @ self.P @ H.T + self.R

        # 卡尔曼增益
        try:
            K = self.P @ H.T @ np.linalg.inv(S)
        except np.linalg.LinAlgError:
            # 处理矩阵奇异的情况
            K = self.P @ H.T @ np.linalg.pinv(S)

        # 状态更新
        self.x = self.x + K @ innovation

        # 角度归一化
        if len(self.x) >= 3:  # 假设第三个状态是角度
            self.x[2] = ((self.x[2] + np.pi) % (2 * np.pi)) - np.pi

        # 协方差更新（Joseph形式）
        I_KH = np.eye(len(self.x)) - K @ H
        self.P = I_KH @ self.P @ I_KH.T + K @ self.R @ K.T

        # 计算似然
        likelihood = self._compute_likelihood(innovation, S)

        # 记录历史
        self.history['x'].append(self.x.copy())
        self.history['P'].append(self.P.copy())
        self.history['K'].append(K.copy())
        self.history['innovation'].append(innovation.copy())
        self.history['likelihood'].append(likelihood)

        return self.x.copy(), self.P.copy(), K.copy()

    def _compute_observation_jacobian(self, state, landmark_positions):
        """计算多个地标的观测雅可比矩阵"""
        jacobians = []
        for landmark in landmark_positions:
            H_single = self.observation_jacobian(state, landmark)
            jacobians.append(H_single)
        return np.vstack(jacobians)

    def _compute_likelihood(self, innovation, S):
        """计算观测似然"""
        try:
            det_S = np.linalg.det(S)
            if det_S <= 0:
                return -np.inf

            inv_S = np.linalg.inv(S)
            log_likelihood = -0.5 * (len(innovation) * np.log(2 * np.pi) +
                                   np.log(det_S) +
                                   innovation.T @ inv_S @ innovation)
            return log_likelihood
        except:
            return -np.inf

    def get_state(self):
        """获取当前状态估计"""
        return self.x.copy(), self.P.copy()

    def get_history(self):
        """获取历史记录"""
        return self.history.copy()

# EKF机器人定位示例
class RobotLocalizationEKF:
    """基于EKF的机器人定位"""

    def __init__(self, dt=0.1, process_noise_std=0.1,
                 range_noise_std=0.1, bearing_noise_std=0.05):
        self.dt = dt
        self.robot_model = Robot2DKinematics(dt)
        self.jacobian_calc = JacobianCalculator()

        # 过程噪声协方差
        self.Q = np.diag([process_noise_std**2, process_noise_std**2,
                         (0.1 * process_noise_std)**2])

        # 观测噪声协方差（距离和角度）
        self.R_single = np.diag([range_noise_std**2, bearing_noise_std**2])

    def create_ekf(self, initial_state, initial_covariance, num_landmarks):
        """创建EKF实例"""
        # 观测噪声矩阵（多个地标）
        R = np.kron(np.eye(num_landmarks), self.R_single)

        # 定义函数包装器
        def motion_model(x, u):
            return self.robot_model.motion_model(x, u)

        def observation_model(x, landmarks):
            return self.robot_model.observation_model(x, landmarks)

        def motion_jacobian(x, u):
            return self.jacobian_calc.motion_model_jacobian(x, u, self.dt)

        def observation_jacobian(x, landmark):
            return self.jacobian_calc.observation_model_jacobian(x, landmark)

        return ExtendedKalmanFilter(
            motion_model, observation_model,
            motion_jacobian, observation_jacobian,
            self.Q, R, initial_state, initial_covariance
        )

def demonstrate_ekf_localization():
    """演示EKF定位"""

    # 创建环境
    landmarks = np.array([[5, 5], [5, -5], [-5, 5], [-5, -5]])

    # 真实轨迹
    true_states = []
    controls = []
    observations = []

    # 初始状态
    true_state = np.array([0.0, 0.0, 0.0])
    true_states.append(true_state.copy())

    robot_model = Robot2DKinematics(dt=0.1)

    # 生成轨迹和观测
    for t in range(50):
        # 控制输入（圆形轨迹）
        control = np.array([1.0, 0.2])
        controls.append(control.copy())

        # 状态更新
        true_state = robot_model.motion_model(true_state, control)
        true_states.append(true_state.copy())

        # 生成噪声观测
        true_obs = robot_model.observation_model(true_state, landmarks)
        noisy_obs = true_obs + np.random.normal(0, [0.1, 0.05] * len(landmarks))
        observations.append(noisy_obs)

    # 创建EKF
    localization = RobotLocalizationEKF()
    ekf = localization.create_ekf(
        initial_state=[0, 0, 0],
        initial_covariance=np.diag([1, 1, 0.1]),
        num_landmarks=len(landmarks)
    )

    # EKF定位
    estimated_states = []
    covariances = []

    for t, (control, obs) in enumerate(zip(controls, observations)):
        # 预测
        ekf.predict(control)

        # 更新
        ekf.update(obs, landmarks)

        # 记录结果
        x_est, P_est = ekf.get_state()
        estimated_states.append(x_est.copy())
        covariances.append(P_est.copy())

    # 可视化结果
    visualize_ekf_localization(true_states, estimated_states, covariances,
                              landmarks, observations)

    return true_states, estimated_states, covariances

def visualize_ekf_localization(true_states, estimated_states, covariances,
                              landmarks, observations):
    """可视化EKF定位结果"""

    fig, axes = plt.subplots(2, 2, figsize=(15, 12))

    # 转换为数组
    true_states = np.array(true_states)
    estimated_states = np.array(estimated_states)

    # 轨迹对比
    axes[0, 0].plot(true_states[:, 0], true_states[:, 1], 'g-',
                    linewidth=2, label='真实轨迹')
    axes[0, 0].plot(estimated_states[:, 0], estimated_states[:, 1], 'b-',
                    linewidth=2, label='EKF估计')

    # 地标
    axes[0, 0].scatter(landmarks[:, 0], landmarks[:, 1],
                      color='red', s=100, marker='^', label='地标')

    # 不确定性椭圆（每5步显示一次）
    for i in range(0, len(covariances), 5):
        P = covariances[i][:2, :2]  # 只取位置协方差
        mean = estimated_states[i][:2]

        try:
            eigenvals, eigenvecs = np.linalg.eigh(P)
            angle = np.degrees(np.arctan2(eigenvecs[1, 0], eigenvecs[0, 0]))
            width = 2 * np.sqrt(eigenvals[0])
            height = 2 * np.sqrt(eigenvals[1])

            from matplotlib.patches import Ellipse
            ellipse = Ellipse(mean, width, height, angle=angle,
                            facecolor='blue', alpha=0.2, edgecolor='blue')
            axes[0, 0].add_patch(ellipse)
        except:
            pass

    axes[0, 0].set_aspect('equal')
    axes[0, 0].grid(True, alpha=0.3)
    axes[0, 0].legend()
    axes[0, 0].set_title('轨迹对比')

    # 位置误差
    position_errors = np.linalg.norm(
        true_states[1:, :2] - estimated_states[:, :2], axis=1)

    axes[0, 1].plot(position_errors, 'r-', linewidth=2)
    axes[0, 1].set_title('位置估计误差')
    axes[0, 1].set_xlabel('时间步')
    axes[0, 1].set_ylabel('误差 (m)')
    axes[0, 1].grid(True, alpha=0.3)

    # 朝向误差
    theta_errors = true_states[1:, 2] - estimated_states[:, 2]
    # 角度差异归一化
    theta_errors = ((theta_errors + np.pi) % (2 * np.pi)) - np.pi

    axes[1, 0].plot(np.degrees(theta_errors), 'g-', linewidth=2)
    axes[1, 0].set_title('朝向估计误差')
    axes[1, 0].set_xlabel('时间步')
    axes[1, 0].set_ylabel('误差 (度)')
    axes[1, 0].grid(True, alpha=0.3)

    # 不确定性演化
    position_uncertainty = [np.sqrt(P[0, 0] + P[1, 1]) for P in covariances]

    axes[1, 1].plot(position_uncertainty, 'b-', linewidth=2)
    axes[1, 1].set_title('位置不确定性')
    axes[1, 1].set_xlabel('时间步')
    axes[1, 1].set_ylabel('标准差 (m)')
    axes[1, 1].grid(True, alpha=0.3)

    plt.tight_layout()
    plt.show()

# 运行EKF定位演示
true_traj, est_traj, covs = demonstrate_ekf_localization()
```

## 第5讲：IMU与里程计数据处理

### 5.1 IMU数据预处理

#### 5.1.1 IMU传感器原理

```python
class IMUDataProcessor:
    """IMU数据处理器"""

    def __init__(self, gyro_noise_std=0.1, accel_noise_std=0.1,
                 gyro_bias_std=0.01, accel_bias_std=0.01):
        # 噪声参数
        self.gyro_noise_std = gyro_noise_std
        self.accel_noise_std = accel_noise_std
        self.gyro_bias_std = gyro_bias_std
        self.accel_bias_std = accel_bias_std

        # 偏差估计
        self.gyro_bias = np.zeros(3)
        self.accel_bias = np.zeros(3)

        # 校准参数
        self.gyro_scale = np.ones(3)
        self.accel_scale = np.ones(3)

        # 历史数据
        self.gyro_history = []
        self.accel_history = []

    def calibrate_static(self, gyro_data, accel_data, gravity=9.81):
        """
        静态校准

        Args:
            gyro_data: 静止时的陀螺仪数据 (N×3)
            accel_data: 静止时的加速度计数据 (N×3)
            gravity: 重力加速度
        """
        gyro_data = np.array(gyro_data)
        accel_data = np.array(accel_data)

        # 陀螺仪偏差
        self.gyro_bias = np.mean(gyro_data, axis=0)

        # 加速度计偏差和缩放
        accel_mean = np.mean(accel_data, axis=0)
        accel_norm = np.linalg.norm(accel_mean)

        # 假设静止时只受重力影响
        self.accel_scale = gravity / accel_norm
        self.accel_bias = accel_mean - gravity * np.array([0, 0, 1])

        print("=== IMU静态校准结果 ===")
        print(f"陀螺仪偏差: {self.gyro_bias}")
        print(f"加速度计偏差: {self.accel_bias}")
        print(f"加速度计缩放: {self.accel_scale}")

    def process_gyro_data(self, raw_gyro):
        """处理陀螺仪数据"""
        # 去偏差和缩放
        calibrated = (raw_gyro - self.gyro_bias) * self.gyro_scale

        # 低通滤波（简单的移动平均）
        self.gyro_history.append(calibrated)
        if len(self.gyro_history) > 5:
            self.gyro_history.pop(0)

        filtered = np.mean(self.gyro_history, axis=0)

        return filtered

    def process_accel_data(self, raw_accel):
        """处理加速度计数据"""
        # 去偏差和缩放
        calibrated = (raw_accel - self.accel_bias) * self.accel_scale

        # 低通滤波
        self.accel_history.append(calibrated)
        if len(self.accel_history) > 5:
            self.accel_history.pop(0)

        filtered = np.mean(self.accel_history, axis=0)

        return filtered

    def integrate_orientation(self, gyro_data, dt, initial_orientation=None):
        """
        积分陀螺仪数据获得朝向

        Args:
            gyro_data: 角速度数据序列
            dt: 时间步长
            initial_orientation: 初始朝向（欧拉角）

        Returns:
            orientations: 朝向角度序列
        """
        if initial_orientation is None:
            initial_orientation = np.array([0, 0, 0])  # roll, pitch, yaw

        orientations = [initial_orientation.copy()]
        current_orientation = initial_orientation.copy()

        for gyro in gyro_data:
            # 简单的欧拉积分（实际应用中应使用四元数）
            current_orientation += gyro * dt

            # 保持角度在合理范围
            current_orientation = np.mod(current_orientation + np.pi, 2*np.pi) - np.pi

            orientations.append(current_orientation.copy())

        return np.array(orientations)

# 模拟IMU数据
def simulate_imu_data():
    """模拟IMU数据"""

    dt = 0.01  # 100Hz
    duration = 10  # 10秒
    n_samples = int(duration / dt)

    # 真实运动
    time = np.linspace(0, duration, n_samples)

    # 角速度（绕z轴旋转）
    true_omega_z = 0.5 * np.sin(0.5 * time)  # rad/s
    true_gyro = np.column_stack([
        np.zeros(n_samples),      # ωx
        np.zeros(n_samples),      # ωy
        true_omega_z              # ωz
    ])

    # 线加速度（前进运动）
    true_accel_x = 2.0 * np.sin(0.2 * time)  # m/s²
    true_accel = np.column_stack([
        true_accel_x,             # ax
        np.zeros(n_samples),      # ay
        np.full(n_samples, 9.81)  # az (重力)
    ])

    # 添加噪声和偏差
    gyro_bias = np.array([0.01, -0.02, 0.005])
    accel_bias = np.array([0.1, -0.05, 0.2])

    noisy_gyro = true_gyro + gyro_bias + np.random.normal(0, 0.1, true_gyro.shape)
    noisy_accel = true_accel + accel_bias + np.random.normal(0, 0.2, true_accel.shape)

    return {
        'time': time,
        'true_gyro': true_gyro,
        'true_accel': true_accel,
        'noisy_gyro': noisy_gyro,
        'noisy_accel': noisy_accel,
        'dt': dt
    }

def demonstrate_imu_processing():
    """演示IMU数据处理"""

    # 生成模拟数据
    imu_data = simulate_imu_data()

    # 创建处理器
    processor = IMUDataProcessor()

    # 使用前100个样本进行静态校准
    static_samples = 100
    processor.calibrate_static(
        imu_data['noisy_gyro'][:static_samples],
        imu_data['noisy_accel'][:static_samples]
    )

    # 处理所有数据
    processed_gyro = []
    processed_accel = []

    for i in range(len(imu_data['noisy_gyro'])):
        proc_g = processor.process_gyro_data(imu_data['noisy_gyro'][i])
        proc_a = processor.process_accel_data(imu_data['noisy_accel'][i])

        processed_gyro.append(proc_g)
        processed_accel.append(proc_a)

    processed_gyro = np.array(processed_gyro)
    processed_accel = np.array(processed_accel)

    # 可视化结果
    fig, axes = plt.subplots(3, 2, figsize=(15, 12))

    time = imu_data['time']

    # 陀螺仪数据
    for i, label in enumerate(['ωx', 'ωy', 'ωz']):
        axes[i, 0].plot(time, imu_data['true_gyro'][:, i], 'g-',
                       linewidth=2, label='真实值')
        axes[i, 0].plot(time, imu_data['noisy_gyro'][:, i], 'r-',
                       alpha=0.5, label='噪声数据')
        axes[i, 0].plot(time, processed_gyro[:, i], 'b-',
                       linewidth=2, label='处理后')
        axes[i, 0].set_ylabel(f'{label} (rad/s)')
        axes[i, 0].legend()
        axes[i, 0].grid(True, alpha=0.3)
        if i == 0:
            axes[i, 0].set_title('陀螺仪数据处理')

    # 加速度计数据
    for i, label in enumerate(['ax', 'ay', 'az']):
        axes[i, 1].plot(time, imu_data['true_accel'][:, i], 'g-',
                       linewidth=2, label='真实值')
        axes[i, 1].plot(time, imu_data['noisy_accel'][:, i], 'r-',
                       alpha=0.5, label='噪声数据')
        axes[i, 1].plot(time, processed_accel[:, i], 'b-',
                       linewidth=2, label='处理后')
        axes[i, 1].set_ylabel(f'{label} (m/s²)')
        axes[i, 1].legend()
        axes[i, 1].grid(True, alpha=0.3)
        if i == 0:
            axes[i, 1].set_title('加速度计数据处理')

    axes[2, 0].set_xlabel('时间 (s)')
    axes[2, 1].set_xlabel('时间 (s)')

    plt.tight_layout()
    plt.show()

    return imu_data, processed_gyro, processed_accel

# 运行IMU处理演示
imu_data, proc_gyro, proc_accel = demonstrate_imu_processing()
```

### 5.2 轮式里程计建模

#### 5.2.1 差分驱动模型

```python
class WheelOdometry:
    """轮式里程计"""

    def __init__(self, wheel_base, wheel_radius, encoder_resolution):
        """
        初始化轮式里程计

        Args:
            wheel_base: 轮距 (m)
            wheel_radius: 轮子半径 (m)
            encoder_resolution: 编码器分辨率 (脉冲/转)
        """
        self.wheel_base = wheel_base
        self.wheel_radius = wheel_radius
        self.encoder_resolution = encoder_resolution

        # 编码器计数
        self.left_encoder_count = 0
        self.right_encoder_count = 0

        # 位姿估计
        self.x = 0.0
        self.y = 0.0
        self.theta = 0.0

        # 历史记录
        self.pose_history = [(self.x, self.y, self.theta)]
        self.velocity_history = []

    def encoder_to_distance(self, encoder_counts):
        """编码器计数转换为距离"""
        rotations = encoder_counts / self.encoder_resolution
        distance = rotations * 2 * np.pi * self.wheel_radius
        return distance

    def update_odometry(self, left_encoder_delta, right_encoder_delta, dt):
        """
        更新里程计

        Args:
            left_encoder_delta: 左轮编码器增量
            right_encoder_delta: 右轮编码器增量
            dt: 时间间隔
        """
        # 计算轮子转动距离
        left_distance = self.encoder_to_distance(left_encoder_delta)
        right_distance = self.encoder_to_distance(right_encoder_delta)

        # 计算机器人运动
        distance = (left_distance + right_distance) / 2.0
        delta_theta = (right_distance - left_distance) / self.wheel_base

        # 更新位姿
        if abs(delta_theta) < 1e-6:
            # 直线运动
            delta_x = distance * np.cos(self.theta)
            delta_y = distance * np.sin(self.theta)
        else:
            # 圆弧运动
            radius = distance / delta_theta
            delta_x = radius * (np.sin(self.theta + delta_theta) - np.sin(self.theta))
            delta_y = radius * (np.cos(self.theta) - np.cos(self.theta + delta_theta))

        self.x += delta_x
        self.y += delta_y
        self.theta += delta_theta
        self.theta = ((self.theta + np.pi) % (2 * np.pi)) - np.pi

        # 计算速度
        linear_velocity = distance / dt if dt > 0 else 0
        angular_velocity = delta_theta / dt if dt > 0 else 0

        # 记录历史
        self.pose_history.append((self.x, self.y, self.theta))
        self.velocity_history.append((linear_velocity, angular_velocity))

        return (self.x, self.y, self.theta), (linear_velocity, angular_velocity)

    def get_pose(self):
        """获取当前位姿"""
        return np.array([self.x, self.y, self.theta])

    def get_velocity(self):
        """获取当前速度"""
        if self.velocity_history:
            return np.array(self.velocity_history[-1])
        return np.array([0.0, 0.0])

    def reset(self, x=0, y=0, theta=0):
        """重置里程计"""
        self.x = x
        self.y = y
        self.theta = theta
        self.pose_history = [(x, y, theta)]
        self.velocity_history = []

# 模拟轮式里程计数据
def simulate_wheel_odometry():
    """模拟轮式里程计数据"""

    # 机器人参数
    wheel_base = 0.5  # 50cm轮距
    wheel_radius = 0.1  # 10cm轮半径
    encoder_resolution = 1024  # 1024脉冲/转

    # 创建里程计
    odometry = WheelOdometry(wheel_base, wheel_radius, encoder_resolution)

    # 模拟运动命令
    dt = 0.1
    duration = 20
    n_steps = int(duration / dt)

    # 生成运动轨迹
    true_poses = []
    odometry_poses = []

    # 真实状态
    true_x, true_y, true_theta = 0, 0, 0
    true_poses.append([true_x, true_y, true_theta])

    for t in range(n_steps):
        time = t * dt

        # 运动命令
        if time < 5:
            # 直线运动
            v, omega = 1.0, 0.0
        elif time < 10:
            # 左转
            v, omega = 1.0, 0.3
        elif time < 15:
            # 直线运动
            v, omega = 1.0, 0.0
        else:
            # 右转
            v, omega = 1.0, -0.3

        # 真实运动更新
        if abs(omega) < 1e-6:
            true_x += v * np.cos(true_theta) * dt
            true_y += v * np.sin(true_theta) * dt
        else:
            r = v / omega
            true_x += r * (np.sin(true_theta + omega * dt) - np.sin(true_theta))
            true_y += r * (np.cos(true_theta) - np.cos(true_theta + omega * dt))
            true_theta += omega * dt
            true_theta = ((true_theta + np.pi) % (2 * np.pi)) - np.pi

        true_poses.append([true_x, true_y, true_theta])

        # 计算轮速
        left_wheel_speed = v - omega * wheel_base / 2
        right_wheel_speed = v + omega * wheel_base / 2

        # 转换为编码器计数
        left_rotations = left_wheel_speed * dt / (2 * np.pi * wheel_radius)
        right_rotations = right_wheel_speed * dt / (2 * np.pi * wheel_radius)

        left_encoder_delta = left_rotations * encoder_resolution
        right_encoder_delta = right_rotations * encoder_resolution

        # 添加编码器噪声
        noise_std = 5  # 编码器噪声（脉冲）
        left_encoder_delta += np.random.normal(0, noise_std)
        right_encoder_delta += np.random.normal(0, noise_std)

        # 更新里程计
        pose, velocity = odometry.update_odometry(left_encoder_delta, right_encoder_delta, dt)
        odometry_poses.append(pose)

    return {
        'true_poses': np.array(true_poses),
        'odometry_poses': np.array(odometry_poses),
        'dt': dt,
        'odometry': odometry
    }

def visualize_odometry_comparison():
    """可视化里程计对比"""

    data = simulate_wheel_odometry()

    true_poses = data['true_poses']
    odom_poses = data['odometry_poses']

    fig, axes = plt.subplots(2, 2, figsize=(15, 10))

    # 轨迹对比
    axes[0, 0].plot(true_poses[:, 0], true_poses[:, 1], 'g-',
                    linewidth=2, label='真实轨迹')
    axes[0, 0].plot(odom_poses[:, 0], odom_poses[:, 1], 'b--',
                    linewidth=2, label='里程计估计')
    axes[0, 0].set_aspect('equal')
    axes[0, 0].legend()
    axes[0, 0].grid(True, alpha=0.3)
    axes[0, 0].set_title('轨迹对比')
    axes[0, 0].set_xlabel('X (m)')
    axes[0, 0].set_ylabel('Y (m)')

    # 位置误差
    position_errors = np.linalg.norm(
        true_poses[1:, :2] - odom_poses[:, :2], axis=1)

    time_steps = np.arange(len(position_errors)) * data['dt']
    axes[0, 1].plot(time_steps, position_errors, 'r-', linewidth=2)
    axes[0, 1].set_title('位置估计误差')
    axes[0, 1].set_xlabel('时间 (s)')
    axes[0, 1].set_ylabel('误差 (m)')
    axes[0, 1].grid(True, alpha=0.3)

    # 朝向对比
    axes[1, 0].plot(time_steps, np.degrees(true_poses[1:, 2]), 'g-',
                    linewidth=2, label='真实朝向')
    axes[1, 0].plot(time_steps, np.degrees(odom_poses[:, 2]), 'b--',
                    linewidth=2, label='里程计估计')
    axes[1, 0].legend()
    axes[1, 0].grid(True, alpha=0.3)
    axes[1, 0].set_title('朝向对比')
    axes[1, 0].set_xlabel('时间 (s)')
    axes[1, 0].set_ylabel('朝向 (度)')

    # 朝向误差
    theta_errors = true_poses[1:, 2] - odom_poses[:, 2]
    theta_errors = ((theta_errors + np.pi) % (2 * np.pi)) - np.pi

    axes[1, 1].plot(time_steps, np.degrees(theta_errors), 'r-', linewidth=2)
    axes[1, 1].set_title('朝向估计误差')
    axes[1, 1].set_xlabel('时间 (s)')
    axes[1, 1].set_ylabel('误差 (度)')
    axes[1, 1].grid(True, alpha=0.3)

    plt.tight_layout()
    plt.show()

    # 误差统计
    final_position_error = position_errors[-1]
    final_theta_error = np.degrees(abs(theta_errors[-1]))

    print("=== 里程计误差分析 ===")
    print(f"最终位置误差: {final_position_error:.3f} m")
    print(f"最终朝向误差: {final_theta_error:.1f} 度")
    print(f"平均位置误差: {np.mean(position_errors):.3f} m")
    print(f"位置误差标准差: {np.std(position_errors):.3f} m")

# 运行里程计演示
visualize_odometry_comparison()
```

### 5.3 IMU与里程计融合

#### 5.3.1 互补滤波方法

```python
class ComplementaryFilter:
    """互补滤波器"""

    def __init__(self, alpha=0.98):
        """
        初始化互补滤波器

        Args:
            alpha: 滤波参数 (0-1), 接近1更信任陀螺仪
        """
        self.alpha = alpha
        self.orientation = np.array([0.0, 0.0, 0.0])  # roll, pitch, yaw

    def update(self, gyro_data, accel_data, dt):
        """
        更新朝向估计

        Args:
            gyro_data: 陀螺仪数据 [wx, wy, wz]
            accel_data: 加速度计数据 [ax, ay, az]
            dt: 时间步长
        """
        # 陀螺仪积分
        gyro_orientation = self.orientation + gyro_data * dt

        # 加速度计朝向估计（假设静态）
        accel_norm = np.linalg.norm(accel_data)
        if accel_norm > 0:
            # Roll和Pitch可以从重力方向计算
            roll_accel = np.arctan2(accel_data[1], accel_data[2])
            pitch_accel = np.arctan2(-accel_data[0],
                                   np.sqrt(accel_data[1]**2 + accel_data[2]**2))

            # Yaw无法从加速度计确定，保持陀螺仪值
            accel_orientation = np.array([roll_accel, pitch_accel, gyro_orientation[2]])
        else:
            accel_orientation = gyro_orientation

        # 互补滤波
        self.orientation = (self.alpha * gyro_orientation +
                          (1 - self.alpha) * accel_orientation)

        return self.orientation.copy()

class IMUOdometryFusion:
    """IMU与里程计融合系统"""

    def __init__(self, wheel_base, wheel_radius, dt=0.01):
        self.wheel_base = wheel_base
        self.wheel_radius = wheel_radius
        self.dt = dt

        # 初始状态：[x, y, theta, vx, vy, omega]
        self.state = np.zeros(6)

        # 互补滤波器
        self.comp_filter = ComplementaryFilter(alpha=0.98)

        # 历史记录
        self.state_history = [self.state.copy()]

    def predict_with_imu(self, gyro_data, accel_data):
        """使用IMU预测状态"""
        # 更新朝向
        orientation = self.comp_filter.update(gyro_data, accel_data, self.dt)
        self.state[2] = orientation[2]  # yaw角

        # 使用加速度更新速度（去除重力）
        # 简化处理：假设平面运动
        gravity_compensated = accel_data[:2]  # 忽略z轴

        # 将加速度从机器人坐标系转换到世界坐标系
        cos_theta = np.cos(self.state[2])
        sin_theta = np.sin(self.state[2])

        world_accel = np.array([
            cos_theta * gravity_compensated[0] - sin_theta * gravity_compensated[1],
            sin_theta * gravity_compensated[0] + cos_theta * gravity_compensated[1]
        ])

        # 更新速度
        self.state[3:5] += world_accel * self.dt

        # 更新位置
        self.state[:2] += self.state[3:5] * self.dt

        # 角速度
        self.state[5] = gyro_data[2]

    def update_with_odometry(self, left_wheel_vel, right_wheel_vel):
        """使用里程计更新状态"""
        # 计算机器人速度
        v = (left_wheel_vel + right_wheel_vel) / 2
        omega = (right_wheel_vel - left_wheel_vel) / self.wheel_base

        # 更新位置
        self.state[0] += v * np.cos(self.state[2]) * self.dt
        self.state[1] += v * np.sin(self.state[2]) * self.dt
        self.state[2] += omega * self.dt
        self.state[2] = ((self.state[2] + np.pi) % (2 * np.pi)) - np.pi

        # 更新速度
        self.state[3] = v * np.cos(self.state[2])
        self.state[4] = v * np.sin(self.state[2])
        self.state[5] = omega

    def fuse_sensors(self, gyro_data, accel_data, left_wheel_vel, right_wheel_vel,
                    imu_weight=0.3, odom_weight=0.7):
        """融合IMU和里程计数据"""
        # 保存当前状态
        state_before = self.state.copy()

        # IMU预测
        self.predict_with_imu(gyro_data, accel_data)
        imu_state = self.state.copy()

        # 恢复状态并使用里程计更新
        self.state = state_before.copy()
        self.update_with_odometry(left_wheel_vel, right_wheel_vel)
        odom_state = self.state.copy()

        # 加权融合
        self.state = imu_weight * imu_state + odom_weight * odom_state

        # 角度特殊处理
        theta_diff = imu_state[2] - odom_state[2]
        theta_diff = ((theta_diff + np.pi) % (2 * np.pi)) - np.pi
        self.state[2] = odom_state[2] + imu_weight * theta_diff
        self.state[2] = ((self.state[2] + np.pi) % (2 * np.pi)) - np.pi

        # 记录历史
        self.state_history.append(self.state.copy())

        return self.state.copy()

def demonstrate_imu_odometry_fusion():
    """演示IMU和里程计融合"""

    # 参数设置
    wheel_base = 0.5
    wheel_radius = 0.1
    dt = 0.01

    # 创建融合系统
    fusion = IMUOdometryFusion(wheel_base, wheel_radius, dt)

    # 模拟数据
    duration = 15
    n_steps = int(duration / dt)

    # 存储结果
    true_states = []
    imu_only_states = []
    odom_only_states = []
    fused_states = []

    # 真实状态
    true_state = np.zeros(6)  # [x, y, theta, vx, vy, omega]

    # 单独的估计器
    imu_only = IMUOdometryFusion(wheel_base, wheel_radius, dt)
    odom_only = IMUOdometryFusion(wheel_base, wheel_radius, dt)

    for t in range(n_steps):
        time = t * dt

        # 生成运动命令
        if time < 5:
            v_cmd, omega_cmd = 2.0, 0.0
        elif time < 10:
            v_cmd, omega_cmd = 2.0, 0.5
        else:
            v_cmd, omega_cmd = 2.0, -0.3

        # 更新真实状态
        true_state[0] += v_cmd * np.cos(true_state[2]) * dt
        true_state[1] += v_cmd * np.sin(true_state[2]) * dt
        true_state[2] += omega_cmd * dt
        true_state[2] = ((true_state[2] + np.pi) % (2 * np.pi)) - np.pi
        true_state[3] = v_cmd * np.cos(true_state[2])
        true_state[4] = v_cmd * np.sin(true_state[2])
        true_state[5] = omega_cmd

        true_states.append(true_state.copy())

        # 生成传感器数据
        # IMU数据（带噪声）
        gyro_noise = np.random.normal(0, 0.01, 3)
        accel_noise = np.random.normal(0, 0.1, 3)

        gyro_data = np.array([0, 0, omega_cmd]) + gyro_noise
        accel_data = np.array([v_cmd / dt, 0, 9.81]) + accel_noise  # 简化的加速度

        # 里程计数据（带噪声）
        left_wheel_vel = v_cmd - omega_cmd * wheel_base / 2
        right_wheel_vel = v_cmd + omega_cmd * wheel_base / 2

        wheel_noise = np.random.normal(0, 0.05, 2)
        left_wheel_vel += wheel_noise[0]
        right_wheel_vel += wheel_noise[1]

        # 更新各个估计器
        # 融合系统
        fused_state = fusion.fuse_sensors(gyro_data, accel_data,
                                        left_wheel_vel, right_wheel_vel)
        fused_states.append(fused_state.copy())

        # 仅IMU
        imu_only.predict_with_imu(gyro_data, accel_data)
        imu_only_states.append(imu_only.state.copy())

        # 仅里程计
        odom_only.update_with_odometry(left_wheel_vel, right_wheel_vel)
        odom_only_states.append(odom_only.state.copy())

    # 转换为数组
    true_states = np.array(true_states)
    imu_only_states = np.array(imu_only_states)
    odom_only_states = np.array(odom_only_states)
    fused_states = np.array(fused_states)

    # 可视化结果
    visualize_fusion_results(true_states, imu_only_states, odom_only_states,
                           fused_states, dt)

    return true_states, fused_states

def visualize_fusion_results(true_states, imu_states, odom_states, fused_states, dt):
    """可视化融合结果"""

    fig, axes = plt.subplots(2, 3, figsize=(18, 10))

    time = np.arange(len(true_states)) * dt

    # 轨迹对比
    axes[0, 0].plot(true_states[:, 0], true_states[:, 1], 'g-',
                    linewidth=3, label='真实轨迹')
    axes[0, 0].plot(imu_states[:, 0], imu_states[:, 1], 'r--',
                    linewidth=2, label='仅IMU', alpha=0.7)
    axes[0, 0].plot(odom_states[:, 0], odom_states[:, 1], 'b--',
                    linewidth=2, label='仅里程计', alpha=0.7)
    axes[0, 0].plot(fused_states[:, 0], fused_states[:, 1], 'm-',
                    linewidth=2, label='融合结果')
    axes[0, 0].set_aspect('equal')
    axes[0, 0].legend()
    axes[0, 0].grid(True, alpha=0.3)
    axes[0, 0].set_title('轨迹对比')
    axes[0, 0].set_xlabel('X (m)')
    axes[0, 0].set_ylabel('Y (m)')

    # X位置误差
    x_error_imu = np.abs(true_states[:, 0] - imu_states[:, 0])
    x_error_odom = np.abs(true_states[:, 0] - odom_states[:, 0])
    x_error_fused = np.abs(true_states[:, 0] - fused_states[:, 0])

    axes[0, 1].plot(time, x_error_imu, 'r-', label='仅IMU', alpha=0.7)
    axes[0, 1].plot(time, x_error_odom, 'b-', label='仅里程计', alpha=0.7)
    axes[0, 1].plot(time, x_error_fused, 'm-', label='融合结果', linewidth=2)
    axes[0, 1].legend()
    axes[0, 1].grid(True, alpha=0.3)
    axes[0, 1].set_title('X位置误差')
    axes[0, 1].set_xlabel('时间 (s)')
    axes[0, 1].set_ylabel('误差 (m)')

    # Y位置误差
    y_error_imu = np.abs(true_states[:, 1] - imu_states[:, 1])
    y_error_odom = np.abs(true_states[:, 1] - odom_states[:, 1])
    y_error_fused = np.abs(true_states[:, 1] - fused_states[:, 1])

    axes[0, 2].plot(time, y_error_imu, 'r-', label='仅IMU', alpha=0.7)
    axes[0, 2].plot(time, y_error_odom, 'b-', label='仅里程计', alpha=0.7)
    axes[0, 2].plot(time, y_error_fused, 'm-', label='融合结果', linewidth=2)
    axes[0, 2].legend()
    axes[0, 2].grid(True, alpha=0.3)
    axes[0, 2].set_title('Y位置误差')
    axes[0, 2].set_xlabel('时间 (s)')
    axes[0, 2].set_ylabel('误差 (m)')

    # 朝向对比
    axes[1, 0].plot(time, np.degrees(true_states[:, 2]), 'g-',
                    linewidth=3, label='真实朝向')
    axes[1, 0].plot(time, np.degrees(imu_states[:, 2]), 'r--',
                    linewidth=2, label='仅IMU', alpha=0.7)
    axes[1, 0].plot(time, np.degrees(odom_states[:, 2]), 'b--',
                    linewidth=2, label='仅里程计', alpha=0.7)
    axes[1, 0].plot(time, np.degrees(fused_states[:, 2]), 'm-',
                    linewidth=2, label='融合结果')
    axes[1, 0].legend()
    axes[1, 0].grid(True, alpha=0.3)
    axes[1, 0].set_title('朝向对比')
    axes[1, 0].set_xlabel('时间 (s)')
    axes[1, 0].set_ylabel('朝向 (度)')

    # 朝向误差
    theta_error_imu = np.abs(true_states[:, 2] - imu_states[:, 2])
    theta_error_odom = np.abs(true_states[:, 2] - odom_states[:, 2])
    theta_error_fused = np.abs(true_states[:, 2] - fused_states[:, 2])

    # 处理角度跳跃
    for errors in [theta_error_imu, theta_error_odom, theta_error_fused]:
        errors[errors > np.pi] = 2*np.pi - errors[errors > np.pi]

    axes[1, 1].plot(time, np.degrees(theta_error_imu), 'r-', label='仅IMU', alpha=0.7)
    axes[1, 1].plot(time, np.degrees(theta_error_odom), 'b-', label='仅里程计', alpha=0.7)
    axes[1, 1].plot(time, np.degrees(theta_error_fused), 'm-', label='融合结果', linewidth=2)
    axes[1, 1].legend()
    axes[1, 1].grid(True, alpha=0.3)
    axes[1, 1].set_title('朝向误差')
    axes[1, 1].set_xlabel('时间 (s)')
    axes[1, 1].set_ylabel('误差 (度)')

    # 总位置误差
    pos_error_imu = np.sqrt(x_error_imu**2 + y_error_imu**2)
    pos_error_odom = np.sqrt(x_error_odom**2 + y_error_odom**2)
    pos_error_fused = np.sqrt(x_error_fused**2 + y_error_fused**2)

    axes[1, 2].plot(time, pos_error_imu, 'r-', label='仅IMU', alpha=0.7)
    axes[1, 2].plot(time, pos_error_odom, 'b-', label='仅里程计', alpha=0.7)
    axes[1, 2].plot(time, pos_error_fused, 'm-', label='融合结果', linewidth=2)
    axes[1, 2].legend()
    axes[1, 2].grid(True, alpha=0.3)
    axes[1, 2].set_title('总位置误差')
    axes[1, 2].set_xlabel('时间 (s)')
    axes[1, 2].set_ylabel('误差 (m)')

    plt.tight_layout()
    plt.show()

    # 打印统计结果
    print("=== 融合性能统计 ===")
    print(f"最终位置误差:")
    print(f"  仅IMU: {pos_error_imu[-1]:.3f} m")
    print(f"  仅里程计: {pos_error_odom[-1]:.3f} m")
    print(f"  融合结果: {pos_error_fused[-1]:.3f} m")
    print(f"平均位置误差:")
    print(f"  仅IMU: {np.mean(pos_error_imu):.3f} m")
    print(f"  仅里程计: {np.mean(pos_error_odom):.3f} m")
    print(f"  融合结果: {np.mean(pos_error_fused):.3f} m")

# 运行融合演示
true_traj, fused_traj = demonstrate_imu_odometry_fusion()
```

这个阶段二的内容深入介绍了非线性系统处理、EKF算法实现，以及IMU和里程计数据的处理与融合。为学生提供了从理论到实践的完整学习路径，为下一阶段的综合项目打下了坚实基础。