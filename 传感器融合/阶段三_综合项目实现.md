# 阶段三：综合项目实现

## 第7讲：机器人运动学建模

### 7.1 完整的机器人运动学模型

#### 7.1.1 差分驱动机器人建模

```python
import numpy as np
import matplotlib.pyplot as plt
from scipy.integrate import odeint
from dataclasses import dataclass
from typing import List, Tuple, Optional
import json

@dataclass
class RobotParameters:
    """机器人参数配置"""
    wheel_base: float = 0.5      # 轮距 (m)
    wheel_radius: float = 0.1    # 轮半径 (m)
    max_linear_vel: float = 2.0  # 最大线速度 (m/s)
    max_angular_vel: float = 1.0 # 最大角速度 (rad/s)

    # 传感器参数
    imu_noise_gyro: float = 0.01
    imu_noise_accel: float = 0.1
    encoder_noise: float = 0.05
    gps_noise: float = 0.1

    # 滤波器参数
    process_noise_pos: float = 0.1
    process_noise_vel: float = 0.05
    process_noise_theta: float = 0.02

class DifferentialDriveRobot:
    """差分驱动机器人完整模型"""

    def __init__(self, params: RobotParameters):
        self.params = params

        # 状态：[x, y, theta, v, omega, vl, vr]
        # vl, vr: 左右轮速度
        self.state = np.zeros(7)

        # 传感器偏差
        self.gyro_bias = np.random.normal(0, 0.01, 3)
        self.accel_bias = np.random.normal(0, 0.05, 3)

        # 历史记录
        self.state_history = []
        self.sensor_history = []
        self.control_history = []

    def kinematics_model(self, state, t, control):
        """
        机器人运动学微分方程

        Args:
            state: [x, y, theta, v, omega, vl, vr]
            t: 时间（odeint需要）
            control: [vl_cmd, vr_cmd] 左右轮速度命令
        """
        x, y, theta, v, omega, vl, vr = state
        vl_cmd, vr_cmd = control

        # 轮速动力学（一阶滞后）
        tau = 0.1  # 时间常数
        dvl_dt = (vl_cmd - vl) / tau
        dvr_dt = (vr_cmd - vr) / tau

        # 机器人运动学
        v = (vl + vr) / 2
        omega = (vr - vl) / self.params.wheel_base

        dx_dt = v * np.cos(theta)
        dy_dt = v * np.sin(theta)
        dtheta_dt = omega
        dv_dt = 0  # 瞬时计算
        domega_dt = 0  # 瞬时计算

        return [dx_dt, dy_dt, dtheta_dt, dv_dt, domega_dt, dvl_dt, dvr_dt]

    def simulate_step(self, control, dt):
        """
        仿真一步

        Args:
            control: [vl_cmd, vr_cmd]
            dt: 时间步长
        """
        # 添加控制噪声
        noisy_control = control + np.random.normal(0, 0.02, 2)

        # 限制控制输入
        noisy_control = np.clip(noisy_control,
                               -self.params.max_linear_vel,
                               self.params.max_linear_vel)

        # 数值积分
        t_span = [0, dt]
        solution = odeint(self.kinematics_model, self.state, t_span,
                         args=(noisy_control,))

        # 更新状态
        self.state = solution[-1]

        # 保持角度在[-π, π]
        self.state[2] = ((self.state[2] + np.pi) % (2 * np.pi)) - np.pi

        # 记录历史
        self.state_history.append(self.state.copy())
        self.control_history.append(control.copy())

        return self.state.copy()

    def get_sensor_measurements(self, gps_available=True):
        """
        获取传感器测量值

        Args:
            gps_available: GPS是否可用

        Returns:
            sensors: 传感器数据字典
        """
        x, y, theta, v, omega, vl, vr = self.state

        sensors = {}

        # IMU数据
        # 陀螺仪（角速度）
        gyro_true = np.array([0, 0, omega])  # 只有yaw轴有角速度
        sensors['gyro'] = (gyro_true + self.gyro_bias +
                          np.random.normal(0, self.params.imu_noise_gyro, 3))

        # 加速度计
        # 简化：只考虑线性加速度和重力
        linear_accel = np.array([0, 0, 0])  # 简化为无线性加速度
        gravity = np.array([0, 0, 9.81])

        # 将重力转换到机器人坐标系
        cos_theta, sin_theta = np.cos(theta), np.sin(theta)
        rotation_matrix = np.array([
            [cos_theta, sin_theta, 0],
            [-sin_theta, cos_theta, 0],
            [0, 0, 1]
        ])

        gravity_body = rotation_matrix @ gravity
        accel_true = linear_accel + gravity_body

        sensors['accel'] = (accel_true + self.accel_bias +
                           np.random.normal(0, self.params.imu_noise_accel, 3))

        # 轮编码器
        sensors['wheel_encoders'] = np.array([vl, vr]) + \
                                   np.random.normal(0, self.params.encoder_noise, 2)

        # GPS（如果可用）
        if gps_available:
            sensors['gps'] = np.array([x, y]) + \
                            np.random.normal(0, self.params.gps_noise, 2)
        else:
            sensors['gps'] = None

        # 磁力计（简化的朝向测量）
        sensors['magnetometer'] = theta + np.random.normal(0, 0.05)

        # 记录传感器历史
        self.sensor_history.append(sensors.copy())

        return sensors

    def get_pose(self):
        """获取当前位姿"""
        return self.state[:3].copy()  # [x, y, theta]

    def get_velocity(self):
        """获取当前速度"""
        return self.state[3:5].copy()  # [v, omega]

# 演示完整机器人模型
def demonstrate_robot_model():
    """演示机器人完整模型"""

    params = RobotParameters()
    robot = DifferentialDriveRobot(params)

    # 仿真参数
    dt = 0.1
    duration = 20
    n_steps = int(duration / dt)

    # 生成运动轨迹
    for t in range(n_steps):
        time = t * dt

        # 不同的运动模式
        if time < 5:
            # 直线运动
            vl_cmd = vr_cmd = 1.0
        elif time < 10:
            # 左转
            vl_cmd, vr_cmd = 0.5, 1.5
        elif time < 15:
            # 右转
            vl_cmd, vr_cmd = 1.5, 0.5
        else:
            # 停止
            vl_cmd = vr_cmd = 0.0

        # 仿真一步
        robot.simulate_step([vl_cmd, vr_cmd], dt)

        # 获取传感器数据
        sensors = robot.get_sensor_measurements(gps_available=(time > 10))

    # 可视化结果
    visualize_robot_simulation(robot, dt)

    return robot

def visualize_robot_simulation(robot, dt):
    """可视化机器人仿真结果"""

    states = np.array(robot.state_history)
    sensors = robot.sensor_history

    fig, axes = plt.subplots(3, 2, figsize=(15, 12))

    time = np.arange(len(states)) * dt

    # 轨迹
    axes[0, 0].plot(states[:, 0], states[:, 1], 'b-', linewidth=2)
    axes[0, 0].set_aspect('equal')
    axes[0, 0].grid(True, alpha=0.3)
    axes[0, 0].set_title('机器人轨迹')
    axes[0, 0].set_xlabel('X (m)')
    axes[0, 0].set_ylabel('Y (m)')

    # 朝向
    axes[0, 1].plot(time, np.degrees(states[:, 2]), 'g-', linewidth=2)
    axes[0, 1].grid(True, alpha=0.3)
    axes[0, 1].set_title('朝向角')
    axes[0, 1].set_xlabel('时间 (s)')
    axes[0, 1].set_ylabel('朝向 (度)')

    # 速度
    axes[1, 0].plot(time, states[:, 3], 'r-', linewidth=2, label='线速度')
    axes[1, 0].plot(time, states[:, 4], 'b-', linewidth=2, label='角速度')
    axes[1, 0].legend()
    axes[1, 0].grid(True, alpha=0.3)
    axes[1, 0].set_title('机器人速度')
    axes[1, 0].set_xlabel('时间 (s)')
    axes[1, 0].set_ylabel('速度')

    # 轮速
    axes[1, 1].plot(time, states[:, 5], 'c-', linewidth=2, label='左轮')
    axes[1, 1].plot(time, states[:, 6], 'm-', linewidth=2, label='右轮')
    axes[1, 1].legend()
    axes[1, 1].grid(True, alpha=0.3)
    axes[1, 1].set_title('轮速')
    axes[1, 1].set_xlabel('时间 (s)')
    axes[1, 1].set_ylabel('轮速 (m/s)')

    # IMU数据
    gyro_data = [s['gyro'][2] for s in sensors]  # yaw轴角速度
    axes[2, 0].plot(time, gyro_data, 'orange', linewidth=2, alpha=0.7, label='IMU测量')
    axes[2, 0].plot(time, states[:, 4], 'b-', linewidth=2, label='真实值')
    axes[2, 0].legend()
    axes[2, 0].grid(True, alpha=0.3)
    axes[2, 0].set_title('陀螺仪 vs 真实角速度')
    axes[2, 0].set_xlabel('时间 (s)')
    axes[2, 0].set_ylabel('角速度 (rad/s)')

    # GPS数据（如果有）
    gps_x, gps_y = [], []
    gps_times = []
    for i, s in enumerate(sensors):
        if s['gps'] is not None:
            gps_x.append(s['gps'][0])
            gps_y.append(s['gps'][1])
            gps_times.append(time[i])

    if gps_x:
        axes[2, 1].plot(states[:, 0], states[:, 1], 'b-', linewidth=2, label='真实轨迹')
        axes[2, 1].scatter(gps_x, gps_y, color='red', s=20, alpha=0.7, label='GPS测量')
        axes[2, 1].set_aspect('equal')
        axes[2, 1].legend()
        axes[2, 1].grid(True, alpha=0.3)
        axes[2, 1].set_title('GPS测量 vs 真实位置')
        axes[2, 1].set_xlabel('X (m)')
        axes[2, 1].set_ylabel('Y (m)')

    plt.tight_layout()
    plt.show()

# 运行机器人模型演示
robot = demonstrate_robot_model()
```

### 7.2 多传感器融合EKF实现

#### 7.2.1 完整的多传感器融合系统

```python
class MultiSensorEKF:
    """多传感器扩展卡尔曼滤波器"""

    def __init__(self, robot_params: RobotParameters, initial_state=None,
                 initial_covariance=None):
        self.params = robot_params

        # 状态向量：[x, y, theta, vx, vy, omega, bias_gx, bias_gy, bias_gz]
        # 包含位置、速度和IMU偏差
        self.state_dim = 9

        if initial_state is None:
            self.x = np.zeros(self.state_dim)
        else:
            self.x = np.array(initial_state)

        if initial_covariance is None:
            self.P = np.eye(self.state_dim) * 0.1
            self.P[:3, :3] *= 10  # 位置初始不确定性较大
        else:
            self.P = np.array(initial_covariance)

        # 过程噪声协方差
        self.setup_process_noise()

        # 观测噪声协方差
        self.setup_observation_noise()

        # 历史记录
        self.history = {
            'x': [self.x.copy()],
            'P': [self.P.copy()],
            'innovations': [],
            'likelihoods': []
        }

    def setup_process_noise(self):
        """设置过程噪声协方差矩阵"""
        # 过程噪声：位置、速度、角度、IMU偏差
        q_pos = self.params.process_noise_pos ** 2
        q_vel = self.params.process_noise_vel ** 2
        q_theta = self.params.process_noise_theta ** 2
        q_bias = 0.001 ** 2  # IMU偏差变化很慢

        self.Q = np.diag([
            q_pos, q_pos, q_theta,        # 位置和朝向
            q_vel, q_vel, q_vel,          # 速度
            q_bias, q_bias, q_bias        # IMU偏差
        ])

    def setup_observation_noise(self):
        """设置观测噪声协方差矩阵"""
        self.R_imu = np.diag([
            self.params.imu_noise_gyro ** 2,    # 陀螺仪
            self.params.imu_noise_accel ** 2,   # 加速度计x
            self.params.imu_noise_accel ** 2    # 加速度计y
        ])

        self.R_encoder = np.diag([
            self.params.encoder_noise ** 2,     # 左轮
            self.params.encoder_noise ** 2      # 右轮
        ])

        self.R_gps = np.diag([
            self.params.gps_noise ** 2,         # GPS x
            self.params.gps_noise ** 2          # GPS y
        ])

        self.R_mag = np.array([[0.05 ** 2]])   # 磁力计

    def predict(self, dt):
        """预测步骤"""
        # 状态转移矩阵（线性化）
        F = np.eye(self.state_dim)

        # 位置更新
        F[0, 3] = dt  # x = x + vx * dt
        F[1, 4] = dt  # y = y + vy * dt
        F[2, 5] = dt  # theta = theta + omega * dt

        # 状态预测
        self.x = F @ self.x

        # 角度归一化
        self.x[2] = ((self.x[2] + np.pi) % (2 * np.pi)) - np.pi

        # 协方差预测
        self.P = F @ self.P @ F.T + self.Q

    def update_imu(self, gyro_measurement, accel_measurement):
        """IMU观测更新"""
        # 观测模型
        # gyro_z = omega + bias_gz
        # accel_x_body = vx * cos(theta) + vy * sin(theta)
        # accel_y_body = -vx * sin(theta) + vy * cos(theta)

        x, y, theta, vx, vy, omega, bias_gx, bias_gy, bias_gz = self.x

        cos_theta = np.cos(theta)
        sin_theta = np.sin(theta)

        # 预测观测
        h = np.array([
            omega + bias_gz,                          # 陀螺仪z
            vx * cos_theta + vy * sin_theta,         # 加速度计x（机器人坐标系）
            -vx * sin_theta + vy * cos_theta         # 加速度计y（机器人坐标系）
        ])

        # 观测雅可比矩阵
        H = np.zeros((3, self.state_dim))

        # 陀螺仪对状态的导数
        H[0, 5] = 1    # 对omega
        H[0, 8] = 1    # 对bias_gz

        # 加速度计对状态的导数
        H[1, 2] = -vx * sin_theta + vy * cos_theta  # 对theta
        H[1, 3] = cos_theta                         # 对vx
        H[1, 4] = sin_theta                         # 对vy

        H[2, 2] = -vx * cos_theta - vy * sin_theta  # 对theta
        H[2, 3] = -sin_theta                        # 对vx
        H[2, 4] = cos_theta                         # 对vy

        # 观测
        z = np.array([gyro_measurement[2], accel_measurement[0], accel_measurement[1]])

        # 更新
        self._ekf_update(z, h, H, self.R_imu)

    def update_encoders(self, encoder_measurements):
        """轮编码器观测更新"""
        vl, vr = encoder_measurements

        # 观测模型：从机器人速度计算轮速
        x, y, theta, vx, vy, omega, _, _, _ = self.x

        # 机器人线速度和角速度
        v_robot = np.sqrt(vx**2 + vy**2)

        # 轮速预测
        h = np.array([
            v_robot - omega * self.params.wheel_base / 2,  # 左轮
            v_robot + omega * self.params.wheel_base / 2   # 右轮
        ])

        # 观测雅可比矩阵
        H = np.zeros((2, self.state_dim))

        if v_robot > 1e-6:
            # 对vx, vy的导数
            dvdvx = vx / v_robot
            dvdvy = vy / v_robot

            H[0, 3] = dvdvx  # 左轮对vx
            H[0, 4] = dvdvy  # 左轮对vy
            H[0, 5] = -self.params.wheel_base / 2  # 左轮对omega

            H[1, 3] = dvdvx  # 右轮对vx
            H[1, 4] = dvdvy  # 右轮对vy
            H[1, 5] = self.params.wheel_base / 2   # 右轮对omega

        # 观测
        z = np.array([vl, vr])

        # 更新
        self._ekf_update(z, h, H, self.R_encoder)

    def update_gps(self, gps_measurement):
        """GPS观测更新"""
        # 观测模型：直接观测位置
        h = self.x[:2]  # [x, y]

        # 观测雅可比矩阵
        H = np.zeros((2, self.state_dim))
        H[0, 0] = 1  # 对x
        H[1, 1] = 1  # 对y

        # 观测
        z = gps_measurement

        # 更新
        self._ekf_update(z, h, H, self.R_gps)

    def update_magnetometer(self, mag_measurement):
        """磁力计观测更新"""
        # 观测模型：直接观测朝向
        h = np.array([self.x[2]])  # [theta]

        # 观测雅可比矩阵
        H = np.zeros((1, self.state_dim))
        H[0, 2] = 1  # 对theta

        # 角度差异处理
        z = np.array([mag_measurement])
        innovation = z - h
        innovation[0] = ((innovation[0] + np.pi) % (2 * np.pi)) - np.pi

        # 手动更新（处理角度问题）
        S = H @ self.P @ H.T + self.R_mag
        K = self.P @ H.T @ np.linalg.pinv(S)

        self.x = self.x + K @ innovation
        self.x[2] = ((self.x[2] + np.pi) % (2 * np.pi)) - np.pi

        I_KH = np.eye(self.state_dim) - K @ H
        self.P = I_KH @ self.P @ I_KH.T + K @ self.R_mag @ K.T

    def _ekf_update(self, z, h, H, R):
        """标准EKF更新步骤"""
        # 创新
        innovation = z - h

        # 创新协方差
        S = H @ self.P @ H.T + R

        # 卡尔曼增益
        try:
            K = self.P @ H.T @ np.linalg.inv(S)
        except np.linalg.LinAlgError:
            K = self.P @ H.T @ np.linalg.pinv(S)

        # 状态更新
        self.x = self.x + K @ innovation

        # 协方差更新（Joseph形式）
        I_KH = np.eye(self.state_dim) - K @ H
        self.P = I_KH @ self.P @ I_KH.T + K @ R @ K.T

        # 记录历史
        self.history['innovations'].append(innovation.copy())
        likelihood = self._compute_likelihood(innovation, S)
        self.history['likelihoods'].append(likelihood)

    def _compute_likelihood(self, innovation, S):
        """计算观测似然"""
        try:
            det_S = np.linalg.det(S)
            if det_S <= 0:
                return -np.inf

            log_likelihood = -0.5 * (len(innovation) * np.log(2 * np.pi) +
                                    np.log(det_S) +
                                    innovation.T @ np.linalg.inv(S) @ innovation)
            return log_likelihood
        except:
            return -np.inf

    def get_state(self):
        """获取当前状态估计"""
        return self.x.copy(), self.P.copy()

    def get_pose(self):
        """获取位姿估计"""
        return self.x[:3].copy()  # [x, y, theta]

    def get_velocity(self):
        """获取速度估计"""
        return self.x[3:6].copy()  # [vx, vy, omega]

    def update_history(self):
        """更新历史记录"""
        self.history['x'].append(self.x.copy())
        self.history['P'].append(self.P.copy())

# 完整的融合系统演示
def demonstrate_complete_fusion_system():
    """演示完整的多传感器融合系统"""

    print("初始化多传感器融合系统...")

    # 创建机器人和滤波器
    params = RobotParameters()
    robot = DifferentialDriveRobot(params)

    # 初始状态估计（带不确定性）
    initial_state = np.zeros(9)
    initial_covariance = np.eye(9)
    initial_covariance[:3, :3] *= 5.0  # 位置不确定性
    initial_covariance[3:6, 3:6] *= 1.0  # 速度不确定性
    initial_covariance[6:, 6:] *= 0.01  # IMU偏差不确定性

    ekf = MultiSensorEKF(params, initial_state, initial_covariance)

    # 仿真参数
    dt = 0.1
    duration = 30
    n_steps = int(duration / dt)

    # 存储结果
    true_poses = []
    estimated_poses = []

    print(f"开始仿真，总时长 {duration} 秒...")

    for t in range(n_steps):
        time = t * dt

        # 生成控制命令
        if time < 8:
            vl_cmd, vr_cmd = 1.0, 1.0      # 直线
        elif time < 16:
            vl_cmd, vr_cmd = 0.8, 1.2     # 左转
        elif time < 24:
            vl_cmd, vr_cmd = 1.2, 0.8     # 右转
        else:
            vl_cmd, vr_cmd = 1.0, 1.0      # 直线

        # 机器人仿真
        robot.simulate_step([vl_cmd, vr_cmd], dt)
        true_pose = robot.get_pose()
        true_poses.append(true_pose)

        # 获取传感器数据
        gps_available = time > 5 and time < 25  # GPS间歇性可用
        sensors = robot.get_sensor_measurements(gps_available)

        # EKF预测
        ekf.predict(dt)

        # 传感器更新
        # IMU更新
        ekf.update_imu(sensors['gyro'], sensors['accel'])

        # 轮编码器更新
        ekf.update_encoders(sensors['wheel_encoders'])

        # GPS更新（如果可用）
        if sensors['gps'] is not None:
            ekf.update_gps(sensors['gps'])

        # 磁力计更新（偶尔）
        if t % 5 == 0:  # 每0.5秒更新一次
            ekf.update_magnetometer(sensors['magnetometer'])

        # 记录结果
        estimated_pose = ekf.get_pose()
        estimated_poses.append(estimated_pose)
        ekf.update_history()

        # 进度显示
        if t % 50 == 0:
            print(f"进度: {time:.1f}s / {duration}s")

    print("仿真完成，开始分析结果...")

    # 分析和可视化结果
    analyze_fusion_performance(true_poses, estimated_poses, ekf, robot, dt)

    return robot, ekf, true_poses, estimated_poses

def analyze_fusion_performance(true_poses, estimated_poses, ekf, robot, dt):
    """分析融合性能"""

    true_poses = np.array(true_poses)
    estimated_poses = np.array(estimated_poses)

    # 计算误差
    position_errors = np.linalg.norm(true_poses[:, :2] - estimated_poses[:, :2], axis=1)

    theta_errors = true_poses[:, 2] - estimated_poses[:, 2]
    theta_errors = ((theta_errors + np.pi) % (2 * np.pi)) - np.pi
    theta_errors = np.abs(theta_errors)

    # 统计结果
    print("=== 融合性能分析 ===")
    print(f"最终位置误差: {position_errors[-1]:.3f} m")
    print(f"平均位置误差: {np.mean(position_errors):.3f} m")
    print(f"位置误差标准差: {np.std(position_errors):.3f} m")
    print(f"最大位置误差: {np.max(position_errors):.3f} m")
    print()
    print(f"最终朝向误差: {np.degrees(theta_errors[-1]):.1f} 度")
    print(f"平均朝向误差: {np.degrees(np.mean(theta_errors)):.1f} 度")
    print(f"朝向误差标准差: {np.degrees(np.std(theta_errors)):.1f} 度")

    # 可视化
    visualize_fusion_performance(true_poses, estimated_poses, ekf, robot, dt)

def visualize_fusion_performance(true_poses, estimated_poses, ekf, robot, dt):
    """可视化融合性能"""

    fig, axes = plt.subplots(3, 3, figsize=(18, 15))

    time = np.arange(len(true_poses)) * dt

    # 轨迹对比
    axes[0, 0].plot(true_poses[:, 0], true_poses[:, 1], 'g-',
                    linewidth=3, label='真实轨迹')
    axes[0, 0].plot(estimated_poses[:, 0], estimated_poses[:, 1], 'b-',
                    linewidth=2, label='EKF估计')

    # 添加GPS观测点
    gps_points = []
    gps_times = []
    for i, sensors in enumerate(robot.sensor_history):
        if sensors['gps'] is not None:
            gps_points.append(sensors['gps'])
            gps_times.append(time[i])

    if gps_points:
        gps_points = np.array(gps_points)
        axes[0, 0].scatter(gps_points[:, 0], gps_points[:, 1],
                          color='red', s=20, alpha=0.6, label='GPS观测')

    axes[0, 0].set_aspect('equal')
    axes[0, 0].legend()
    axes[0, 0].grid(True, alpha=0.3)
    axes[0, 0].set_title('轨迹对比')
    axes[0, 0].set_xlabel('X (m)')
    axes[0, 0].set_ylabel('Y (m)')

    # 位置误差
    position_errors = np.linalg.norm(true_poses[:, :2] - estimated_poses[:, :2], axis=1)
    axes[0, 1].plot(time, position_errors, 'r-', linewidth=2)
    axes[0, 1].grid(True, alpha=0.3)
    axes[0, 1].set_title('位置估计误差')
    axes[0, 1].set_xlabel('时间 (s)')
    axes[0, 1].set_ylabel('误差 (m)')

    # 朝向对比
    axes[0, 2].plot(time, np.degrees(true_poses[:, 2]), 'g-',
                    linewidth=2, label='真实朝向')
    axes[0, 2].plot(time, np.degrees(estimated_poses[:, 2]), 'b-',
                    linewidth=2, label='EKF估计')
    axes[0, 2].legend()
    axes[0, 2].grid(True, alpha=0.3)
    axes[0, 2].set_title('朝向对比')
    axes[0, 2].set_xlabel('时间 (s)')
    axes[0, 2].set_ylabel('朝向 (度)')

    # 状态不确定性
    state_history = ekf.history['x'][1:]  # 去掉初始状态
    covariance_history = ekf.history['P'][1:]

    # 位置不确定性
    pos_uncertainty = [np.sqrt(P[0,0] + P[1,1]) for P in covariance_history]
    axes[1, 0].plot(time, pos_uncertainty, 'purple', linewidth=2)
    axes[1, 0].grid(True, alpha=0.3)
    axes[1, 0].set_title('位置不确定性')
    axes[1, 0].set_xlabel('时间 (s)')
    axes[1, 0].set_ylabel('标准差 (m)')

    # 速度估计
    estimated_velocities = np.array([x[3:6] for x in state_history])
    axes[1, 1].plot(time, estimated_velocities[:, 0], 'r-', label='vx')
    axes[1, 1].plot(time, estimated_velocities[:, 1], 'g-', label='vy')
    axes[1, 1].plot(time, estimated_velocities[:, 2], 'b-', label='ω')
    axes[1, 1].legend()
    axes[1, 1].grid(True, alpha=0.3)
    axes[1, 1].set_title('速度估计')
    axes[1, 1].set_xlabel('时间 (s)')
    axes[1, 1].set_ylabel('速度')

    # IMU偏差估计
    estimated_biases = np.array([x[6:9] for x in state_history])
    axes[1, 2].plot(time, estimated_biases[:, 0], 'r-', label='bias_gx')
    axes[1, 2].plot(time, estimated_biases[:, 1], 'g-', label='bias_gy')
    axes[1, 2].plot(time, estimated_biases[:, 2], 'b-', label='bias_gz')
    axes[1, 2].legend()
    axes[1, 2].grid(True, alpha=0.3)
    axes[1, 2].set_title('IMU偏差估计')
    axes[1, 2].set_xlabel('时间 (s)')
    axes[1, 2].set_ylabel('偏差')

    # 创新序列
    if ekf.history['innovations']:
        # 计算创新序列的统计
        all_innovations = []
        for innov in ekf.history['innovations']:
            all_innovations.extend(innov)

        axes[2, 0].plot(all_innovations, 'orange', alpha=0.7)
        axes[2, 0].axhline(y=0, color='k', linestyle='--', alpha=0.5)
        axes[2, 0].grid(True, alpha=0.3)
        axes[2, 0].set_title('创新序列')
        axes[2, 0].set_xlabel('更新步骤')
        axes[2, 0].set_ylabel('创新值')

    # 似然演化
    if ekf.history['likelihoods']:
        axes[2, 1].plot(ekf.history['likelihoods'], 'purple', linewidth=2)
        axes[2, 1].grid(True, alpha=0.3)
        axes[2, 1].set_title('观测似然')
        axes[2, 1].set_xlabel('更新步骤')
        axes[2, 1].set_ylabel('对数似然')

    # 协方差矩阵演化（行列式）
    covariance_dets = [np.linalg.det(P[:3, :3]) for P in covariance_history]
    axes[2, 2].semilogy(time, covariance_dets, 'navy', linewidth=2)
    axes[2, 2].grid(True, alpha=0.3)
    axes[2, 2].set_title('位姿协方差行列式')
    axes[2, 2].set_xlabel('时间 (s)')
    axes[2, 2].set_ylabel('行列式值 (对数)')

    plt.tight_layout()
    plt.show()

# 运行完整的融合系统演示
robot, ekf, true_poses, estimated_poses = demonstrate_complete_fusion_system()
```

## 第8讲：GPS/INS组合导航

### 8.1 GPS定位原理与误差模型

#### 8.1.1 GPS误差源分析

```python
class GPSErrorModel:
    """GPS误差模型"""

    def __init__(self):
        # 误差参数
        self.satellite_clock_error_std = 2.0  # 卫星时钟误差 (m)
        self.ionospheric_error_std = 5.0      # 电离层误差 (m)
        self.tropospheric_error_std = 2.0     # 对流层误差 (m)
        self.multipath_error_std = 1.0        # 多径误差 (m)
        self.receiver_noise_std = 0.5         # 接收机噪声 (m)

        # 选择性可用性（模拟）
        self.sa_enabled = False
        self.sa_error_std = 50.0

        # DOP因子
        self.base_hdop = 1.2  # 基准水平DOP
        self.base_vdop = 1.8  # 基准垂直DOP

    def generate_gps_measurement(self, true_position, visible_satellites=6,
                               building_blockage=False):
        """
        生成GPS测量值

        Args:
            true_position: [x, y, z] 真实位置
            visible_satellites: 可见卫星数量
            building_blockage: 是否有建筑物遮挡

        Returns:
            gps_measurement: 含噪声的GPS位置
            accuracy: 精度估计
            available: GPS是否可用
        """
        # 检查GPS可用性
        if visible_satellites < 4:
            return None, np.inf, False

        # 计算DOP因子（几何精度因子）
        hdop = self.base_hdop * (8 / visible_satellites) ** 0.5
        vdop = self.base_vdop * (8 / visible_satellites) ** 0.5

        if building_blockage:
            hdop *= 2.0
            vdop *= 1.5

        # 各种误差源
        errors = []

        # 卫星相关误差
        sat_clock_error = np.random.normal(0, self.satellite_clock_error_std)
        ionospheric_error = np.random.normal(0, self.ionospheric_error_std)
        tropospheric_error = np.random.normal(0, self.tropospheric_error_std)

        # 接收机相关误差
        multipath_error = np.random.normal(0, self.multipath_error_std)
        if building_blockage:
            multipath_error *= 3.0

        receiver_noise = np.random.normal(0, self.receiver_noise_std)

        # 选择性可用性
        sa_error = 0
        if self.sa_enabled:
            sa_error = np.random.normal(0, self.sa_error_std)

        # 总的距离误差
        range_error = (sat_clock_error + ionospheric_error +
                      tropospheric_error + multipath_error +
                      receiver_noise + sa_error)

        # 转换为位置误差
        # 简化模型：距离误差通过DOP转换为位置误差
        position_error_std = range_error * hdop

        # 生成位置误差
        horizontal_error = np.random.normal(0, position_error_std, 2)
        vertical_error = np.random.normal(0, range_error * vdop)

        # GPS测量值
        gps_measurement = np.array([
            true_position[0] + horizontal_error[0],
            true_position[1] + horizontal_error[1],
            true_position[2] + vertical_error if len(true_position) > 2 else 0
        ])

        # 精度估计
        accuracy = position_error_std

        return gps_measurement[:2], accuracy, True

class INSGPSFusion:
    """INS/GPS组合导航系统"""

    def __init__(self, robot_params: RobotParameters):
        self.params = robot_params
        self.gps_model = GPSErrorModel()

        # 扩展状态：[x, y, z, vx, vy, vz, roll, pitch, yaw,
        #            bias_ax, bias_ay, bias_az, bias_gx, bias_gy, bias_gz]
        self.state_dim = 15
        self.x = np.zeros(self.state_dim)
        self.P = np.eye(self.state_dim) * 0.1

        # 重力向量
        self.gravity = np.array([0, 0, -9.81])

        # 过程噪声
        self.setup_process_noise()

        # 观测噪声
        self.R_gps = np.eye(2) * (2.0 ** 2)  # GPS位置噪声
        self.R_imu = np.eye(6) * 0.01 ** 2   # IMU噪声

        # 历史记录
        self.history = {
            'x': [self.x.copy()],
            'P': [self.P.copy()],
            'gps_available': [],
            'gps_accuracy': []
        }

    def setup_process_noise(self):
        """设置过程噪声"""
        # 位置、速度、姿态、偏差
        q = np.array([
            0.1, 0.1, 0.1,      # 位置噪声
            0.1, 0.1, 0.1,      # 速度噪声
            0.01, 0.01, 0.01,   # 姿态噪声
            0.001, 0.001, 0.001, # 加速度计偏差
            0.001, 0.001, 0.001  # 陀螺仪偏差
        ])

        self.Q = np.diag(q ** 2)

    def predict(self, imu_accel, imu_gyro, dt):
        """INS机械化预测"""
        # 提取状态
        pos = self.x[:3]
        vel = self.x[3:6]
        attitude = self.x[6:9]  # [roll, pitch, yaw]
        bias_a = self.x[9:12]
        bias_g = self.x[12:15]

        # IMU数据校正
        accel_corrected = imu_accel - bias_a
        gyro_corrected = imu_gyro - bias_g

        # 姿态更新（简化的欧拉角积分）
        new_attitude = attitude + gyro_corrected * dt

        # 保持角度在合理范围
        new_attitude[0] = np.clip(new_attitude[0], -np.pi/2, np.pi/2)  # roll
        new_attitude[1] = np.clip(new_attitude[1], -np.pi/2, np.pi/2)  # pitch
        new_attitude[2] = ((new_attitude[2] + np.pi) % (2*np.pi)) - np.pi  # yaw

        # 旋转矩阵（从机体坐标系到导航坐标系）
        R_bn = self.euler_to_rotation_matrix(new_attitude)

        # 速度更新
        accel_nav = R_bn @ accel_corrected + self.gravity
        new_vel = vel + accel_nav * dt

        # 位置更新
        new_pos = pos + vel * dt + 0.5 * accel_nav * dt**2

        # 更新状态
        self.x[:3] = new_pos
        self.x[3:6] = new_vel
        self.x[6:9] = new_attitude
        # 偏差保持不变（随机游走）

        # 线性化雅可比矩阵（简化）
        F = np.eye(self.state_dim)

        # 位置对速度的导数
        F[:3, 3:6] = np.eye(3) * dt

        # 速度对姿态的导数（简化）
        F[3:6, 6:9] = -self.skew_symmetric(R_bn @ accel_corrected) * dt

        # 协方差更新
        self.P = F @ self.P @ F.T + self.Q

    def update_gps(self, gps_measurement, gps_accuracy):
        """GPS更新"""
        # 观测模型：H矩阵
        H = np.zeros((2, self.state_dim))
        H[0, 0] = 1  # GPS观测x位置
        H[1, 1] = 1  # GPS观测y位置

        # 观测噪声（根据GPS精度动态调整）
        R_gps_adaptive = np.eye(2) * (gps_accuracy ** 2)

        # 预测观测
        h = self.x[:2]

        # 创新
        innovation = gps_measurement - h

        # 创新协方差
        S = H @ self.P @ H.T + R_gps_adaptive

        # 卡尔曼增益
        K = self.P @ H.T @ np.linalg.inv(S)

        # 状态更新
        self.x = self.x + K @ innovation

        # 协方差更新
        I_KH = np.eye(self.state_dim) - K @ H
        self.P = I_KH @ self.P @ I_KH.T + K @ R_gps_adaptive @ K.T

    def euler_to_rotation_matrix(self, euler_angles):
        """欧拉角转旋转矩阵"""
        roll, pitch, yaw = euler_angles

        # 旋转矩阵
        cos_r, sin_r = np.cos(roll), np.sin(roll)
        cos_p, sin_p = np.cos(pitch), np.sin(pitch)
        cos_y, sin_y = np.cos(yaw), np.sin(yaw)

        R = np.array([
            [cos_p*cos_y, -cos_p*sin_y, sin_p],
            [sin_r*sin_p*cos_y + cos_r*sin_y, -sin_r*sin_p*sin_y + cos_r*cos_y, -sin_r*cos_p],
            [-cos_r*sin_p*cos_y + sin_r*sin_y, cos_r*sin_p*sin_y + sin_r*cos_y, cos_r*cos_p]
        ])

        return R

    def skew_symmetric(self, vector):
        """向量的反对称矩阵"""
        x, y, z = vector
        return np.array([
            [0, -z, y],
            [z, 0, -x],
            [-y, x, 0]
        ])

    def get_position(self):
        """获取位置估计"""
        return self.x[:3].copy()

    def get_velocity(self):
        """获取速度估计"""
        return self.x[3:6].copy()

    def get_attitude(self):
        """获取姿态估计"""
        return self.x[6:9].copy()

# 演示GPS/INS组合导航
def demonstrate_gps_ins_navigation():
    """演示GPS/INS组合导航"""

    print("初始化GPS/INS组合导航系统...")

    # 系统参数
    params = RobotParameters()
    ins_gps = INSGPSFusion(params)

    # 仿真参数
    dt = 0.1
    duration = 60  # 1分钟
    n_steps = int(duration / dt)

    # 模拟轨迹（3D螺旋轨迹）
    true_trajectory = []
    imu_measurements = []
    gps_measurements = []

    # 初始状态
    true_pos = np.array([0.0, 0.0, 0.0])
    true_vel = np.array([0.0, 0.0, 0.0])
    true_attitude = np.array([0.0, 0.0, 0.0])

    print("生成仿真数据...")

    for t in range(n_steps):
        time = t * dt

        # 生成运动轨迹（螺旋上升）
        radius = 10.0
        angular_freq = 0.1
        climb_rate = 0.05

        # 目标速度
        target_vel = np.array([
            -radius * angular_freq * np.sin(angular_freq * time),
            radius * angular_freq * np.cos(angular_freq * time),
            climb_rate
        ])

        # 目标加速度
        target_accel = np.array([
            -radius * angular_freq**2 * np.cos(angular_freq * time),
            -radius * angular_freq**2 * np.sin(angular_freq * time),
            0
        ])

        # 更新真实状态
        true_vel = target_vel
        true_pos += true_vel * dt

        # 简单的姿态模型（朝向运动方向）
        if np.linalg.norm(true_vel[:2]) > 0.1:
            true_attitude[2] = np.arctan2(true_vel[1], true_vel[0])

        true_trajectory.append({
            'position': true_pos.copy(),
            'velocity': true_vel.copy(),
            'attitude': true_attitude.copy()
        })

        # 生成IMU测量
        # 加速度（机体坐标系）
        R_bn = ins_gps.euler_to_rotation_matrix(true_attitude)
        accel_nav = target_accel - ins_gps.gravity
        accel_body = R_bn.T @ accel_nav

        # 添加IMU噪声和偏差
        accel_measured = accel_body + np.random.normal(0, 0.1, 3)
        gyro_measured = np.array([0, 0, angular_freq]) + np.random.normal(0, 0.01, 3)

        imu_measurements.append({
            'accel': accel_measured,
            'gyro': gyro_measured
        })

        # 生成GPS测量
        # 模拟不同的GPS条件
        if time < 20:
            # 开阔环境，GPS良好
            visible_sats = 8
            building_block = False
        elif time < 40:
            # 城市环境，有遮挡
            visible_sats = 5
            building_block = True
        else:
            # GPS失效
            visible_sats = 2
            building_block = True

        gps_meas, gps_acc, gps_avail = ins_gps.gps_model.generate_gps_measurement(
            true_pos, visible_sats, building_block)

        gps_measurements.append({
            'position': gps_meas,
            'accuracy': gps_acc,
            'available': gps_avail
        })

    print("开始INS/GPS融合处理...")

    # INS/GPS融合
    estimated_trajectory = []

    for t in range(n_steps):
        # INS预测
        imu = imu_measurements[t]
        ins_gps.predict(imu['accel'], imu['gyro'], dt)

        # GPS更新（如果可用）
        gps = gps_measurements[t]
        if gps['available'] and gps['accuracy'] < 20.0:  # 精度阈值
            ins_gps.update_gps(gps['position'], gps['accuracy'])

        # 记录结果
        estimated_trajectory.append({
            'position': ins_gps.get_position(),
            'velocity': ins_gps.get_velocity(),
            'attitude': ins_gps.get_attitude()
        })

        # 更新历史
        ins_gps.history['x'].append(ins_gps.x.copy())
        ins_gps.history['P'].append(ins_gps.P.copy())
        ins_gps.history['gps_available'].append(gps['available'])
        ins_gps.history['gps_accuracy'].append(gps['accuracy'] if gps['available'] else np.inf)

        if t % 100 == 0:
            print(f"处理进度: {t*dt:.1f}s / {duration}s")

    print("分析结果...")

    # 分析和可视化
    analyze_ins_gps_performance(true_trajectory, estimated_trajectory,
                               gps_measurements, ins_gps, dt)

    return true_trajectory, estimated_trajectory, ins_gps

def analyze_ins_gps_performance(true_traj, est_traj, gps_meas, ins_gps, dt):
    """分析INS/GPS性能"""

    # 提取数据
    true_positions = np.array([t['position'] for t in true_traj])
    est_positions = np.array([t['position'] for t in est_traj])

    # 计算误差
    position_errors = np.linalg.norm(true_positions - est_positions, axis=1)

    # GPS可用性
    gps_available = [g['available'] for g in gps_meas]
    gps_accuracy = [g['accuracy'] if g['available'] else np.inf for g in gps_meas]

    # 可视化
    fig = plt.figure(figsize=(20, 15))

    # 3D轨迹
    ax1 = fig.add_subplot(3, 3, 1, projection='3d')
    ax1.plot(true_positions[:, 0], true_positions[:, 1], true_positions[:, 2],
             'g-', linewidth=3, label='真实轨迹')
    ax1.plot(est_positions[:, 0], est_positions[:, 1], est_positions[:, 2],
             'b-', linewidth=2, label='INS/GPS估计')

    # 添加GPS观测点
    gps_pos = []
    for i, g in enumerate(gps_meas):
        if g['available'] and g['accuracy'] < 20:
            gps_pos.append([g['position'][0], g['position'][1], est_positions[i, 2]])

    if gps_pos:
        gps_pos = np.array(gps_pos)
        ax1.scatter(gps_pos[:, 0], gps_pos[:, 1], gps_pos[:, 2],
                   color='red', s=10, alpha=0.6, label='GPS观测')

    ax1.set_xlabel('X (m)')
    ax1.set_ylabel('Y (m)')
    ax1.set_zlabel('Z (m)')
    ax1.legend()
    ax1.set_title('3D轨迹对比')

    # 其他子图
    time = np.arange(len(true_traj)) * dt

    # 位置误差
    ax2 = fig.add_subplot(3, 3, 2)
    ax2.plot(time, position_errors, 'r-', linewidth=2)
    ax2.grid(True, alpha=0.3)
    ax2.set_title('位置估计误差')
    ax2.set_xlabel('时间 (s)')
    ax2.set_ylabel('误差 (m)')

    # GPS可用性和精度
    ax3 = fig.add_subplot(3, 3, 3)
    availability = [1 if avail else 0 for avail in gps_available]
    ax3.plot(time, availability, 'g-', linewidth=2, label='GPS可用性')

    # 精度（右轴）
    ax3_twin = ax3.twinx()
    valid_accuracy = [acc if acc < 50 else np.nan for acc in gps_accuracy]
    ax3_twin.plot(time, valid_accuracy, 'orange', alpha=0.7, label='GPS精度')

    ax3.set_xlabel('时间 (s)')
    ax3.set_ylabel('可用性')
    ax3_twin.set_ylabel('精度 (m)')
    ax3.set_title('GPS状态')
    ax3.legend(loc='upper left')
    ax3_twin.legend(loc='upper right')

    # 水平轨迹
    ax4 = fig.add_subplot(3, 3, 4)
    ax4.plot(true_positions[:, 0], true_positions[:, 1], 'g-',
             linewidth=3, label='真实轨迹')
    ax4.plot(est_positions[:, 0], est_positions[:, 1], 'b-',
             linewidth=2, label='INS/GPS估计')
    ax4.set_aspect('equal')
    ax4.legend()
    ax4.grid(True, alpha=0.3)
    ax4.set_title('水平面轨迹')
    ax4.set_xlabel('X (m)')
    ax4.set_ylabel('Y (m)')

    # 高度对比
    ax5 = fig.add_subplot(3, 3, 5)
    ax5.plot(time, true_positions[:, 2], 'g-', linewidth=2, label='真实高度')
    ax5.plot(time, est_positions[:, 2], 'b-', linewidth=2, label='估计高度')
    ax5.legend()
    ax5.grid(True, alpha=0.3)
    ax5.set_title('高度对比')
    ax5.set_xlabel('时间 (s)')
    ax5.set_ylabel('高度 (m)')

    # 速度对比
    ax6 = fig.add_subplot(3, 3, 6)
    true_velocities = np.array([t['velocity'] for t in true_traj])
    est_velocities = np.array([t['velocity'] for t in est_traj])

    ax6.plot(time, np.linalg.norm(true_velocities, axis=1), 'g-',
             linewidth=2, label='真实速度')
    ax6.plot(time, np.linalg.norm(est_velocities, axis=1), 'b-',
             linewidth=2, label='估计速度')
    ax6.legend()
    ax6.grid(True, alpha=0.3)
    ax6.set_title('速度大小对比')
    ax6.set_xlabel('时间 (s)')
    ax6.set_ylabel('速度 (m/s)')

    # 位置不确定性
    ax7 = fig.add_subplot(3, 3, 7)
    pos_uncertainty = [np.sqrt(P[0,0] + P[1,1] + P[2,2]) for P in ins_gps.history['P'][1:]]
    ax7.plot(time, pos_uncertainty, 'purple', linewidth=2)
    ax7.grid(True, alpha=0.3)
    ax7.set_title('位置不确定性')
    ax7.set_xlabel('时间 (s)')
    ax7.set_ylabel('标准差 (m)')

    # 误差统计分析
    ax8 = fig.add_subplot(3, 3, 8)

    # 分段分析（GPS可用和不可用）
    gps_periods = []
    no_gps_periods = []

    for i, avail in enumerate(gps_available):
        if avail and gps_accuracy[i] < 20:
            gps_periods.append(position_errors[i])
        else:
            no_gps_periods.append(position_errors[i])

    data_to_plot = []
    labels = []

    if gps_periods:
        data_to_plot.append(gps_periods)
        labels.append('GPS可用')

    if no_gps_periods:
        data_to_plot.append(no_gps_periods)
        labels.append('GPS不可用')

    if data_to_plot:
        ax8.boxplot(data_to_plot, labels=labels)
        ax8.set_title('分段误差统计')
        ax8.set_ylabel('位置误差 (m)')

    # 累积误差分布
    ax9 = fig.add_subplot(3, 3, 9)
    ax9.hist(position_errors, bins=30, alpha=0.7, density=True)
    ax9.set_title('位置误差分布')
    ax9.set_xlabel('位置误差 (m)')
    ax9.set_ylabel('概率密度')
    ax9.grid(True, alpha=0.3)

    plt.tight_layout()
    plt.show()

    # 打印统计结果
    print("=== INS/GPS组合导航性能分析 ===")
    print(f"最终位置误差: {position_errors[-1]:.2f} m")
    print(f"平均位置误差: {np.mean(position_errors):.2f} m")
    print(f"位置误差标准差: {np.std(position_errors):.2f} m")
    print(f"最大位置误差: {np.max(position_errors):.2f} m")

    if gps_periods and no_gps_periods:
        print(f"GPS可用时平均误差: {np.mean(gps_periods):.2f} m")
        print(f"GPS不可用时平均误差: {np.mean(no_gps_periods):.2f} m")

    gps_availability_rate = np.mean(gps_available)
    print(f"GPS可用率: {gps_availability_rate:.1%}")

# 运行GPS/INS演示
true_traj, est_traj, ins_gps_system = demonstrate_gps_ins_navigation()
```

这个第7和第8讲的内容提供了完整的机器人运动学建模和GPS/INS组合导航系统。学生可以通过这些实践了解真实的导航系统是如何工作的，以及各种传感器在不同环境条件下的表现。