# 扩展练习和高级话题

## 阶段一扩展练习

### 练习1：多维卡尔曼滤波
**难度**：⭐⭐
**预计时间**：3-4小时

#### 任务描述
实现2D平面内的物体跟踪，包含位置和速度的估计。

#### 具体要求
```python
# 练习1：2D运动跟踪
class Exercise1_2DTracking:
    """2D运动跟踪练习"""

    def __init__(self):
        # TODO: 设计4状态卡尔曼滤波器 [x, y, vx, vy]
        # 状态转移矩阵设计
        # 观测矩阵设计（只观测位置）
        # 噪声矩阵设计
        pass

    def setup_kalman_filter(self, dt=0.1):
        """设置卡尔曼滤波器参数"""
        # TODO: 实现4×4状态转移矩阵
        # 提示：位置更新 = 位置 + 速度 * dt
        #       速度保持不变（恒速模型）

        F = np.array([
            [1, 0, dt, 0],
            [0, 1, 0, dt],
            [0, 0, 1, 0],
            [0, 0, 0, 1]
        ])

        # TODO: 设计观测矩阵（只观测位置）
        H = # 你的代码

        # TODO: 设计过程噪声协方差矩阵
        Q = # 你的代码

        # TODO: 设计观测噪声协方差矩阵
        R = # 你的代码

        return F, H, Q, R

    def generate_2d_trajectory(self, n_steps=100):
        """生成2D轨迹"""
        # TODO: 生成有趣的2D轨迹
        # 建议：螺旋、8字形、或随机游走
        trajectory = []

        # 示例：圆形轨迹
        for i in range(n_steps):
            t = i * 0.1
            x = 5 * np.cos(0.5 * t)
            y = 5 * np.sin(0.5 * t)
            trajectory.append([x, y])

        return np.array(trajectory)

    def run_tracking_experiment(self):
        """运行2D跟踪实验"""
        # TODO: 实现完整的2D跟踪
        # 1. 生成真实轨迹
        # 2. 添加观测噪声
        # 3. 运行卡尔曼滤波
        # 4. 分析性能
        # 5. 可视化结果
        pass

# 提示：运行示例
# exercise1 = Exercise1_2DTracking()
# exercise1.run_tracking_experiment()
```

#### 扩展挑战
1. 实现不同的运动模型（恒加速度、转弯模型）
2. 比较不同噪声水平下的性能
3. 添加速度观测，分析性能变化

---

### 练习2：自适应卡尔曼滤波
**难度**：⭐⭐⭐
**预计时间**：5-6小时

#### 任务描述
实现能够自动调整噪声参数的自适应卡尔曼滤波器。

#### 理论基础
自适应滤波通过创新序列的统计特性来估计噪声参数：

$$\hat{R}_k = \frac{1}{N} \sum_{i=k-N+1}^{k} \nu_i \nu_i^T - H_k P_{k|k-1} H_k^T$$

其中 $\nu_i$ 是创新序列。

#### 实现框架
```python
class AdaptiveKalmanFilter:
    """自适应卡尔曼滤波器"""

    def __init__(self, base_kf, adaptation_method='innovation_based'):
        self.base_kf = base_kf
        self.adaptation_method = adaptation_method

        # 自适应参数
        self.innovation_window_size = 10
        self.innovation_history = []

        # 噪声估计历史
        self.R_estimates = []
        self.Q_estimates = []

    def adaptive_R_estimation(self):
        """基于创新序列估计观测噪声"""
        if len(self.innovation_history) < self.innovation_window_size:
            return self.base_kf.R

        # TODO: 实现观测噪声自适应估计
        # 1. 计算创新序列的样本协方差
        # 2. 减去理论协方差的确定性部分
        # 3. 更新R矩阵

        innovations = np.array(self.innovation_history[-self.innovation_window_size:])

        # 计算经验协方差
        empirical_cov = np.cov(innovations.T)

        # TODO: 实现完整的R估计算法
        estimated_R = # 你的代码

        return estimated_R

    def adaptive_Q_estimation(self):
        """基于状态预测误差估计过程噪声"""
        # TODO: 实现过程噪声自适应估计
        # 提示：可以使用最大似然估计或贝叶斯方法
        pass

    def update(self, observation):
        """自适应更新步骤"""
        # 标准预测
        self.base_kf.predict()

        # 计算创新
        predicted_obs = self.base_kf.H @ self.base_kf.x
        innovation = observation - predicted_obs
        self.innovation_history.append(innovation)

        # 自适应噪声估计
        if self.adaptation_method == 'innovation_based':
            self.base_kf.R = self.adaptive_R_estimation()

        # 标准更新
        self.base_kf.update(observation)

        # 记录噪声估计
        self.R_estimates.append(self.base_kf.R.copy())

# 测试框架
def test_adaptive_filter():
    """测试自适应滤波器"""
    # TODO: 设计测试场景
    # 1. 噪声水平突然变化的场景
    # 2. 比较自适应vs固定参数的性能
    # 3. 分析收敛速度和稳定性
    pass
```

---

### 练习3：鲁棒卡尔曼滤波
**难度**：⭐⭐⭐⭐
**预计时间**：6-8小时

#### 任务描述
实现能够处理异常值（outliers）的鲁棒卡尔曼滤波器。

#### 方法选择
1. **Huber滤波器**：使用Huber损失函数
2. **Student-t滤波器**：假设重尾分布
3. **异常值检测**：基于马氏距离的异常值剔除

#### 实现框架
```python
class RobustKalmanFilter:
    """鲁棒卡尔曼滤波器"""

    def __init__(self, base_kf, robust_method='huber'):
        self.base_kf = base_kf
        self.robust_method = robust_method

        # 鲁棒参数
        self.huber_threshold = 2.0
        self.outlier_threshold = 3.0  # 马氏距离阈值

        # 统计记录
        self.outlier_count = 0
        self.total_updates = 0

    def detect_outlier(self, innovation, innovation_covariance):
        """异常值检测"""
        # TODO: 实现基于马氏距离的异常值检测
        # 马氏距离 = sqrt(innovation^T * S^-1 * innovation)

        try:
            mahalanobis_distance = np.sqrt(
                innovation.T @ np.linalg.inv(innovation_covariance) @ innovation
            )

            is_outlier = mahalanobis_distance > self.outlier_threshold
            return is_outlier, mahalanobis_distance

        except np.linalg.LinAlgError:
            return False, 0

    def huber_weight(self, innovation, innovation_covariance):
        """计算Huber权重"""
        # TODO: 实现Huber权重计算
        _, mahalanobis_dist = self.detect_outlier(innovation, innovation_covariance)

        if mahalanobis_dist <= self.huber_threshold:
            weight = 1.0
        else:
            weight = self.huber_threshold / mahalanobis_dist

        return weight

    def robust_update(self, observation):
        """鲁棒更新步骤"""
        # 预测步骤
        self.base_kf.predict()

        # 计算创新和创新协方差
        predicted_obs = self.base_kf.H @ self.base_kf.x
        innovation = observation - predicted_obs
        S = self.base_kf.H @ self.base_kf.P @ self.base_kf.H.T + self.base_kf.R

        # 异常值检测
        is_outlier, mahal_dist = self.detect_outlier(innovation, S)

        if self.robust_method == 'outlier_rejection' and is_outlier:
            # 拒绝异常值，只进行预测
            self.outlier_count += 1
            return

        elif self.robust_method == 'huber':
            # Huber滤波
            weight = self.huber_weight(innovation, S)

            # 调整卡尔曼增益
            K = self.base_kf.P @ self.base_kf.H.T @ np.linalg.inv(S)
            K_robust = weight * K

            # 鲁棒更新
            self.base_kf.x = self.base_kf.x + K_robust @ innovation
            self.base_kf.P = (np.eye(len(self.base_kf.x)) -
                             K_robust @ self.base_kf.H) @ self.base_kf.P

        else:
            # 标准更新
            self.base_kf.update(observation)

        self.total_updates += 1

# 测试场景生成
def generate_outlier_scenario():
    """生成包含异常值的测试场景"""
    # TODO: 生成包含outliers的观测序列
    # 1. 正常观测：高斯噪声
    # 2. 异常观测：大幅偏离的测量值
    # 3. 分析鲁棒滤波器的性能

    n_steps = 200
    outlier_probability = 0.05
    outlier_magnitude = 10.0

    true_trajectory = []
    observations = []
    outlier_flags = []

    for i in range(n_steps):
        # 真实位置
        true_pos = np.sin(0.1 * i)
        true_trajectory.append(true_pos)

        # 观测生成
        if np.random.random() < outlier_probability:
            # 异常值
            obs = true_pos + np.random.normal(0, outlier_magnitude)
            outlier_flags.append(True)
        else:
            # 正常观测
            obs = true_pos + np.random.normal(0, 0.1)
            outlier_flags.append(False)

        observations.append(obs)

    return true_trajectory, observations, outlier_flags
```

---

## 阶段二扩展练习

### 练习4：无迹卡尔曼滤波（UKF）
**难度**：⭐⭐⭐⭐
**预计时间**：8-10小时

#### 任务描述
实现无迹卡尔曼滤波器，并与EKF性能进行比较。

#### 理论背景
UKF使用确定性采样（Unscented Transform）来处理非线性变换，避免了EKF的线性化误差。

#### 实现框架
```python
class UnscentedKalmanFilter:
    """无迹卡尔曼滤波器"""

    def __init__(self, motion_model, observation_model, Q, R, x0, P0):
        self.motion_model = motion_model
        self.observation_model = observation_model
        self.Q = Q
        self.R = R
        self.x = x0
        self.P = P0

        # UKF参数
        self.n = len(x0)  # 状态维度
        self.alpha = 1e-3  # 扩散参数
        self.beta = 2.0    # 先验分布参数
        self.kappa = 3 - self.n  # 缩放参数

        # 计算权重
        self.compute_weights()

    def compute_weights(self):
        """计算UT变换权重"""
        lambda_param = self.alpha**2 * (self.n + self.kappa) - self.n

        # 均值权重
        self.Wm = np.zeros(2 * self.n + 1)
        self.Wm[0] = lambda_param / (self.n + lambda_param)
        self.Wm[1:] = 1 / (2 * (self.n + lambda_param))

        # 协方差权重
        self.Wc = self.Wm.copy()
        self.Wc[0] += (1 - self.alpha**2 + self.beta)

    def generate_sigma_points(self, x, P):
        """生成Sigma点"""
        # TODO: 实现Sigma点生成算法
        # 1. 计算矩阵平方根
        # 2. 生成2n+1个Sigma点
        # 3. 返回Sigma点矩阵

        n = len(x)
        lambda_param = self.alpha**2 * (n + self.kappa) - n

        # 计算协方差矩阵的Cholesky分解
        try:
            sqrt_matrix = np.linalg.cholesky((n + lambda_param) * P)
        except np.linalg.LinAlgError:
            # 如果Cholesky分解失败，使用特征值分解
            eigenvals, eigenvecs = np.linalg.eigh(P)
            sqrt_matrix = eigenvecs @ np.diag(np.sqrt(np.maximum(eigenvals, 0))) @ eigenvecs.T
            sqrt_matrix *= np.sqrt(n + lambda_param)

        # 生成Sigma点
        sigma_points = np.zeros((2 * n + 1, n))
        sigma_points[0] = x

        for i in range(n):
            sigma_points[i + 1] = x + sqrt_matrix[i]
            sigma_points[n + i + 1] = x - sqrt_matrix[i]

        return sigma_points

    def unscented_transform(self, sigma_points, weights_m, weights_c, noise_cov=None):
        """无迹变换"""
        # TODO: 实现无迹变换
        # 1. 计算变换后的均值
        # 2. 计算变换后的协方差

        # 计算均值
        x_mean = np.sum(weights_m[:, np.newaxis] * sigma_points, axis=0)

        # 计算协方差
        P_cov = np.zeros((sigma_points.shape[1], sigma_points.shape[1]))
        for i, (point, weight) in enumerate(zip(sigma_points, weights_c)):
            diff = point - x_mean
            P_cov += weight * np.outer(diff, diff)

        if noise_cov is not None:
            P_cov += noise_cov

        return x_mean, P_cov

    def predict(self, control=None):
        """UKF预测步骤"""
        # TODO: 实现UKF预测
        # 1. 生成Sigma点
        # 2. 通过运动模型传播Sigma点
        # 3. 使用无迹变换计算预测状态和协方差

        # 生成Sigma点
        sigma_points = self.generate_sigma_points(self.x, self.P)

        # 传播Sigma点
        propagated_points = np.zeros_like(sigma_points)
        for i, point in enumerate(sigma_points):
            propagated_points[i] = self.motion_model(point, control)

        # 无迹变换
        self.x, self.P = self.unscented_transform(
            propagated_points, self.Wm, self.Wc, self.Q
        )

    def update(self, observation):
        """UKF更新步骤"""
        # TODO: 实现UKF更新
        # 1. 生成Sigma点
        # 2. 通过观测模型传播Sigma点
        # 3. 计算预测观测和创新协方差
        # 4. 计算卡尔曼增益和更新状态

        # 生成Sigma点
        sigma_points = self.generate_sigma_points(self.x, self.P)

        # 传播到观测空间
        obs_points = np.zeros((len(sigma_points), len(observation)))
        for i, point in enumerate(sigma_points):
            obs_points[i] = self.observation_model(point)

        # 预测观测
        z_pred, Pz = self.unscented_transform(obs_points, self.Wm, self.Wc, self.R)

        # 交叉协方差
        Pxz = np.zeros((len(self.x), len(observation)))
        for i, (x_point, z_point, weight) in enumerate(zip(sigma_points, obs_points, self.Wc)):
            dx = x_point - self.x
            dz = z_point - z_pred
            Pxz += weight * np.outer(dx, dz)

        # 卡尔曼增益
        K = Pxz @ np.linalg.inv(Pz)

        # 状态更新
        innovation = observation - z_pred
        self.x = self.x + K @ innovation
        self.P = self.P - K @ Pz @ K.T

# UKF vs EKF比较实验
def compare_ukf_ekf():
    """比较UKF和EKF性能"""
    # TODO: 设计比较实验
    # 1. 使用强非线性系统
    # 2. 比较估计精度
    # 3. 分析计算复杂度
    # 4. 可视化性能差异
    pass
```

---

### 练习5：粒子滤波器
**难度**：⭐⭐⭐⭐⭐
**预计时间**：10-12小时

#### 任务描述
实现粒子滤波器，处理高度非线性和非高斯的估计问题。

#### 理论基础
粒子滤波使用加权粒子集合来表示后验概率分布，特别适合处理非线性、非高斯问题。

#### 实现框架
```python
class ParticleFilter:
    """粒子滤波器"""

    def __init__(self, motion_model, observation_model,
                 likelihood_func, n_particles=1000):
        self.motion_model = motion_model
        self.observation_model = observation_model
        self.likelihood_func = likelihood_func
        self.n_particles = n_particles

        # 粒子状态
        self.particles = None
        self.weights = None
        self.state_estimate = None
        self.covariance_estimate = None

        # 重采样参数
        self.resample_threshold = 0.5  # 有效粒子数阈值

    def initialize_particles(self, initial_state, initial_covariance):
        """初始化粒子"""
        # TODO: 从初始分布采样粒子
        self.particles = np.random.multivariate_normal(
            initial_state, initial_covariance, self.n_particles
        )
        self.weights = np.ones(self.n_particles) / self.n_particles

    def predict(self, control=None, process_noise_cov=None):
        """预测步骤：粒子传播"""
        # TODO: 实现粒子预测
        # 1. 通过运动模型传播每个粒子
        # 2. 添加过程噪声

        for i in range(self.n_particles):
            # 传播粒子
            self.particles[i] = self.motion_model(self.particles[i], control)

            # 添加过程噪声
            if process_noise_cov is not None:
                noise = np.random.multivariate_normal(
                    np.zeros(len(self.particles[i])), process_noise_cov
                )
                self.particles[i] += noise

    def update(self, observation):
        """更新步骤：权重计算"""
        # TODO: 实现权重更新
        # 1. 计算每个粒子的似然
        # 2. 更新权重
        # 3. 归一化权重

        for i in range(self.n_particles):
            predicted_obs = self.observation_model(self.particles[i])
            self.weights[i] *= self.likelihood_func(observation, predicted_obs)

        # 归一化权重
        weight_sum = np.sum(self.weights)
        if weight_sum > 0:
            self.weights /= weight_sum
        else:
            # 权重退化，重新初始化
            self.weights = np.ones(self.n_particles) / self.n_particles

    def resample(self):
        """重采样"""
        # TODO: 实现重采样算法
        # 1. 计算有效粒子数
        # 2. 决定是否重采样
        # 3. 执行系统重采样或多项式重采样

        # 计算有效粒子数
        eff_particles = 1.0 / np.sum(self.weights ** 2)

        if eff_particles < self.resample_threshold * self.n_particles:
            # 系统重采样
            indices = self.systematic_resample()
            self.particles = self.particles[indices]
            self.weights = np.ones(self.n_particles) / self.n_particles

    def systematic_resample(self):
        """系统重采样"""
        # TODO: 实现系统重采样算法
        cumulative_sum = np.cumsum(self.weights)
        indices = []

        # 生成均匀分布的随机数
        u = np.random.random() / self.n_particles

        for i in range(self.n_particles):
            u_i = u + i / self.n_particles
            # 找到对应的粒子索引
            index = np.searchsorted(cumulative_sum, u_i)
            indices.append(min(index, self.n_particles - 1))

        return np.array(indices)

    def estimate_state(self):
        """估计状态（加权平均）"""
        self.state_estimate = np.average(self.particles, weights=self.weights, axis=0)

        # 估计协方差
        diff = self.particles - self.state_estimate
        self.covariance_estimate = np.cov(diff.T, aweights=self.weights)

        return self.state_estimate, self.covariance_estimate

# 非线性非高斯测试场景
def nonlinear_nongaussian_scenario():
    """非线性非高斯测试场景"""
    # TODO: 设计具有挑战性的测试场景
    # 1. 强非线性运动模型
    # 2. 非高斯噪声
    # 3. 多模态分布
    # 4. 比较PF、UKF、EKF性能

    def bearing_only_tracking():
        """纯方位跟踪问题"""
        # 运动模型：恒速直线运动
        def motion_model(state, control):
            dt = 0.1
            F = np.array([[1, 0, dt, 0],
                         [0, 1, 0, dt],
                         [0, 0, 1, 0],
                         [0, 0, 0, 1]])
            return F @ state

        # 观测模型：方位角
        def observation_model(state):
            x, y = state[:2]
            bearing = np.arctan2(y, x)
            return np.array([bearing])

        # 似然函数
        def likelihood_func(observation, predicted_obs):
            angle_diff = observation[0] - predicted_obs[0]
            angle_diff = ((angle_diff + np.pi) % (2*np.pi)) - np.pi
            return np.exp(-0.5 * angle_diff**2 / (0.1**2))

        return motion_model, observation_model, likelihood_func

    return bearing_only_tracking()
```

---

## 阶段三扩展练习

### 练习6：SLAM基础实现
**难度**：⭐⭐⭐⭐⭐
**预计时间**：15-20小时

#### 任务描述
实现基于EKF的同时定位与地图构建（EKF-SLAM）。

#### 理论基础
SLAM问题：在未知环境中，同时估计机器人位姿和环境地图。

#### 实现框架
```python
class EKF_SLAM:
    """基于EKF的SLAM系统"""

    def __init__(self, robot_state_dim=3, max_landmarks=100):
        self.robot_state_dim = robot_state_dim  # [x, y, theta]
        self.max_landmarks = max_landmarks

        # 状态向量：[robot_pose, landmark1, landmark2, ...]
        # 每个地标：[x, y]
        self.state_dim = robot_state_dim + 2 * max_landmarks

        # 初始化状态和协方差
        self.x = np.zeros(self.state_dim)
        self.P = np.eye(self.state_dim) * 1000  # 大的初始不确定性
        self.P[:robot_state_dim, :robot_state_dim] = np.eye(robot_state_dim) * 0.1

        # 地标管理
        self.landmark_count = 0
        self.landmark_ids = {}  # 观测ID到状态索引的映射

        # 数据关联
        self.association_threshold = 3.0  # 马氏距离阈值

    def get_robot_state(self):
        """获取机器人状态"""
        return self.x[:self.robot_state_dim]

    def get_robot_covariance(self):
        """获取机器人状态协方差"""
        return self.P[:self.robot_state_dim, :self.robot_state_dim]

    def get_landmark_state(self, landmark_idx):
        """获取地标状态"""
        start_idx = self.robot_state_dim + 2 * landmark_idx
        return self.x[start_idx:start_idx + 2]

    def motion_update(self, control, dt):
        """运动更新"""
        # TODO: 实现机器人运动更新
        # 1. 更新机器人状态
        # 2. 计算雅可比矩阵
        # 3. 更新协方差

        # 提取机器人状态
        robot_x, robot_y, robot_theta = self.get_robot_state()
        v, omega = control  # 线速度和角速度

        # 运动模型
        if abs(omega) < 1e-6:
            # 直线运动
            new_x = robot_x + v * np.cos(robot_theta) * dt
            new_y = robot_y + v * np.sin(robot_theta) * dt
            new_theta = robot_theta
        else:
            # 圆弧运动
            new_theta = robot_theta + omega * dt
            new_x = robot_x + (v/omega) * (np.sin(new_theta) - np.sin(robot_theta))
            new_y = robot_y + (v/omega) * (np.cos(robot_theta) - np.cos(new_theta))

        # 角度归一化
        new_theta = ((new_theta + np.pi) % (2*np.pi)) - np.pi

        # 更新状态
        self.x[0] = new_x
        self.x[1] = new_y
        self.x[2] = new_theta

        # 计算雅可比矩阵
        Fx = np.eye(self.state_dim)

        if abs(omega) < 1e-6:
            Fx[0, 2] = -v * np.sin(robot_theta) * dt
            Fx[1, 2] = v * np.cos(robot_theta) * dt
        else:
            Fx[0, 2] = (v/omega) * (np.cos(new_theta) - np.cos(robot_theta))
            Fx[1, 2] = (v/omega) * (np.sin(new_theta) - np.sin(robot_theta))

        # 过程噪声
        Q_robot = np.diag([0.1, 0.1, 0.05]) * dt  # 调整噪声大小
        Q_full = np.zeros((self.state_dim, self.state_dim))
        Q_full[:self.robot_state_dim, :self.robot_state_dim] = Q_robot

        # 协方差更新
        self.P = Fx @ self.P @ Fx.T + Q_full

    def observation_update(self, observations):
        """观测更新"""
        # TODO: 实现观测更新
        # 1. 数据关联
        # 2. 新地标初始化
        # 3. EKF更新

        for obs in observations:
            range_obs, bearing_obs = obs['range'], obs['bearing']

            # 数据关联
            associated_landmark = self.data_association(range_obs, bearing_obs)

            if associated_landmark is None:
                # 新地标
                self.add_new_landmark(range_obs, bearing_obs)
            else:
                # 更新已知地标
                self.update_landmark(associated_landmark, range_obs, bearing_obs)

    def data_association(self, range_obs, bearing_obs):
        """数据关联"""
        # TODO: 实现最近邻数据关联
        min_distance = float('inf')
        best_match = None

        robot_state = self.get_robot_state()
        robot_x, robot_y, robot_theta = robot_state

        for landmark_idx in range(self.landmark_count):
            # 预测观测
            landmark_pos = self.get_landmark_state(landmark_idx)
            predicted_range, predicted_bearing = self.predict_observation(
                robot_state, landmark_pos
            )

            # 计算马氏距离
            innovation = np.array([range_obs - predicted_range,
                                 bearing_obs - predicted_bearing])

            # 角度差异归一化
            innovation[1] = ((innovation[1] + np.pi) % (2*np.pi)) - np.pi

            # 观测雅可比和协方差
            H = self.compute_observation_jacobian(robot_state, landmark_pos, landmark_idx)
            R = np.diag([0.1, 0.05])  # 观测噪声
            S = H @ self.P @ H.T + R

            try:
                mahal_dist = innovation.T @ np.linalg.inv(S) @ innovation
                if mahal_dist < min_distance and mahal_dist < self.association_threshold:
                    min_distance = mahal_dist
                    best_match = landmark_idx
            except np.linalg.LinAlgError:
                continue

        return best_match

    def predict_observation(self, robot_state, landmark_pos):
        """预测观测"""
        robot_x, robot_y, robot_theta = robot_state
        landmark_x, landmark_y = landmark_pos

        dx = landmark_x - robot_x
        dy = landmark_y - robot_y

        predicted_range = np.sqrt(dx**2 + dy**2)
        predicted_bearing = np.arctan2(dy, dx) - robot_theta
        predicted_bearing = ((predicted_bearing + np.pi) % (2*np.pi)) - np.pi

        return predicted_range, predicted_bearing

    def add_new_landmark(self, range_obs, bearing_obs):
        """添加新地标"""
        if self.landmark_count >= self.max_landmarks:
            return

        robot_state = self.get_robot_state()
        robot_x, robot_y, robot_theta = robot_state

        # 初始化地标位置
        landmark_x = robot_x + range_obs * np.cos(bearing_obs + robot_theta)
        landmark_y = robot_y + range_obs * np.sin(bearing_obs + robot_theta)

        # 添加到状态向量
        landmark_idx = self.landmark_count
        start_idx = self.robot_state_dim + 2 * landmark_idx

        self.x[start_idx] = landmark_x
        self.x[start_idx + 1] = landmark_y

        # 初始化地标协方差（大不确定性）
        self.P[start_idx:start_idx+2, start_idx:start_idx+2] = np.eye(2) * 100

        self.landmark_count += 1

    def update_landmark(self, landmark_idx, range_obs, bearing_obs):
        """更新已知地标"""
        robot_state = self.get_robot_state()
        landmark_pos = self.get_landmark_state(landmark_idx)

        # 预测观测
        predicted_range, predicted_bearing = self.predict_observation(
            robot_state, landmark_pos
        )

        # 创新
        innovation = np.array([range_obs - predicted_range,
                             bearing_obs - predicted_bearing])
        innovation[1] = ((innovation[1] + np.pi) % (2*np.pi)) - np.pi

        # 观测雅可比
        H = self.compute_observation_jacobian(robot_state, landmark_pos, landmark_idx)

        # 观测噪声
        R = np.diag([0.1, 0.05])

        # EKF更新
        S = H @ self.P @ H.T + R
        K = self.P @ H.T @ np.linalg.inv(S)

        self.x = self.x + K @ innovation
        self.P = (np.eye(self.state_dim) - K @ H) @ self.P

    def compute_observation_jacobian(self, robot_state, landmark_pos, landmark_idx):
        """计算观测雅可比矩阵"""
        # TODO: 计算观测模型对状态的雅可比矩阵
        robot_x, robot_y, robot_theta = robot_state
        landmark_x, landmark_y = landmark_pos

        dx = landmark_x - robot_x
        dy = landmark_y - robot_y
        r = np.sqrt(dx**2 + dy**2)

        H = np.zeros((2, self.state_dim))

        if r > 1e-6:
            # 对机器人状态的导数
            H[0, 0] = -dx / r        # drange/dx_robot
            H[0, 1] = -dy / r        # drange/dy_robot
            H[0, 2] = 0              # drange/dtheta_robot

            H[1, 0] = dy / (r**2)    # dbearing/dx_robot
            H[1, 1] = -dx / (r**2)   # dbearing/dy_robot
            H[1, 2] = -1             # dbearing/dtheta_robot

            # 对地标状态的导数
            landmark_start_idx = self.robot_state_dim + 2 * landmark_idx
            H[0, landmark_start_idx] = dx / r      # drange/dx_landmark
            H[0, landmark_start_idx + 1] = dy / r  # drange/dy_landmark

            H[1, landmark_start_idx] = -dy / (r**2)      # dbearing/dx_landmark
            H[1, landmark_start_idx + 1] = dx / (r**2)   # dbearing/dy_landmark

        return H

# SLAM测试和可视化
def test_ekf_slam():
    """测试EKF-SLAM"""
    # TODO: 设计SLAM测试场景
    # 1. 生成机器人轨迹
    # 2. 生成地标观测
    # 3. 运行SLAM算法
    # 4. 可视化结果（轨迹、地图、不确定性）

    slam = EKF_SLAM()

    # 仿真参数
    dt = 0.1
    duration = 30

    # 真实地标位置
    true_landmarks = np.array([
        [10, 10], [10, -10], [-10, 10], [-10, -10],
        [5, 0], [-5, 0], [0, 5], [0, -5]
    ])

    # 真实机器人轨迹
    true_trajectory = []
    estimated_trajectory = []
    estimated_landmarks = []

    # 初始状态
    true_pose = np.array([0, 0, 0])

    for t in np.arange(0, duration, dt):
        # 控制输入（圆形轨迹）
        v = 1.0  # 线速度
        omega = 0.3  # 角速度
        control = [v, omega]

        # 真实运动
        true_pose = simulate_robot_motion(true_pose, control, dt)
        true_trajectory.append(true_pose.copy())

        # SLAM预测
        slam.motion_update(control, dt)

        # 生成观测
        observations = generate_landmark_observations(true_pose, true_landmarks)

        # SLAM更新
        if observations:
            slam.observation_update(observations)

        # 记录估计结果
        estimated_trajectory.append(slam.get_robot_state().copy())

        current_landmarks = []
        for i in range(slam.landmark_count):
            landmark_pos = slam.get_landmark_state(i)
            current_landmarks.append(landmark_pos.copy())
        estimated_landmarks.append(current_landmarks)

    # 可视化SLAM结果
    visualize_slam_results(true_trajectory, estimated_trajectory,
                         true_landmarks, estimated_landmarks, slam)

def simulate_robot_motion(pose, control, dt):
    """仿真机器人运动"""
    x, y, theta = pose
    v, omega = control

    if abs(omega) < 1e-6:
        new_x = x + v * np.cos(theta) * dt
        new_y = y + v * np.sin(theta) * dt
        new_theta = theta
    else:
        new_theta = theta + omega * dt
        new_x = x + (v/omega) * (np.sin(new_theta) - np.sin(theta))
        new_y = y + (v/omega) * (np.cos(theta) - np.cos(new_theta))

    new_theta = ((new_theta + np.pi) % (2*np.pi)) - np.pi

    return np.array([new_x, new_y, new_theta])

def generate_landmark_observations(robot_pose, landmarks, max_range=15):
    """生成地标观测"""
    observations = []
    robot_x, robot_y, robot_theta = robot_pose

    for landmark in landmarks:
        dx = landmark[0] - robot_x
        dy = landmark[1] - robot_y
        range_true = np.sqrt(dx**2 + dy**2)

        if range_true <= max_range:
            bearing_true = np.arctan2(dy, dx) - robot_theta
            bearing_true = ((bearing_true + np.pi) % (2*np.pi)) - np.pi

            # 添加噪声
            range_obs = range_true + np.random.normal(0, 0.1)
            bearing_obs = bearing_true + np.random.normal(0, 0.05)

            observations.append({
                'range': range_obs,
                'bearing': bearing_obs
            })

    return observations
```

---

## 高级研究话题

### 话题1：多机器人协同定位
**难度**：⭐⭐⭐⭐⭐

#### 研究内容
- 分布式滤波算法
- 信息融合策略
- 通信约束下的协同估计
- 一致性算法

#### 实现要点
```python
class MultiRobotLocalization:
    """多机器人协同定位"""

    def __init__(self, robot_id, n_robots):
        self.robot_id = robot_id
        self.n_robots = n_robots

        # 分布式滤波器
        self.local_filter = None
        self.consensus_weights = np.ones(n_robots) / n_robots

        # 通信网络
        self.neighbors = []
        self.communication_range = 10.0

    def distributed_update(self, local_estimate, neighbor_estimates):
        """分布式一致性更新"""
        # TODO: 实现分布式一致性算法
        pass

    def information_fusion(self, measurements):
        """信息融合"""
        # TODO: 实现信息形式的状态估计
        pass
```

### 话题2：深度学习增强的状态估计
**难度**：⭐⭐⭐⭐⭐

#### 研究内容
- 神经网络辅助的卡尔曼滤波
- 学习的运动模型和观测模型
- 端到端的深度滤波器
- 不确定性量化

#### 实现框架
```python
import torch
import torch.nn as nn

class LearnedKalmanFilter(nn.Module):
    """学习增强的卡尔曼滤波"""

    def __init__(self, state_dim, obs_dim):
        super().__init__()

        # 学习的运动模型
        self.motion_net = nn.Sequential(
            nn.Linear(state_dim + 2, 64),  # +2 for control
            nn.ReLU(),
            nn.Linear(64, 64),
            nn.ReLU(),
            nn.Linear(64, state_dim)
        )

        # 学习的观测模型
        self.observation_net = nn.Sequential(
            nn.Linear(state_dim, 32),
            nn.ReLU(),
            nn.Linear(32, obs_dim)
        )

        # 学习的噪声估计
        self.noise_net = nn.Sequential(
            nn.Linear(state_dim + obs_dim, 32),
            nn.ReLU(),
            nn.Linear(32, state_dim + obs_dim),
            nn.Softplus()
        )

    def forward(self, state, control, observation):
        """前向传播"""
        # TODO: 实现神经网络增强的滤波过程
        pass
```

### 话题3：量子增强传感器融合
**难度**：⭐⭐⭐⭐⭐

#### 研究内容
- 量子传感器建模
- 量子信息融合
- 量子不确定性原理的影响
- 量子算法在状态估计中的应用

### 话题4：边缘计算环境下的实时融合
**难度**：⭐⭐⭐⭐

#### 研究内容
- 计算资源受限的滤波算法
- 自适应采样率控制
- 能耗优化的状态估计
- 云-边协同计算

---

## 项目建议

### 初学者项目
1. **个人定位追踪器**：使用手机传感器实现个人位置跟踪
2. **无人机姿态估计**：融合IMU和磁力计估计无人机姿态
3. **室内定位系统**：基于WiFi信号强度的位置估计

### 中级项目
1. **自动驾驶仿真**：实现车辆的多传感器融合定位
2. **机器人SLAM**：在ROS环境中实现完整的SLAM系统
3. **运动捕捉系统**：多相机fusion的人体运动跟踪

### 高级项目
1. **分布式传感器网络**：多节点协同的环境监测系统
2. **水下机器人导航**：在GPS拒止环境下的导航系统
3. **太空飞行器姿态控制**：考虑微重力环境的姿态估计

---

## 学习资源推荐

### 经典教材
1. **"Probabilistic Robotics"** - Thrun, Burgard, Fox
2. **"Optimal State Estimation"** - Dan Simon
3. **"Applied Optimal Estimation"** - Gelb et al.

### 在线课程
1. **Coursera**: "State Estimation and Localization for Self-Driving Cars"
2. **edX**: "Autonomous Mobile Robots"
3. **Udacity**: "Sensor Fusion Engineer Nanodegree"

### 开源项目
1. **robot_localization** (ROS包)
2. **GTSAM** (因子图优化库)
3. **OpenSLAM** (SLAM算法集合)

### 会议和期刊
1. **IEEE Transactions on Robotics**
2. **International Conference on Robotics and Automation (ICRA)**
3. **Robotics: Science and Systems (RSS)**

这些扩展练习和高级话题为不同水平的学生提供了丰富的学习和研究机会，从基础的多维滤波到前沿的量子传感器融合，形成了完整的学习路径。